-- MySQL dump 10.13  Distrib 8.0.43, for Win64 (x86_64)
--
-- Host: 127.0.0.1    Database: codepulse_learning
-- ------------------------------------------------------
-- Server version	9.4.0

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!50503 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `chapters`
--

DROP TABLE IF EXISTS `chapters`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `chapters` (
  `chapter_id` int NOT NULL AUTO_INCREMENT,
  `course_id` int NOT NULL,
  `chapter_name` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL,
  `chapter_order` int DEFAULT '1',
  `created_at` timestamp NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`chapter_id`),
  KEY `course_id` (`course_id`),
  CONSTRAINT `chapters_ibfk_1` FOREIGN KEY (`course_id`) REFERENCES `courses` (`course_id`) ON DELETE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=29 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `chapters`
--

LOCK TABLES `chapters` WRITE;
/*!40000 ALTER TABLE `chapters` DISABLE KEYS */;
INSERT INTO `chapters` VALUES (2,2,'Chương 1: Giới thiệu',1,'2026-01-28 04:33:59'),(6,2,'Chương 2: Biến, Comment và Built-in',1,'2026-01-28 04:57:30'),(7,2,'Chương 3: Toán tử, kiểu dữ liệu',1,'2026-01-28 05:53:36'),(8,2,'Chương 4: Làm việc với hàm',1,'2026-01-28 09:14:52'),(9,2,'Chương 5: Làm việc với chuỗi',1,'2026-01-28 09:29:44'),(10,2,'Chương 6: Làm việc với số ',1,'2026-01-28 09:39:41'),(11,2,'Chương 7: Mảng trong Javascript',1,'2026-01-28 14:08:10'),(12,2,'Chương 8: Object',1,'2026-01-28 14:18:26'),(13,2,'Chương 9: Lệnh rẽ nhánh và toán tử 3 ngôi',1,'2026-01-28 14:39:21'),(14,2,'Chương 10: Vòng lặp',1,'2026-01-28 14:49:55'),(15,2,'Chương 11: Callback',1,'2026-01-29 01:50:45'),(16,2,'Chương 12: HTML DOM',1,'2026-01-29 02:01:36'),(17,2,'Chương 13: JSON, Fetch',1,'2026-01-29 06:52:08'),(18,2,'Chương 14: Các khái niệm nâng cao & ES6',1,'2026-01-29 07:05:36'),(19,3,'Chương 1: Giới thiệu',1,'2026-01-29 07:11:51'),(20,3,'Chương 2: Biến và kiểu dữ liệu',1,'2026-01-29 07:29:51'),(21,3,'Chương 3: Cấu trúc điều khiển và vòng lặp',1,'2026-01-29 13:39:30'),(22,3,'Chương 4: Mảng (Arrays)',1,'2026-01-29 13:55:35'),(23,3,'Chương 5: Chuỗi (String)',1,'2026-01-29 14:02:15'),(24,3,'Chương 6: Hàm (Function)',1,'2026-01-29 14:10:18'),(25,3,'Chương 7: Con trỏ (Pointers)',1,'2026-01-29 14:33:12'),(26,3,'Chương 8: Struct',1,'2026-01-29 14:46:36'),(27,3,'Chương 9: Làm việc với File?',1,'2026-01-29 14:55:36'),(28,3,'Chương 10: Lập trình hướng đối tượng (OOP)',1,'2026-01-29 15:03:32');
/*!40000 ALTER TABLE `chapters` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `coding_exercises`
--

DROP TABLE IF EXISTS `coding_exercises`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `coding_exercises` (
  `exercise_id` int NOT NULL AUTO_INCREMENT,
  `lesson_id` int DEFAULT NULL,
  `chapter_id` int DEFAULT NULL,
  `exercise_order` int DEFAULT '1',
  `title` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL,
  `instruction` text COLLATE utf8mb4_unicode_ci NOT NULL,
  `difficulty` enum('Easy','Medium','Hard') COLLATE utf8mb4_unicode_ci DEFAULT 'Easy',
  `starter_code` text COLLATE utf8mb4_unicode_ci,
  `solution_code` text COLLATE utf8mb4_unicode_ci,
  `programming_language` varchar(50) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `created_at` timestamp NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`exercise_id`),
  KEY `lesson_id` (`lesson_id`),
  KEY `chapter_id` (`chapter_id`),
  CONSTRAINT `coding_exercises_ibfk_1` FOREIGN KEY (`lesson_id`) REFERENCES `lessons` (`lesson_id`) ON DELETE CASCADE,
  CONSTRAINT `coding_exercises_ibfk_2` FOREIGN KEY (`chapter_id`) REFERENCES `chapters` (`chapter_id`) ON DELETE CASCADE,
  CONSTRAINT `chk_location` CHECK (((`lesson_id` is not null) or (`chapter_id` is not null)))
) ENGINE=InnoDB AUTO_INCREMENT=96 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `coding_exercises`
--

LOCK TABLES `coding_exercises` WRITE;
/*!40000 ALTER TABLE `coding_exercises` DISABLE KEYS */;
INSERT INTO `coding_exercises` VALUES (1,NULL,6,1,'Khai báo và sử dụng biến','1. Khai báo một biến có tên là `courseName` và gán cho nó giá trị là chuỗi `\"CodePulse Learning\"`.\n2. Sử dụng hàm `console.log()` để in giá trị của biến `courseName` ra màn hình kiểm tra.','Easy','// 1. Khai báo biến courseName\n// ...\n\n// 2. In biến courseName ra màn hình\n// ...','var courseName = \"CodePulse Learning\";\nconsole.log(courseName);','javascript','2026-01-29 08:12:34'),(2,NULL,6,1,'Tính tổng hai số','1. Khai báo biến `a` và gán cho nó giá trị là số `15`.\n2. Khai báo biến `b` và gán cho nó giá trị là số `25`.\n3. Khai báo biến `tong` và gán cho nó giá trị là tổng của `a` và `b`.\n4. Sử dụng `console.log()` để in giá trị của biến `tong` ra màn hình.','Easy','// 1. Khai báo biến a và b\n// ...\n\n// 2. Tính tổng gán vào biến tong\nvar tong = ...;\n\n// 3. In kết quả ra màn hình\n// ...','var a = 15;\nvar b = 25;\nvar tong = a + b;\nconsole.log(tong);','javascript','2026-01-29 08:18:25'),(3,7,NULL,1,'Tính chu vi hình chữ nhật','1. Khai báo biến `dai` với giá trị là 10.\n2. Khai báo biến `rong` với giá trị là 5.\n3. Sử dụng công thức [(dai + rong) * 2] để tính chu vi và gán vào biến `chuVi`.\n4. In biến `chuVi` ra màn hình.','Easy','var dai = 10;\nvar rong = 5;\n\n// Tính chu vi\nvar chuVi = ...;\n\n// In kết quả\nconsole.log(chuVi);','var dai = 10;\nvar rong = 5;\nvar chuVi = (dai + rong) * 2;\nconsole.log(chuVi);','javascript','2026-01-29 08:22:02'),(4,7,NULL,1,'Ghép họ và tên','1. Khai báo biến [ho] với giá trị \"Nguyễn\".\n2. Khai báo biến [ten] với giá trị \"Văn A\".\n3. Tạo biến `hoVaTen` bằng cách nối biến [ho] + một dấu cách \" \" + biến `ten`.\n4. In `hoVaTen` ra màn hình.','Easy','var ho = \"Nguyễn\";\nvar ten = \"Văn A\";\n\n// Ghép chuỗi vào biến hoVaTen\nvar hoVaTen = ...;\n\nconsole.log(hoVaTen);','var ho = \"Nguyễn\";\nvar ten = \"Văn A\";\nvar hoVaTen = ho + \" \" + ten;\nconsole.log(hoVaTen);','javascript','2026-01-29 08:22:56'),(5,65,NULL,1,'Chào hỏi theo tên','Viết chương trình thực hiện các bước sau:\n1. Khai báo một biến kiểu chuỗi (string) để lưu tên người dùng.\n2. Nhập tên từ bàn phím.\n3. In ra màn hình lời chào theo định dạng: Xin chao [Tên]! Lưu ý: In chính xác từng ký tự (không dấu tiếng Việt) và kết thúc bằng dấu chấm than.','Easy','#include <iostream>\n#include <string>\nusing namespace std;\n\nint main() {\n    // Viết code của bạn tại đây\n\n    return 0;\n}','#include <iostream>\n#include <string>\nusing namespace std;\n\nint main() {\n    string name;\n    cin >> name;\n    cout << \"Xin chao \" << name << \"!\";\n    return 0;\n}','cpp','2026-01-30 13:51:33'),(6,65,NULL,1,'Thông tin sinh viên','Viết chương trình nhập vào một số nguyên là Mã số sinh viên và một chuỗi ký tự là Tên lớp. Sau đó in ra màn hình theo định dạng: MSSV: [MaSo], Lop: [TenLop].','Easy','#include <iostream>\n#include <string>\nusing namespace std;\n\nint main() {\n    int mssv;\n    string lop;\n    // Viết code nhập mssv và lop, sau đó in ra theo định dạng yêu cầu\n\n    return 0;\n}','#include <iostream>\n#include <string>\nusing namespace std;\n\nint main() {\n    int mssv;\n    string lop;\n    cin >> mssv >> lop;\n    cout << \"MSSV: \" << mssv << \", Lop: \" << lop;\n    return 0;\n}','cpp','2026-01-30 13:54:51'),(7,66,NULL,1,'Chuyển đổi ký tự sang mã ASCII','Trong lập trình, mỗi ký tự đều tương ứng với một mã số nguyên (ASCII). Viết chương trình nhập vào một ký tự bất kỳ từ bàn phím, sau đó in ra mã số nguyên tương ứng của ký tự đó. Gợi ý: Sử dụng kiểu dữ liệu char để nhận đầu vào và ép kiểu sang int để in ra kết quả.','Easy','#include <iostream>\nusing namespace std;\n\nint main() {\n    char c;\n    // Nhập ký tự và in ra mã ASCII của nó\n\n    return 0;\n}','#include <iostream>\nusing namespace std;\n\nint main() {\n    char c;\n    cin >> c;\n    cout << (int)c;\n    return 0;\n}','cpp','2026-01-30 13:56:40'),(8,66,NULL,1,'Tính chu vi hình tròn (Số thực)','Viết chương trình nhập vào bán kính $r$ của một hình tròn (là một số thực). Hãy tính chu vi của hình tròn đó theo công thức: $C = 2 \\times 3.14 \\times r$.\nYêu cầu: Sử dụng kiểu dữ liệu double để đảm bảo độ chính xác.','Easy','#include <iostream>\nusing namespace std;\n\nint main() {\n    double r;\n    // Nhập bán kính và tính chu vi với PI = 3.14\n\n    return 0;\n}','#include <iostream>\nusing namespace std;\n\nint main() {\n    double r;\n    cin >> r;\n    cout << 2 * 3.14 * r;\n    return 0;\n}','cpp','2026-01-30 13:57:35'),(9,67,NULL,1,'Tính thuế VAT cố định','Một cửa hàng áp dụng mức thuế VAT cố định là 10% cho mọi mặt hàng. Viết chương trình nhập vào giá tiền chưa thuế của một sản phẩm (số nguyên), sau đó tính và in ra số tiền thuế phải trả. Yêu cầu: Khai báo mức thuế 0.1 là một hằng số bằng từ khóa const.','Easy','#include <iostream>\nusing namespace std;\n\nint main() {\n    // Khai báo hằng số THUE = 0.1 tại đây\n    int giaGoc;\n    // Nhập giaGoc và in ra tiền thuế (giaGoc * THUE)\n\n    return 0;\n}','#include <iostream>\nusing namespace std;\n\nint main() {\n    const double THUE = 0.1;\n    int giaGoc;\n    cin >> giaGoc;\n    cout << giaGoc * THUE;\n    return 0;\n}','cpp','2026-01-30 13:58:57'),(10,67,NULL,1,'Đổi từ km/h sang m/s','Để đổi từ vận tốc $km/h$ sang $m/s$, ta chia giá trị cho 3.6. Viết chương trình nhập vào vận tốc $v$ (số thực, đơn vị $km/h$) và in ra vận tốc tương ứng ở đơn vị $m/s$.\nYêu cầu: Sử dụng hằng số cho giá trị quy đổi 3.6.','Easy','#include <iostream>\nusing namespace std;\n\nint main() {\n    const double HE_SO = 3.6;\n    double v_kmh;\n    // Nhập v_kmh và in ra v_ms = v_kmh / HE_SO\n\n    return 0;\n}','#include <iostream>\nusing namespace std;\n\nint main() {\n    const double HE_SO = 3.6;\n    double v_kmh;\n    cin >> v_kmh;\n    cout << v_kmh / HE_SO;\n    return 0;\n}','cpp','2026-01-30 13:59:49'),(11,68,NULL,1,'Tính biểu thức số học','Viết chương trình nhập vào hai số nguyên a và b. Hãy thực hiện các bước sau:\n1. Tính tổng của a và b, gán kết quả vào biến tong.\n2. Tính tích của a và b, gán kết quả vào biến tich.\n3. Tính hiệu của a trừ b, gán kết quả vào biến hieu.\n4. In ra ba kết quả trên, mỗi số cách nhau một khoảng trắng.','Easy','#include <iostream>\nusing namespace std;\n\nint main() {\n    int a, b;\n    // Nhập a, b và thực hiện các phép toán gán\n\n    return 0;\n}','#include <iostream>\nusing namespace std;\n\nint main() {\n    int a, b, tong, hieu, tich;\n    cin >> a >> b;\n    tong = a + b;\n    hieu = a - b;\n    tich = a * b;\n    cout << tong << \" \" << hieu << \" \" << tich;\n    return 0;\n}','cpp','2026-01-30 14:03:01'),(12,68,NULL,1,'Tách số hàng đơn vị','Viết chương trình nhập vào một số nguyên dương n. Hãy in ra chữ số hàng đơn vị của số đó.\nGợi ý: Để lấy chữ số hàng đơn vị của một số, ta thực hiện phép chia lấy dư của số đó cho 10 (sử dụng toán tử %).','Easy','#include <iostream>\nusing namespace std;\n\nint main() {\n    int n;\n    // Nhập n và in ra n % 10\n\n    return 0;\n}','#include <iostream>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    cout << n % 10;\n    return 0;\n}','cpp','2026-01-30 14:03:57'),(13,69,NULL,1,'Kiểm tra số lớn hơn','Viết chương trình nhập vào hai số nguyên a và b. Sử dụng toán tử quan hệ để kiểm tra xem a có lớn hơn b hay không. In ra kết quả dưới dạng số nguyên (1 nếu đúng, 0 nếu sai).\nGợi ý: Trong C++, kết quả của một phép so sánh đúng sẽ trả về 1 (true) và sai trả về 0 (false).','Easy','#include <iostream>\nusing namespace std;\n\nint main() {\n    int a, b;\n    // Nhập a, b và in ra kết quả của phép so sánh (a > b)\n\n    return 0;\n}','#include <iostream>\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin >> a >> b;\n    cout << (a > b);\n    return 0;\n}','javascript','2026-01-30 14:06:11'),(14,69,NULL,1,'Số nằm trong khoảng','Viết chương trình nhập vào một số nguyên x. Sử dụng toán tử logic && (AND) để kiểm tra xem x có đồng thời lớn hơn 10 và nhỏ hơn 100 hay không. In ra 1 nếu nằm trong khoảng, ngược lại in 0.','Easy','#include <iostream>\nusing namespace std;\n\nint main() {\n    int x;\n    // Nhập x và kiểm tra điều kiện (x > 10 && x < 100)\n\n    return 0;\n}','#include <iostream>\nusing namespace std;\n\nint main() {\n    int x;\n    cin >> x;\n    cout << (x > 10 && x < 100);\n    return 0;\n}','cpp','2026-01-30 14:07:22'),(15,70,NULL,1,'Tính trung bình cộng chính xác','Viết chương trình nhập vào hai số nguyên a và b. Hãy tính trung bình cộng của chúng.\nYêu cầu: Vì kết quả trung bình cộng có thể là số thập phân (ví dụ trung bình cộng của 3 và 4 là 3.5), bạn cần sử dụng kỹ thuật ép kiểu (type casting) để kết quả in ra là một số thực, thay vì bị mất phần thập phân do chia hai số nguyên.','Easy','#include <iostream>\nusing namespace std;\n\nint main() {\n    int a, b;\n    // Nhập a, b và in ra (a + b) / 2.0 hoặc sử dụng (double)\n\n    return 0;\n}','#include <iostream>\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin >> a >> b;\n    double result = (double)(a + b) / 2;\n    cout << result;\n    return 0;\n}','cpp','2026-01-30 14:09:20'),(16,70,NULL,1,'Tìm ký tự đứng sau','Mỗi ký tự trong bảng mã ASCII được sắp xếp theo một thứ tự nhất định. Viết chương trình nhập vào một ký tự c, hãy in ra ký tự đứng ngay sau nó trong bảng mã ASCII.\nVí dụ: Nếu nhập \'A\' (mã 65), kết quả in ra phải là \'B\' (mã 66).\nGợi ý: Bạn có thể cộng trực tiếp 1 đơn vị vào biến kiểu char để tìm ký tự kế tiếp','Easy','#include <iostream>\nusing namespace std;\n\nint main() {\n    char c;\n    // Nhập c và in ra ký tự tiếp theo\n\n    return 0;\n}','#include <iostream>\nusing namespace std;\n\nint main() {\n    char c;\n    cin >> c;\n    char next_c = c + 1;\n    cout << next_c;\n    return 0;\n}','cpp','2026-01-30 14:10:16'),(17,NULL,20,1,'Tính điểm tổng kết học phần','Viết chương trình tính điểm tổng kết của một sinh viên dựa trên điểm các thành phần sau:\n1. Điểm chuyên cần (hệ số 1).\n2. Điểm kiểm tra giữa kỳ (hệ số 2).\n3. Điểm thi cuối kỳ (hệ số 3). Hãy nhập 3 số thực từ bàn phím tương ứng với 3 loại điểm trên. Tính và in ra điểm trung bình theo công thức: DiemTB = (Cần + GK*2 + CK*3) / 6 Yêu cầu: Kết quả là số thực.','Medium','#include <iostream>\nusing namespace std;\n\nint main() {\n    double diemCC, diemGK, diemCK;\n    // Nhập 3 loại điểm và tính điểm trung bình hệ số\n\n    return 0;\n}','#include <iostream>\nusing namespace std;\n\nint main() {\n    double diemCC, diemGK, diemCK;\n    cin >> diemCC >> diemGK >> diemCK;\n    double diemTB = (diemCC + diemGK * 2 + diemCK * 3) / 6;\n    cout << diemTB;\n    return 0;\n}','cpp','2026-01-30 14:11:54'),(18,NULL,20,1,'Đổi giây sang định dạng H:M:S','Viết chương trình nhập vào một số nguyên dương $N$ là tổng số giây. Hãy quy đổi và in ra định dạng Giờ Phút Giây (mỗi số cách nhau một khoảng trắng).\nVí dụ: Nếu nhập 3661 thì in ra 1 1 1 (vì 3661 giây = 1 giờ, 1 phút, 1 giây).\nGợi ý:1 giờ = 3600 giây.1 phút = 60 giây.Sử dụng toán tử / để lấy phần nguyên và % để lấy phần dư.','Hard','#include <iostream>\nusing namespace std;\n\nint main() {\n    int tongGiay;\n    // Nhập tổng số giây và thực hiện tính toán gio, phut, giay\n\n    return 0;\n}','#include <iostream>\nusing namespace std;\n\nint main() {\n    int tongGiay, gio, phut, giay;\n    cin >> tongGiay;\n    gio = tongGiay / 3600;\n    phut = (tongGiay % 3600) / 60;\n    giay = tongGiay % 60;\n    cout << gio << \" \" << phut << \" \" << giay;\n    return 0;\n}','cpp','2026-01-30 14:12:44'),(19,71,NULL,1,'Kiểm tra số chẵn hay lẻ','Viết chương trình nhập vào một số nguyên n. Sử dụng cấu trúc if...else để kiểm tra:\n1. Nếu n chia hết cho 2, in ra màn hình: CHAN\n2. Ngược lại (nếu n không chia hết cho 2), in ra màn hình: LE\nGợi ý: Sử dụng toán tử chia lấy dư %. Nếu n % 2 == 0 thì đó là số chẵn.','Easy','#include <iostream>\nusing namespace std;\n\nint main() {\n    int n;\n    // Nhập n và kiểm tra chẵn lẻ\n\n    return 0;\n}','#include <iostream>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    if (n % 2 == 0) {\n        cout << \"CHAN\";\n    } else {\n        cout << \"LE\";\n    }\n    return 0;\n}','cpp','2026-01-30 14:15:16'),(20,71,NULL,1,'Tìm số lớn nhất','Viết chương trình nhập vào hai số nguyên $a$ và $b$. Hãy so sánh hai số này và in ra giá trị của số lớn hơn. Nếu hai số bằng nhau, in ra giá trị của bất kỳ số nào trong hai số đó.','Easy','#include <iostream>\nusing namespace std;\n\nint main() {\n    int a, b;\n    // Nhập a, b và tìm số lớn nhất bằng if else\n\n    return 0;\n}','#include <iostream>\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin >> a >> b;\n    if (a > b) {\n        cout << a;\n    } else {\n        cout << b;\n    }\n    return 0;\n}','cpp','2026-01-30 14:16:00'),(21,72,NULL,1,'Tìm tên thứ trong tuần','Viết chương trình nhập vào một số nguyên n (2 <= n <= 8). Sử dụng cấu trúc switch case để in ra tên thứ tương ứng:\n1. Nếu n = 2: In Thu Hai\n2. Nếu n = 3: In Thu Ba...\n3. Nếu nhập số ngoài khoảng 2-8: In Khong hop le','Easy','#include <iostream>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    // Sử dụng switch (n) để phân loại\n\n    return 0;\n}','#include <iostream>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    switch (n) {\n        case 2: cout << \"Thu Hai\"; break;\n        case 3: cout << \"Thu Ba\"; break;\n        case 4: cout << \"Thu Tu\"; break;\n        case 5: cout << \"Thu Nam\"; break;\n        case 6: cout << \"Thu Sau\"; break;\n        case 7: cout << \"Thu Bay\"; break;\n        case 8: cout << \"Chu Nhat\"; break;\n        default: cout << \"Khong hop le\";\n    }\n    return 0;\n}','javascript','2026-01-30 14:20:11'),(22,72,NULL,1,'Thực hiện phép tính cơ bản','Viết chương trình nhập vào hai số nguyên a, b và một ký tự c đại diện cho phép toán (+, -, *). Hãy sử dụng switch case trên biến ký tự c để in ra kết quả của phép tính tương ứng.\nVí dụ: Nhập 5 3 + -> In ra 8.','Easy','#include <iostream>\nusing namespace std;\n\nint main() {\n    int a, b;\n    char phepToan;\n    cin >> a >> b >> phepToan;\n    // switch (phepToan) để tính toán\n\n    return 0;\n}','#include <iostream>\nusing namespace std;\n\nint main() {\n    int a, b;\n    char pt;\n    cin >> a >> b >> pt;\n    switch (pt) {\n        case \'+\': cout << a + b; break;\n        case \'-\': cout << a - b; break;\n        case \'*\': cout << a * b; break;\n        default: cout << \"Loi\";\n    }\n    return 0;\n}','cpp','2026-01-30 14:21:18'),(23,73,NULL,1,'Kiểm tra số âm dương cực ngắn','Viết chương trình nhập vào một số nguyên n. Sử dụng toán tử 3 ngôi để kiểm tra:\n1. Nếu n >= 0, in ra chuỗi: DUONG\n2. Ngược lại, in ra chuỗi: AM\nYêu cầu: Chỉ sử dụng một dòng lệnh duy nhất để kiểm tra và in kết quả (không dùng if...else).','Easy','#include <iostream>\n#include <string>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    // Sử dụng toán tử 3 ngôi: (dieu_kien) ? \"Gia_tri_dung\" : \"Gia_tri_sai\"\n\n    return 0;\n}','#include <iostream>\n#include <string>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    cout << (n >= 0 ? \"DUONG\" : \"AM\");\n    return 0;\n}','cpp','2026-01-30 14:23:16'),(24,73,NULL,1,'Tìm Min của hai số','#include <iostream>\nusing namespace std;\n\nint main() {\n    double a, b;\n    cin >> a >> b;\n    // Khai báo biến min và gán giá trị bằng toán tử 3 ngôi\n\n    return 0;\n}','Easy','#include <iostream>\nusing namespace std;\n\nint main() {\n    double a, b;\n    cin >> a >> b;\n    // Khai báo biến min và gán giá trị bằng toán tử 3 ngôi\n\n    return 0;\n}','#include <iostream>\nusing namespace std;\n\nint main() {\n    double a, b;\n    cin >> a >> b;\n    double min = (a < b) ? a : b;\n    cout << min;\n    return 0;\n}','cpp','2026-01-30 14:24:24'),(25,74,NULL,1,'Liệt kê các số tự nhiên','Viết chương trình nhập vào một số nguyên dương n. Sử dụng vòng lặp for để in ra các số từ 1 đến n. Các số được in trên cùng một dòng và cách nhau bởi một khoảng trắng.','Easy','#include <iostream>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    // Sử dụng vòng lặp for để in từ 1 đến n\n\n    return 0;\n}','#include <iostream>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n        cout << i << \" \";\n    }\n    return 0;\n}','cpp','2026-01-30 14:25:46'),(26,74,NULL,1,'Tính tổng chữ số bằng vòng lặp while','Viết chương trình nhập vào một số nguyên dương n. Hãy tính tổng các chữ số của n.\nGợi ý: Sử dụng vòng lặp while (n > 0), mỗi lần lặp lấy n (mod 10) để được chữ số cuối cùng, cộng vào tổng, sau đó gán n = n / 10 để bỏ chữ số đó đi.','Easy','#include <iostream>\nusing namespace std;\n\nint main() {\n    int n, sum = 0;\n    cin >> n;\n    // Sử dụng while để tách từng chữ số và cộng vào sum\n\n    return 0;\n}','#include <iostream>\nusing namespace std;\n\nint main() {\n    int n, sum = 0;\n    cin >> n;\n    while (n > 0) {\n        sum += n % 10;\n        n /= 10;\n    }\n    cout << sum;\n    return 0;\n}','cpp','2026-01-30 14:26:55'),(27,75,NULL,1,'Thoát vòng lặp với Break','Viết chương trình nhập vào hai số nguyên a và b (a < b). Hãy tìm và in ra số nguyên đầu tiên trong khoảng từ a đến b mà chia hết cho 7.\nYêu cầu: Sử dụng vòng lặp for chạy từ a đến b và dùng lệnh break để dừng vòng lặp ngay khi tìm thấy số đầu tiên thỏa mãn. Nếu không có số nào, không in gì cả.','Easy','#include <iostream>\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin >> a >> b;\n    // Chạy vòng lặp từ a đến b, tìm số chia hết cho 7 và break\n\n    return 0;\n}','#include <iostream>\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin >> a >> b;\n    for (int i = a; i <= b; i++) {\n        if (i % 7 == 0) {\n            cout << i;\n            break;\n        }\n    }\n    return 0;\n}','cpp','2026-01-30 14:29:08'),(28,75,NULL,1,'In các số trừ bội số của 3','Viết chương trình nhập vào một số nguyên dương n. Hãy in ra các số từ 1 đến n, nhưng không in các số chia hết cho 3.\nYêu cầu: Sử dụng vòng lặp for và lệnh continue để bỏ qua việc in các số là bội của 3. Các số in ra cách nhau một khoảng trắng.','Easy','#include <iostream>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    // Sử dụng for và continue\n\n    return 0;\n}','#include <iostream>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n        if (i % 3 == 0) {\n            continue;\n        }\n        cout << i << \" \";\n    }\n    return 0;\n}','cpp','2026-01-30 14:30:04'),(29,NULL,21,1,'Kiểm tra số nguyên tố','Viết chương trình nhập vào một số nguyên dương n. Kiểm tra xem n có phải là số nguyên tố hay không.\n1. Số nguyên tố là số lớn hơn 1 và chỉ có hai ước là 1 và chính nó.\n2. Nếu là số nguyên tố, in ra: YES','Easy','#include <iostream>\nusing namespace std;\n\nint main() {\n\n    return 0;\n}','','cpp','2026-01-30 14:32:08'),(30,NULL,21,1,'Vẽ hình chữ nhật rỗng bằng dấu sao','Nhập vào chiều cao h và chiều rộng w (h, w > 1). Hãy in ra một hình chữ nhật rỗng kích thước h * w bằng các dấu sao (*)','Hard','#include <iostream>\nusing namespace std;\n\nint main() {\n    return 0;\n}','#include <iostream>\nusing namespace std;\n\nint main() {\n    int h, w;\n    cin >> h >> w;\n    for (int i = 1; i <= h; i++) {\n        for (int j = 1; j <= w; j++) {\n            if (i == 1 || i == h || j == 1 || j == w) {\n                cout << \"*\";\n            } else {\n                cout << \" \";\n            }\n        }\n        cout << endl;\n    }\n    return 0;\n}','javascript','2026-01-30 14:33:43'),(31,76,NULL,1,'Tổng các phần tử trong mảng','Viết chương trình thực hiện các bước sau:\n1. Nhập vào số nguyên dương n là số lượng phần tử của mảng (n <= 100).\n2. Nhập các phần tử của mảng số nguyên.\n3. Tính và in ra tổng của tất cả các phần tử trong mảng đó.','Easy','#include <iostream>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    int a[100];\n    // Nhập mảng và tính tổng tại đây\n\n    return 0;\n}','#include <iostream>\nusing namespace std;\n\nint main() {\n    int n, sum = 0;\n    cin >> n;\n    int a[n];\n    for(int i = 0; i < n; i++) {\n        cin >> a[i];\n        sum += a[i];\n    }\n    cout << sum;\n    return 0;\n}','cpp','2026-01-30 14:35:18'),(32,76,NULL,1,'Tìm số lớn nhất trong mảng','Nhập vào một mảng gồm n số nguyên. Hãy tìm và in ra giá trị lớn nhất có trong mảng đó.\nGợi ý: Giả sử phần tử đầu tiên là max, sau đó duyệt mảng, nếu thấy phần tử nào lớn hơn max thì cập nhật lại giá trị cho max.','Easy','#include <iostream>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    int a[100];\n    // Tìm và in ra phần tử lớn nhất\n    return 0;\n}','#include <iostream>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    int a[n];\n    for(int i = 0; i < n; i++) cin >> a[i];\n\n    int maxVal = a[0];\n    for(int i = 1; i < n; i++) {\n        if(a[i] > maxVal) maxVal = a[i];\n    }\n    cout << maxVal;\n    return 0;\n}','cpp','2026-01-30 14:36:13'),(33,77,NULL,1,'Tính tổng các phần tử trong ma trận','Viết chương trình thực hiện các yêu cầu sau:\n1. Nhập vào hai số nguyên dương m và n lần lượt là số hàng và số cột của ma trận.\n2. Nhập các phần tử của ma trận số nguyên kích thước m * n.\n3. Tính và in ra tổng của tất cả các phần tử có trong ma trận đó.','Easy','#include <iostream>\nusing namespace std;\n\nint main() {\n    int m, n;\n    cin >> m >> n;\n    int a[100][100];\n    // Nhập ma trận và tính tổng bằng 2 vòng lặp lồng nhau\n\n    return 0;\n}','','cpp','2026-01-30 14:37:52'),(34,77,NULL,1,'Giá trị lớn nhất của mỗi hàng','Nhập vào một ma trận số nguyên kích thước m * n. Với mỗi hàng của ma trận, hãy tìm giá trị lớn nhất của hàng đó và in ra màn hình. Các giá trị cách nhau bởi một khoảng trắng.\nGợi ý: Duyệt qua từng hàng, với mỗi hàng, khởi tạo maxRow = a[i][0] rồi so sánh với các phần tử còn lại trên cùng hàng đó.','Medium','#include <iostream>\nusing namespace std;\n\nint main() {\n    int m, n;\n    cin >> m >> n;\n    int a[100][100];\n    // Duyệt từng hàng để tìm max và in ra\n    return 0;\n}','','cpp','2026-01-30 14:38:56'),(35,78,NULL,1,'Tính độ dài chuỗi ký tự','Viết chương trình nhập vào một chuỗi ký tự (không chứa khoảng trắng). Hãy tính và in ra độ dài (số lượng ký tự) của chuỗi đó','Easy','#include <iostream>\n#include <string>\nusing namespace std;\n\nint main() {\n    string s;\n    // Nhập chuỗi s và in ra độ dài của nó\n\n    return 0;\n}','','cpp','2026-01-30 14:41:13'),(36,78,NULL,1,'Lấy ký tự đầu và cuối','Nhập vào một chuỗi ký tự s. Hãy in ra ký tự đầu tiên và ký tự cuối cùng của chuỗi đó, cách nhau bởi một khoảng trắng','Easy','#include <iostream>\n#include <string>\nusing namespace std;\n\nint main() {\n    string s;\n    cin >> s;\n    // In ký tự đầu và cuối\n    return 0;\n}','','cpp','2026-01-30 14:41:57'),(37,79,NULL,1,'Tìm vị trí chuỗi con','Viết chương trình nhập vào một chuỗi mẹ S và một chuỗi con sub. Hãy kiểm tra xem sub có xuất hiện trong S hay không.\n1. Nếu có, in ra vị trí (index) đầu tiên mà sub xuất hiện.\n2. Nếu không, in ra -1. Gợi ý: Sử dụng hàm S.find(sub). Lưu ý rằng nếu không tìm thấy, hàm sẽ trả về giá trị hằng số string::npos.','Medium','#include <iostream>\n#include <string>\nusing namespace std;\n\nint main() {\n    string S, sub;\n    getline(cin, S);\n    getline(cin, sub);\n    // Sử dụng hàm find để tìm vị trí của sub trong S\n\n    return 0;\n}','','cpp','2026-01-30 14:45:09'),(38,79,NULL,1,'Cắt chuỗi ký tự','Nhập vào một chuỗi S và hai số nguyên pos (vị trí bắt đầu) và len (độ dài cần lấy). Hãy in ra chuỗi con được cắt từ S bắt đầu tại pos với độ dài len','Easy','#include <iostream>\n#include <string>\nusing namespace std;\n\nint main() {\n    string S;\n    int pos, len;\n    getline(cin, S);\n    cin >> pos >> len;\n    // In ra chuỗi con bằng hàm substr\n\n    return 0;\n}','','cpp','2026-01-30 14:46:08'),(39,NULL,23,1,'Kiểm tra chuỗi đối xứng (Palindrome)','Một chuỗi được gọi là đối xứng nếu đọc từ trái sang phải hay từ phải sang trái đều giống nhau (Ví dụ: radar, madam). Viết chương trình nhập vào một chuỗi S, kiểm tra xem S có phải là chuỗi đối xứng hay không.Nếu đối xứng, in ra: YES; Ngược lại, in ra: NO','Medium','#include <iostream>\n#include <string>\n#include <algorithm> // Thư viện để sử dụng hàm reverse\nusing namespace std;\n\nint main() {\n    string s;\n    cin >> s;\n\n    // 1. Tạo một chuỗi tạm thời \'temp\' sao chép từ \'s\'\n    // 2. Sử dụng hàm reverse(temp.begin(), temp.end()) để đảo ngược \'temp\'\n    // 3. So sánh \'s\' với \'temp\' và in kết quả phù hợp\n    \n    return 0;\n}','','cpp','2026-01-30 14:49:03'),(40,NULL,23,1,'Chuẩn hóa ký tự đầu','Nhập vào một từ (chuỗi không dấu cách, viết thường hoàn toàn). Hãy chuyển ký tự đầu tiên của chuỗi đó sang dạng chữ hoa, các ký tự còn lại giữ nguyên.','Hard','#include <iostream>\n#include <string>\n#include <cctype> // Thư viện chứa hàm toupper\nusing namespace std;\n\nint main() {\n    string s;\n    cin >> s;\n\n    // 1. Kiểm tra nếu chuỗi không rỗng\n    // 2. Chuyển ký tự đầu tiên s[0] thành chữ hoa bằng hàm toupper()\n    // 3. In chuỗi s ra màn hình\n    \n    return 0;\n}','','cpp','2026-01-30 14:49:54'),(41,80,NULL,1,'Hàm xin chào','Viết một hàm đặt tên là xinChao() không có tham số và không trả về giá trị (kiểu void). Hàm này có nhiệm vụ in ra màn hình dòng chữ: Hello CodePulse!. Trong hàm main, hãy gọi hàm này một lần.','Easy','#include <iostream>\nusing namespace std;\n\n// 1. Định nghĩa hàm xinChao() tại đây\n\n\nint main() {\n    // 2. Gọi hàm xinChao() tại đây\n\n    return 0;\n}','#include <iostream>\nusing namespace std;\n\nvoid xinChao() {\n    cout << \"Hello CodePulse!\";\n}\n\nint main() {\n    xinChao();\n    return 0;\n}','cpp','2026-01-31 00:38:48'),(42,80,NULL,1,'Tính bình phương một số','Viết một hàm đặt tên là binhPhuong nhận vào một số nguyên n làm tham số và trả về giá trị bình phương của số đó (n^2). Trong hàm main, hãy nhập một số nguyên từ bàn phím, sử dụng hàm đã viết để tính toán và in kết quả.','Easy','#include <iostream>\nusing namespace std;\n\n// 1. Định nghĩa hàm binhPhuong tại đây\n\n\nint main() {\n    int x;\n    cin >> x;\n\n    // 2. Gọi hàm binhPhuong(x) và in kết quả tại đây\n\n    return 0;\n}','','cpp','2026-01-31 00:39:34'),(43,81,NULL,1,'Hàm tính lũy thừa','Viết hàm tinhLuyThua nhận vào hai tham số nguyên coSo và soMu. Hàm trả về giá trị coSo^soMu. Trong bài này, chúng ta sử dụng truyền tham trị (giá trị của biến ở main không bị thay đổi).','Easy','#include <iostream>\n#include <cmath> // Thư viện cho hàm pow\nusing namespace std;\n\n// 1. Định nghĩa hàm tinhLuyThua(int coSo, int soMu) tại đây\n\n\nint main() {\n    int a, b;\n    cin >> a >> b;\n\n    // 2. Gọi hàm và in kết quả tại đây\n    \n    return 0;\n}','','cpp','2026-01-31 00:40:42'),(44,81,NULL,1,'Hàm hoán đổi giá trị (Swap)','Viết hàm hoanDoi nhận vào hai tham số nguyên a và b. Để thay đổi giá trị của biến sau khi ra khỏi hàm, bạn phải sử dụng truyền tham chiếu (thêm dấu & trước tên tham số)','Easy','#include <iostream>\nusing namespace std;\n\n// 1. Định nghĩa hàm hoanDoi(int &a, int &b) tại đây\n\n\nint main() {\n    int x, y;\n    cin >> x >> y;\n\n    // 2. Gọi hàm hoanDoi(x, y)\n    \n    // In kết quả sau khi hoán đổi\n    cout << x << \" \" << y;\n    return 0;\n}','','cpp','2026-01-31 00:41:36'),(45,82,NULL,1,'Hàm tính tổng 3 số','Viết hàm tinhTong nhận vào 3 tham số số nguyên a, b, và c. In kết quả cách nhau một khoảng trắng.','Easy','#include <iostream>\nusing namespace std;\n\n// 1. Định nghĩa hàm tinhTong(int a, int b, int c = 0) tại đây\n\n\nint main() {\n    int x, y, z;\n    cin >> x >> y >> z;\n\n    // 2. Gọi hàm lần 1 với 3 tham số x, y, z\n    // 3. Gọi hàm lần 2 với 2 tham số x, y\n    \n    return 0;\n}','','cpp','2026-01-31 00:49:32'),(46,82,NULL,1,'Tính lương với hệ số mặc định','Viết hàm tinhLuong nhận vào luongCoBan (kiểu double) và heSo (kiểu double).\n1. Gán giá trị mặc định cho heSo là 1.0.\n2. Hàm trả về giá trị: luongCoBan * heSo.\n3. Tại hàm main, nhập vào lương cơ bản và một hệ số mới. In ra kết quả khi dùng hệ số mới đó và kết quả khi không truyền hệ số (dùng mặc định).','Easy','#include <iostream>\nusing namespace std;\n\n// 1. Định nghĩa hàm tinhLuong(double luongCoBan, double heSo = 1.0)\n\n\nint main() {\n    double lcb, hs;\n    cin >> lcb >> hs;\n\n    // 2. In lương có hệ số hs và lương mặc định (heSo = 1.0)\n    \n    return 0;\n}','','cpp','2026-01-31 00:50:37'),(47,83,NULL,1,'Sử dụng hàm nguyên mẫu cơ bản','Viết chương trình tính diện tích hình chữ nhật.\n1. Khai báo Hàm nguyên mẫu double tinhDienTich(double dai, double rong); ở phía trên hàm main().\n2. Viết hàm main() để nhập chiều dài, chiều rộng và gọi hàm.\n3. Định nghĩa chi tiết thân hàm tinhDienTich ở phía dưới hàm main().','Easy','#include <iostream>\nusing namespace std;\n\n// 1. Khai báo nguyên mẫu hàm (Function Prototype) tại đây\n\n\nint main() {\n    double a, b;\n    cin >> a >> b;\n\n    // 2. Gọi hàm và in kết quả\n    \n    return 0;\n}\n\n// 3. Định nghĩa chi tiết hàm tinhDienTich tại đây','','cpp','2026-01-31 00:51:54'),(48,83,NULL,1,'Kiểm tra số chẵn và số âm','Sử dụng hàm nguyên mẫu để khai báo hai hàm:\n- bool laSoChan(int n); (Trả về true nếu n chẵn)\n- bool laSoAm(int n); (Trả về true nếu n < 0) \nYêu cầu: Khai báo nguyên mẫu ở trên main(), gọi hàm trong main(), và định nghĩa hàm ở cuối file. In ra 1 cho true và 0 cho false, cách nhau một dấu cách.','Easy','#include <iostream>\nusing namespace std;\n\n// Khai báo nguyên mẫu 2 hàm tại đây\n\n\nint main() {\n    int x;\n    cin >> x;\n\n    // Gọi hàm và in kết quả: laSoChan(x) và laSoAm(x)\n    \n    return 0;\n}\n\n// Định nghĩa 2 hàm tại đây','','javascript','2026-01-31 00:53:13'),(49,84,NULL,1,'Tính tổng nhiều kiểu dữ liệu','Viết hai hàm cùng tên là tinhTong:\n1. Hàm thứ nhất nhận vào hai số nguyên (int a, int b) và trả về tổng của chúng.\n2. Hàm thứ hai nhận vào hai số thực (double a, double b) và trả về tổng của chúng. Trong hàm main, hãy thực hiện nhập 2 số nguyên và 2 số thực, sau đó gọi lần lượt hai hàm này để in kết quả (cách nhau một khoảng trắng).','Easy','#include <iostream>\nusing namespace std;\n\n// 1. Định nghĩa hàm tinhTong cho kiểu int\n\n\n// 2. Định nghĩa hàm tinhTong cho kiểu double\n\n\nint main() {\n    int n1, n2;\n    double d1, d2;\n    cin >> n1 >> n2 >> d1 >> d2;\n\n    // 3. Gọi nạp chồng hàm và in kết quả\n    \n    return 0;\n}','','cpp','2026-01-31 00:54:31'),(50,84,NULL,1,'Nạp chồng hàm tìm Max','Viết nạp chồng hàm timMax để tìm số lớn nhất trong các trường hợp sau:\n1. Tìm số lớn nhất giữa hai số nguyên a và b.\n2. Tìm số lớn nhất giữa ba số nguyên a, b và c.','Medium','#include <iostream>\nusing namespace std;\n\n// 1. Định nghĩa hàm timMax(int a, int b)\n\n\n// 2. Định nghĩa hàm timMax(int a, int b, int c)\n\n\nint main() {\n    int x, y, z;\n    cin >> x >> y >> z;\n\n    // 3. In kết quả timMax của (x, y) và timMax của (x, y, z)\n    \n    return 0;\n}','','cpp','2026-01-31 00:55:29'),(51,85,NULL,1,'Tính giai thừa bằng đệ quy','Giai thừa của một số nguyên dương n (ký hiệu n!) được tính bằng công thức: n! = n x (n-1) x ... x 1','Medium','#include <iostream>\nusing namespace std;\n\n// 1. Định nghĩa hàm đệ quy tinhGiaiThua(int n) tại đây\n\n\nint main() {\n    int n;\n    cin >> n;\n\n    // 2. Gọi hàm và in kết quả tại đây\n    \n    return 0;\n}','','cpp','2026-01-31 00:57:27'),(52,85,NULL,1,'Dãy số Fibonacci đệ quy','Dãy Fibonacci là dãy số bắt đầu bằng 0, 1, 1, 2, 3, 5, 8, ...','Medium','#include <iostream>\nusing namespace std;\n\n// 1. Định nghĩa hàm đệ quy fibonacci(int n) tại đây\n\n\nint main() {\n    int n;\n    cin >> n;\n\n    // 2. In ra số Fibonacci thứ n\n    \n    return 0;\n}','','cpp','2026-01-31 00:58:25'),(53,NULL,24,1,'Tìm ước chung lớn nhất','Viết hàm timUCLN(int a, int b) sử dụng thuật toán Euclid để tìm ước chung lớn nhất của hai số nguyên dương.\n1. Thuật toán Euclid: UCLN(a, b) = UCLN(b, a (mod b)). Điểm dừng khi b = 0, kết quả là a.\n2. Trong hàm main, nhập 2 số nguyên và in ra kết quả từ hàm đã viết.','Medium','#include <iostream>\nusing namespace std;\n\n// 1. Định nghĩa hàm timUCLN(int a, int b) tại đây\n\n\nint main() {\n    int x, y;\n    if (!(cin >> x >> y)) return 0;\n\n    // 2. Gọi hàm và in kết quả tại đây\n    \n    return 0;\n}','','cpp','2026-01-31 01:02:46'),(54,NULL,24,1,'Hàm kiểm tra số hoàn hảo','Số hoàn hảo là số có tổng các ước thực sự (không kể chính nó) bằng chính nó (Ví dụ: 6 = 1 + 2 + 3).\n1. Viết hàm bool laSoHoanHao(int n) trả về true nếu n là số hoàn hảo.\n2. Viết hàm void xuLy(int &n) nhận vào một số n theo tham chiếu. Nếu n < 0, hãy gán n = |n| (giá trị tuyệt đối).\n3. Trong hàm main, nhập n, gọi hàm xuLy, sau đó gọi hàm laSoHoanHao và in YES hoặc NO.','Hard','#include <iostream>\nusing namespace std;\n\n// 1. Định nghĩa hàm laSoHoanHao(int n)\n\n\n// 2. Định nghĩa hàm xuLy(int &n) truyền tham chiếu\n\n\nint main() {\n    int n;\n    cin >> n;\n\n    // 3. Gọi hàm xuLy(n)\n    // 4. Kiểm tra laSoHoanHao(n) và in kết quả YES/NO\n    \n    return 0;\n}','','cpp','2026-01-31 01:04:16'),(55,86,NULL,1,'Truy xuất giá trị qua con trỏ','Viết chương trình thực hiện các bước sau:\n1. Nhập một số nguyên n từ bàn phím.\n2. Khai báo một con trỏ ptr trỏ tới địa chỉ của biến n.\n3. In ra giá trị của biến n thông qua con trỏ ptr bằng toán tử giải tham chiếu (*).','Easy','#include <iostream>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    // 1. Khai báo con trỏ ptr và gán địa chỉ của n cho ptr\n    \n    // 2. In giá trị của n thông qua ptr\n    \n    return 0;\n}','','cpp','2026-01-31 01:08:02'),(56,86,NULL,1,'Thay đổi giá trị qua địa chỉ','Nhập một số nguyên a. Khai báo con trỏ p trỏ tới a. Sử dụng con trỏ p để cộng thêm 10 đơn vị vào giá trị của biến a. Cuối cùng, in ra giá trị mới của biến a. Ví dụ: Nhập 5 -> Dùng con trỏ cộng thêm 10 -> In ra 15.','Medium','#include <iostream>\nusing namespace std;\n\nint main() {\n    int a;\n    cin >> a;\n\n    // 1. Khai báo con trỏ p trỏ tới a\n    \n    // 2. Sử dụng *p để cộng thêm 10 vào biến a\n    \n    // 3. In giá trị của a\n    \n    return 0;\n}','','cpp','2026-01-31 01:08:43'),(57,87,NULL,1,'Sử dụng từ khóa new và delete','Viết chương trình thực hiện các yêu cầu sau:\n1. Khai báo một con trỏ kiểu số nguyên.\n2. Sử dụng từ khóa new để cấp phát vùng nhớ động cho con trỏ này.\n3. Nhập giá trị cho vùng nhớ vừa cấp phát và in giá trị đó ra màn hình.\n4. Sử dụng từ khóa delete để giải phóng vùng nhớ sau khi dùng xong.','Easy','#include <iostream>\nusing namespace std;\n\nint main() {\n    // 1. Khai báo con trỏ ptr và cấp phát động bằng new\n    \n    // 2. Nhập giá trị cho vùng nhớ mà ptr trỏ tới\n    \n    // 3. In giá trị ra màn hình\n    \n    // 4. Giải phóng vùng nhớ bằng delete\n    \n    return 0;\n}','','cpp','2026-01-31 01:10:36'),(58,87,NULL,1,'Tính tổng trên vùng nhớ Heap','Viết chương trình cấp phát động cho 2 số nguyên a và b. Nhập giá trị cho chúng, sau đó in ra tổng của hai số này. Cuối cùng, đừng quên giải phóng cả hai vùng nhớ đã cấp phát.','Medium','#include <iostream>\nusing namespace std;\n\nint main() {\n    // 1. Cấp phát động cho ptrA và ptrB\n    \n    // 2. Nhập giá trị cho *ptrA và *ptrB\n    \n    // 3. In ra tổng (*ptrA + *ptrB)\n    \n    // 4. Giải phóng bộ nhớ\n    \n    return 0;\n}','','cpp','2026-01-31 01:11:14'),(59,88,NULL,1,'Quản lý mảng bằng cấp phát động','Viết chương trình thực hiện:\n1. Nhập số lượng phần tử n từ bàn phím.\n2. Cấp phát một mảng động gồm n số nguyên bằng từ khóa new.\n3. Nhập các phần tử cho mảng và in chúng ra màn hình theo thứ tự ngược lại.\n4. Giải phóng vùng nhớ mảng bằng delete[].','Medium','#include <iostream>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    // 1. Cấp phát mảng động a có n phần tử\n    \n    // 2. Nhập các phần tử cho mảng\n    \n    // 3. In mảng theo thứ tự ngược lại\n    \n    // 4. Giải phóng mảng động\n    \n    return 0;\n}','','cpp','2026-01-31 01:12:42'),(60,88,NULL,1,'Tính toán trên mảng động','Cấp phát động một mảng số thực gồm n phần tử. Tính trung bình cộng của các phần tử trong mảng đó.','Medium','#include <iostream>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    // Cấp phát mảng động kiểu double\n    \n    // Tính tổng và trung bình cộng\n    \n    // Giải phóng bộ nhớ\n    return 0;\n}','','cpp','2026-01-31 01:13:33'),(61,NULL,25,1,'Hoán đổi hai số bằng con trỏ','Viết hàm swap(int *a, int *b) nhận vào hai địa chỉ của hai số nguyên. Hàm thực hiện hoán đổi giá trị tại hai địa chỉ đó. Trong hàm main, nhập hai số x và y, gọi hàm swap bằng cách truyền địa chỉ của chúng (&x, &y) và in kết quả sau khi hoán đổi.','Medium','#include <iostream>\nusing namespace std;\n\n// 1. Định nghĩa hàm swap(int *a, int *b) tại đây\n\n\nint main() {\n    int x, y;\n    cin >> x >> y;\n\n    // 2. Gọi hàm swap và truyền vào địa chỉ của x, y\n    \n    // 3. In kết quả x và y\n    \n    return 0;\n}','','cpp','2026-01-31 01:14:45'),(62,NULL,25,1,'Tìm Max trên vùng nhớ Heap','1. Nhập số nguyên dương n.\n2. Cấp phát mảng động n phần tử.\n3. Nhập dữ liệu cho mảng.\n4. Viết hàm int findMax(int *arr, int n) để tìm và trả về giá trị lớn nhất trong mảng đó.\n5. In kết quả và giải phóng bộ nhớ.','Hard','#include <iostream>\nusing namespace std;\n\n// 1. Định nghĩa hàm findMax(int *arr, int n)\n\n\nint main() {\n    int n;\n    cin >> n;\n    \n    // 2. Cấp phát mảng động\n    // 3. Nhập dữ liệu\n    // 4. Gọi hàm tìm Max và in kết quả\n    // 5. Giải phóng bộ nhớ\n    \n    return 0;\n}','','cpp','2026-01-31 01:15:42'),(63,89,NULL,1,'Tạo cấu trúc điểm tọa độ','Khai báo một cấu trúc tên là Point gồm hai thành phần: x và y (kiểu số nguyên).\nTrong hàm main, khai báo một biến kiểu Point.\nNhập giá trị tọa độ từ bàn phím và in ra theo định dạng (x, y).','Easy','#include <iostream>\nusing namespace std;\n\n// 1. Khai báo struct Point ở đây\n\n\nint main() {\n    // 2. Khai báo biến p kiểu Point\n    \n    // 3. Nhập p.x và p.y\n    \n    // 4. In theo định dạng (x, y)\n    \n    return 0;\n}','','cpp','2026-01-31 01:17:44'),(64,89,NULL,1,'Cấu trúc thông tin Sinh viên','1. Tạo struct SinhVien gồm: ten (string), tuoi (int) và gpa (double).\n2. Viết chương trình nhập thông tin cho một sinh viên.\n3. In ra thông tin sinh viên trên 3 dòng khác nhau.','Medium','#include <iostream>\n#include <string>\nusing namespace std;\n\n// 1. Định nghĩa struct SinhVien\n\n\nint main() {\n    // 2. Nhập thông tin (Lưu ý dùng getline cho tên)\n    \n    // 3. Xuất thông tin\n    \n    return 0;\n}','','cpp','2026-01-31 01:19:03'),(65,90,NULL,1,'Truy cập struct qua con trỏ','Khi dùng con trỏ để quản lý một struct, thay vì dùng toán tử dấu chấm (.), chúng ta sử dụng toán tử mũi tên (->) để truy cập vào các thành viên của nó.\n1. Khai báo struct SinhVien gồm: ten (string) và tuoi (int).\n2. Trong hàm main, khai báo một biến sv và một con trỏ ptr trỏ tới sv.\n3. Nhập dữ liệu và in ra màn hình thông tin của sinh viên đó chỉ được sử dụng con trỏ ptr.','Medium','#include <iostream>\n#include <string>\nusing namespace std;\n\nstruct SinhVien {\n    string ten;\n    int tuoi;\n};\n\nint main() {\n    SinhVien sv;\n    SinhVien *ptr = &sv;\n\n    // 1. Nhập dữ liệu sử dụng ptr->ten và ptr->tuoi\n    \n    // 2. In dữ liệu ra màn hình\n    \n    return 0;\n}','','cpp','2026-01-31 01:21:05'),(66,90,NULL,1,'Cấp phát vùng nhớ Heap cho đối tượng','Viết chương trình thực hiện:\n1. Khai báo struct Box gồm: dai, rong, cao (kiểu int).\n2. Sử dụng con trỏ và từ khóa new để cấp phát động một đối tượng Box.\n3. Nhập 3 kích thước và in ra thể tích của hình hộp đó (Dài * Rộng * Cao).\n4. Giải phóng bộ nhớ bằng delete.','Hard','#include <iostream>\nusing namespace std;\n\nstruct Box {\n    int dai, rong, cao;\n};\n\nint main() {\n    // 1. Cấp phát động cho một con trỏ kiểu Box\n    \n    // 2. Nhập các giá trị thông qua con trỏ\n    \n    // 3. Tính thể tích và in ra\n    \n    // 4. Giải phóng bộ nhớ\n    \n    return 0;\n}','','cpp','2026-01-31 01:22:12'),(67,91,NULL,1,'Cộng hai Số phức (Complex Number)','Số phức có dạng a + bi. Để cộng hai số phức, ta cộng phần thực với phần thực và phần ảo với phần ảo.\n1. Tạo struct Complex gồm real và imag (kiểu double).\n2. Viết nạp chồng toán tử + để trả về tổng của hai đối tượng Complex.\n3. Trong main, nhập 2 số phức và in ra tổng theo định dạng thuc + ao i.','Medium','#include <iostream>\nusing namespace std;\n\nstruct Complex {\n    double real, imag;\n\n    // 1. Định nghĩa nạp chồng toán tử + tại đây\n    // Complex operator + (const Complex& other) { ... }\n};\n\nint main() {\n    Complex c1, c2;\n    cin >> c1.real >> c1.imag;\n    cin >> c2.real >> c2.imag;\n\n    // 2. Thực hiện cộng c3 = c1 + c2\n    \n    // 3. In kết quả\n    return 0;\n}','','cpp','2026-01-31 01:23:40'),(68,91,NULL,1,'So sánh hai Phân số','Hai phân số a/b và c/d bằng nhau nếu a x d = b x c.\n1. Tạo struct Fraction gồm tu và mau (int).\n2. Nạp chồng toán tử == để kiểm tra hai phân số có bằng nhau không.\n3. In YES nếu bằng nhau, NO nếu khác nhau.','Hard','#include <iostream>\nusing namespace std;\n\nstruct Fraction {\n    int tu, mau;\n\n    // 1. Định nghĩa nạp chồng toán tử ==\n};\n\nint main() {\n    Fraction f1, f2;\n    cin >> f1.tu >> f1.mau >> f2.tu >> f2.mau;\n\n    // 2. So sánh f1 == f2 và in kết quả\n    \n    return 0;\n}','','cpp','2026-01-31 01:25:20'),(69,92,NULL,1,'Ghi nội dung vào file .txt','Viết chương trình nhập một chuỗi ký tự từ bàn phím và ghi chuỗi đó vào một file có tên là data.txt.\n1. Sử dụng ofstream (output file stream) để mở file ghi.\n2. Sử dụng toán tử << để ghi dữ liệu.\n3. Đừng quên đóng file bằng .close() sau khi hoàn tất.','Easy','#include <iostream>\n#include <fstream>\n#include <string>\nusing namespace std;\n\nint main() {\n    string input;\n    getline(cin, input);\n\n    // 1. Khai báo đối tượng ofstream để ghi file\n    // 2. Mở file \"data.txt\"\n    // 3. Ghi biến input vào file\n    // 4. Đóng file\n    \n    return 0;\n}','','cpp','2026-01-31 01:27:07'),(70,92,NULL,1,'Đọc nội dung từ file .txt','Giả sử bạn đã có file hello.txt chứa một dòng chữ. Hãy viết chương trình sử dụng ifstream (input file stream) để đọc nội dung từ file đó và in ra màn hình.','Medium','#include <iostream>\n#include <fstream>\n#include <string>\nusing namespace std;\n\nint main() {\n    // 1. Khai báo ifstream để đọc file \"hello.txt\"\n    // 2. Kiểm tra file có mở thành công không\n    // 3. Dùng getline để đọc nội dung file vào một biến string\n    // 4. In biến đó ra màn hình và đóng file\n    \n    return 0;\n}','','cpp','2026-01-31 01:28:21'),(71,93,NULL,1,'Ghi dữ liệu nhị phân cơ bản','1. Nhập một số nguyên n từ bàn phím. \n2. Mở file number.bin ở chế độ nhị phân (ios::binary). \n3. Sử dụng hàm .write() để ghi giá trị của n vào file. Lưu ý: Hàm write yêu cầu ép kiểu về char*. \n4. Đóng file và in thông báo hoàn tất.','Medium','#include <iostream>\n#include <fstream>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    // 1. Mở ofstream với chế độ ios::binary\n    // 2. Sử dụng outFile.write((char*)&n, sizeof(n))\n    // 3. Đóng file\n    \n    return 0;\n}','','cpp','2026-01-31 01:45:56'),(72,93,NULL,1,'Lưu trữ đối tượng vào file nhị phân','Đây là ứng dụng thực tế nhất của file nhị phân: Lưu toàn bộ một cấu trúc (Struct).\n1. Tạo struct Player gồm id (int) và score (int).\n2. Viết chương trình nhập thông tin 1 Player, ghi vào file player.dat.\n3. Sau đó, mở lại file đó, đọc dữ liệu ra một biến Player khác và in score của người chơi đó ra màn hình.','Hard','#include <iostream>\n#include <fstream>\nusing namespace std;\n\nstruct Player {\n    int id;\n    int score;\n};\n\nint main() {\n    Player p1;\n    cin >> p1.id >> p1.score;\n\n    // Ghi Player p1 vào file nhị phân\n    \n    // Đọc từ file vào Player p2\n    \n    // In p2.score\n    return 0;\n}','','cpp','2026-01-31 01:46:44'),(73,NULL,27,1,'Thống kê tệp văn bản','Viết chương trình đọc một file văn bản có tên document.txt. Hãy đếm và in ra tổng số dòng và tổng số ký tự có trong file đó.','Medium','#include <iostream>\n#include <fstream>\n#include <string>\nusing namespace std;\n\nint main() {\n    ifstream inFile(\"document.txt\");\n    int lineCount = 0;\n    int charCount = 0;\n    string line;\n\n    // 1. Kiểm tra file mở thành công\n    // 2. Dùng vòng lặp while(getline(...)) để duyệt file\n    // 3. Tăng lineCount và cộng line.length() vào charCount\n    // 4. In kết quả và đóng file\n    \n    return 0;\n}','','cpp','2026-01-31 01:48:10'),(74,NULL,27,1,'Quản lý danh sách sản phẩm (Struct & Binary File)','1. Tạo struct Product gồm id (int) và price (double).\n2. Nhập số lượng sản phẩm n từ bàn phím.\n3. Nhập thông tin cho n sản phẩm và ghi tất cả vào file nhị phân store.dat.\n4. Đọc lại file store.dat và in ra tổng giá trị của tất cả sản phẩm.','Hard','#include <iostream>\n#include <fstream>\nusing namespace std;\n\nstruct Product {\n    int id;\n    double price;\n};\n\nint main() {\n    int n;\n    cin >> n;\n    Product p[100];\n\n    // 1. Nhập mảng p và ghi vào store.dat bằng file.write()\n    \n    // 2. Mở lại file, dùng file.read() để đọc từng Product\n    \n    // 3. Tính tổng price và in ra\n    \n    return 0;\n}','','cpp','2026-01-31 01:49:10'),(75,94,NULL,1,'Tạo lớp Hình chữ nhật','1. Định nghĩa một lớp (class) tên là HinhChuNhat. \n2. Lớp có hai thuộc tính public: chieuDai và chieuRong (kiểu double). \n3. Lớp có một phương thức (hàm) tên là tinhDienTich() trả về diện tích của hình đó. \n4. Trong hàm main, tạo một đối tượng từ lớp này, nhập kích thước và in ra diện tích.','Easy','#include <iostream>\nusing namespace std;\n\n// 1. Định nghĩa lớp HinhChuNhat tại đây\nclass HinhChuNhat {\npublic:\n    double chieuDai, chieuRong;\n\n    // Viết hàm tinhDienTich() trả về dai * rong\n};\n\nint main() {\n    // 2. Tạo đối tượng hcn\n    // 3. Nhập dữ liệu và gọi hàm tinhDienTich()\n    \n    return 0;\n}','','cpp','2026-01-31 01:50:33'),(76,94,NULL,1,'Lớp Xe hơi (Car)','ạo lớp Car gồm các thuộc tính brand (string) và year (int). Viết phương thức displayInfo() để in ra thông tin xe theo định dạng: Brand: [tên xe], Year: [năm].','Medium','#include <iostream>\n#include <string>\nusing namespace std;\n\n// 1. Định nghĩa lớp Car\n\n\nint main() {\n    // 2. Tạo đối tượng car1, nhập brand và year\n    // 3. Gọi phương thức displayInfo()\n    return 0;\n}','','cpp','2026-01-31 01:51:11'),(77,95,NULL,1,'Quản lý tài khoản ngân hàng (Getter & Setter)','Định nghĩa lớp BankAccount.\nThuộc tính: balance (số dư) để ở chế độ private để tránh việc sửa đổi tùy tiện.\nPhương thức:\n- setBalance(double b): Kiểm tra nếu b >= 0 thì mới gán cho balance, ngược lại gán bằng 0.\n- getBalance(): Trả về giá trị của balance.\nTrong hàm main, nhập một số tiền, sử dụng setBalance để gán và getBalance để in ra.','Medium','#include <iostream>\nusing namespace std;\n\nclass BankAccount {\nprivate:\n    double balance;\n\npublic:\n    // 1. Viết hàm setBalance(double b) tại đây\n    \n    // 2. Viết hàm getBalance() tại đây\n};\n\nint main() {\n    BankAccount account;\n    double money;\n    cin >> money;\n\n    // 3. Gọi setBalance và in kết quả từ getBalance\n    \n    return 0;\n}','','cpp','2026-01-31 01:52:42'),(78,95,NULL,1,'Quản lý thông tin học sinh','Tạo lớp Student có thuộc tính score (điểm số) là private. Viết hàm setScore(double s) sao cho: nếu điểm nhập vào không nằm trong khoảng [0, 10], hãy in ra \"Diem khong hop le\" và gán điểm bằng 0. Nếu hợp lệ, gán bình thường.','Hard','#include <iostream>\nusing namespace std;\n\nclass Student {\nprivate:\n    double score;\n\npublic:\n    // Viết setScore và getScore\n};\n\nint main() {\n    Student st;\n    double s;\n    cin >> s;\n    // Thực hiện set và get\n    return 0;\n}','','cpp','2026-01-31 01:53:24'),(79,96,NULL,1,'Kế thừa cơ bản (Lớp Động vật)','1. Tạo lớp cha Animal có một phương thức public là speak() in ra chuỗi \"Animal speaks\". \n2. Tạo lớp con Dog kế thừa từ lớp Animal bằng từ khóa public. \n3. Trong lớp Dog, viết thêm một phương thức wagTail() in ra chuỗi \"Dog wags tail\". \n4. Trong hàm main, tạo đối tượng Dog, gọi cả hai phương thức trên.','Easy','#include <iostream>\nusing namespace std;\n\n// 1. Định nghĩa lớp cha Animal\nclass Animal {\npublic:\n    void speak() {\n        cout << \"Animal speaks\" << endl;\n    }\n};\n\n// 2. Định nghĩa lớp con Dog kế thừa từ Animal\nclass Dog : public Animal {\npublic:\n    // Viết phương thức wagTail() tại đây\n};\n\nint main() {\n    // 3. Tạo đối tượng Dog và gọi các hàm\n    \n    return 0;\n}','','cpp','2026-01-31 01:54:33'),(80,96,NULL,1,'Quản lý nhân viên và quản lý','Từ khóa protected cho phép các lớp con truy cập trực tiếp vào thuộc tính của lớp cha, nhưng bên ngoài lớp (như hàm main) thì không truy cập được.\n1. Tạo lớp Employee có thuộc tính protected: name (string) và salary (double).\n2. Tạo lớp Manager kế thừa từ Employee.\n3. Trong lớp Manager, viết phương thức setInfo(string n, double s) để gán giá trị cho name và salary.\n4. Viết phương thức display() in ra: Manager: [name], Salary: [salary].','Medium','#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Employee {\nprotected:\n    string name;\n    double salary;\n};\n\n// Định nghĩa lớp Manager kế thừa Employee tại đây\n\n\nint main() {\n    // Nhập tên và lương, sau đó dùng Manager để hiển thị\n    return 0;\n}','','cpp','2026-01-31 01:55:48'),(81,97,NULL,1,'Tiếng kêu của các loài vật','1. Tạo lớp cha Animal có phương thức virtual void makeSound(). \n2. Tạo hai lớp con Cat và Dog kế thừa từ Animal. \n3. Ghi đè (override) phương thức makeSound() trong lớp Cat để in ra \"Meow\" và trong lớp Dog để in ra \"Woof\". \n4. Trong hàm main, sử dụng con trỏ kiểu Animal để trỏ đến đối tượng Cat và Dog, sau đó gọi hàm makeSound().','Easy','#include <iostream>\nusing namespace std;\n\nclass Animal {\npublic:\n    // 1. Khai báo hàm ảo makeSound tại đây\n};\n\n// 2. Định nghĩa lớp Cat và Dog ghi đè makeSound\n\nint main() {\n    Animal* a;\n    \n    // 3. Cho a trỏ tới Cat, gọi makeSound\n    // 4. Cho a trỏ tới Dog, gọi makeSound\n    \n    return 0;\n}','','cpp','2026-01-31 01:57:08'),(82,97,NULL,1,'Hệ thống quản lý hình học','1. Tạo lớp cha Shape có phương thức virtual double getArea().\n2. Tạo lớp Square (Hình vuông) kế thừa Shape với thuộc tính side.\n3. Tạo lớp Circle (Hình tròn) kế thừa Shape với thuộc tính radius.\n4. Sử dụng con trỏ lớp cha để tính diện tích cho một hình vuông và một hình tròn bất kỳ. (Lấy pi = 3.14).','Hard','#include <iostream>\nusing namespace std;\n\nclass Shape {\npublic:\n    virtual double getArea() = 0; // Hàm ảo thuần túy\n};\n\n// Định nghĩa lớp Square và Circle tại đây\n\nint main() {\n    double s, r;\n    cin >> s >> r;\n    \n    // Sử dụng tính đa hình để in diện tích\n    \n    return 0;\n}','','cpp','2026-01-31 01:57:51'),(83,98,NULL,1,'Lớp trừu tượng thiết bị (Device)','1. Tạo một Lớp trừu tượng (Abstract Class) tên là Device. \n2. Lớp này chứa một Hàm ảo thuần túy là virtual void turnOn() = 0;. \n3. Tạo hai lớp con Laptop và Phone kế thừa từ Device. \n4. Ghi đè hàm turnOn() để in ra cách khởi động riêng của từng thiết bị.','Medium','#include <iostream>\nusing namespace std;\n\n// 1. Định nghĩa lớp trừu tượng Device\nclass Device {\npublic:\n    // Khai báo hàm ảo thuần túy turnOn\n};\n\n// 2. Định nghĩa lớp Laptop và Phone kế thừa Device\n\nint main() {\n    // 3. Sử dụng con trỏ Device để điều khiển Laptop và Phone\n    \n    return 0;\n}','','cpp','2026-01-31 01:59:16'),(84,98,NULL,1,'Hệ thống thanh toán (Interface)','1. Tạo lớp trừu tượng Payment có hàm virtual void pay(double amount) = 0;. \n2. Tạo lớp CreditCard và EWallet ghi đè hàm pay. \n3. Lớp CreditCard in: Paid [amount] using Credit Card. \n4. Lớp EWallet in: Paid [amount] using E-Wallet.','Hard','#include <iostream>\nusing namespace std;\n\n// 1. Định nghĩa lớp Payment\n\n// 2. Định nghĩa các lớp thực thi thanh toán\n\nint main() {\n    double money;\n    cin >> money;\n    \n    // Gọi thanh toán qua CreditCard và EWallet\n    \n    return 0;\n}','','cpp','2026-01-31 02:00:32'),(85,99,NULL,1,'Khởi tạo thông tin Sinh viên (Constructor)','1. Định nghĩa lớp Student gồm các thuộc tính name (string) và age (int). \n2. Viết một Constructor có tham số để khởi tạo các giá trị này ngay khi tạo đối tượng. \n3. Viết phương thức display() để in thông tin theo định dạng: Name: [name], Age: [age].','Easy','#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Student {\npublic:\n    string name;\n    int age;\n\n    // 1. Định nghĩa Constructor tại đây\n    \n    void display() {\n        cout << \"Name: \" << name << \", Age: \" << age << endl;\n    }\n};\n\nint main() {\n    string n;\n    int a;\n    getline(cin, n);\n    cin >> a;\n\n    // 2. Tạo đối tượng và truyền tham số vào Constructor\n    \n    return 0;\n}','','cpp','2026-01-31 02:02:27'),(86,99,NULL,1,'Quản lý bộ nhớ mảng (Destructor)','1. Tạo lớp ArrayHandler có một thuộc tính là con trỏ số nguyên int* data và int size. \n2. Constructor: Cấp phát động một mảng có kích thước size. \n3. Destructor: Sử dụng delete[] để giải phóng vùng nhớ của mảng khi đối tượng bị hủy. \n4. In thông báo \"Array created\" trong Constructor và \"Array destroyed\" trong Destructor','Medium','#include <iostream>\nusing namespace std;\n\nclass ArrayHandler {\nprivate:\n    int* data;\n    int size;\n\npublic:\n    // 1. Định nghĩa Constructor: cấp phát động data = new int[s]\n    \n    // 2. Định nghĩa Destructor: delete[] data\n};\n\nint main() {\n    int s;\n    cin >> s;\n    {\n        ArrayHandler arr(s);\n    } // Đối tượng arr bị hủy tại đây\n    \n    return 0;\n}','','cpp','2026-01-31 02:03:19'),(87,100,NULL,1,'Đếm số lượng đối tượng đã tạo','1. Tạo lớp User. \n2. Khai báo một biến tĩnh static int userCount để theo dõi tổng số người dùng. \n3. Trong Constructor, hãy tăng userCount lên 1 mỗi khi một đối tượng mới được tạo.\n4. Trong hàm main, tạo 3 đối tượng User và in ra giá trị của userCount. \nLưu ý: Biến tĩnh phải được khởi tạo bên ngoài lớp','Medium','#include <iostream>\nusing namespace std;\n\nclass User {\npublic:\n    static int userCount;\n\n    // 1. Định nghĩa Constructor để tăng userCount\n};\n\n// 2. Khởi tạo biến tĩnh bên ngoài lớp tại đây\n// int User::userCount = 0;\n\nint main() {\n    // 3. Tạo các đối tượng User và in User::userCount\n    \n    return 0;\n}','','cpp','2026-01-31 02:04:35'),(88,100,NULL,1,'Hàm tĩnh hỗ trợ tính toán (Static Method)','Hàm tĩnh có thể được gọi mà không cần tạo đối tượng.\n1. Tạo lớp MathHelper.\n2. Viết hàm tĩnh static int cube(int n) để trả về lập phương của một số.\n3. Trong hàm main, gọi trực tiếp MathHelper::cube(n) để tính toán mà không cần khai báo biến.','Medium','#include <iostream>\nusing namespace std;\n\nclass MathHelper {\npublic:\n    // 1. Định nghĩa hàm tĩnh cube tại đây\n};\n\nint main() {\n    int x;\n    cin >> x;\n    // 2. Gọi hàm tĩnh bằng toán tử phạm vi ::\n    \n    return 0;\n}','','cpp','2026-01-31 02:05:26'),(89,101,NULL,1,'Hàm bạn truy cập thuộc tính Private','1. Tạo lớp Box có thuộc tính private là width. \n2. Định nghĩa một hàm tự do (không thuộc lớp) là void printWidth(Box b). \n3. Sử dụng từ khóa friend bên trong lớp Box để cấp quyền cho hàm printWidth. \n4. Trong hàm main, nhập giá trị cho width thông qua một hàm setter, sau đó dùng hàm bạn để in giá trị đó ra.','Medium','#include <iostream>\nusing namespace std;\n\nclass Box {\nprivate:\n    double width;\n\npublic:\n    void setWidth(double w) { width = w; }\n\n    // 1. Khai báo friend void printWidth(Box b); tại đây\n};\n\n// 2. Định nghĩa hàm printWidth(Box b) tại đây\n\nint main() {\n    Box b;\n    double w;\n    cin >> w;\n    b.setWidth(w);\n\n    // 3. Gọi hàm bạn\n    \n    return 0;\n}','','cpp','2026-01-31 02:06:27'),(90,101,NULL,1,'Lớp bạn quản lý dữ liệu','1. Tạo lớp Secret chứa một chuỗi private là password. \n2. Tạo lớp Hacker. \n3. Trong lớp Secret, khai báo friend class Hacker;. \n4. Trong lớp Hacker, viết phương thức void accessPassword(Secret s) để in ra mật khẩu của lớp Secret','Hard','#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Secret {\nprivate:\n    string password;\npublic:\n    Secret(string p) : password(p) {}\n\n    // 1. Khai báo lớp bạn Hacker tại đây\n};\n\nclass Hacker {\npublic:\n    // 2. Viết hàm accessPassword(Secret s)\n};\n\nint main() {\n    string p;\n    cin >> p;\n    Secret s(p);\n    Hacker h;\n    \n    // 3. Sử dụng hacker để lấy pass\n    \n    return 0;\n}','','cpp','2026-01-31 02:06:53'),(91,102,NULL,1,'Lớp Computer và CPU','Composition là mối quan hệ mà vật con không thể tồn tại độc lập với vật cha.\n1. Tạo lớp CPU có thuộc tính type (string).\n2. Tạo lớp Computer. Trong Computer khai báo một đối tượng CPU làm thuộc tính.\n3. Khi Computer được tạo, CPU cũng được tạo. Khi Computer bị hủy, CPU cũng biến mất.\n4. Viết hàm showSpecs() trong Computer để in ra loại CPU.','Medium','#include <iostream>\n#include <string>\nusing namespace std;\n\nclass CPU {\npublic:\n    string type;\n    CPU(string t) : type(t) {}\n};\n\nclass Computer {\nprivate:\n    CPU myCPU; // Composition\npublic:\n    // 1. Định nghĩa Constructor cho Computer để khởi tạo myCPU\n    \n    // 2. Viết hàm showSpecs()\n};\n\nint main() {\n    string t;\n    getline(cin, t);\n    // 3. Tạo Computer và hiển thị cấu hình\n    \n    return 0;\n}','','cpp','2026-01-31 02:08:17'),(92,102,NULL,1,'Lớp Department và Teacher','Aggregation là mối quan hệ mà vật con có thể tồn tại độc lập với vật cha. Chúng ta thường dùng con trỏ để thể hiện mối quan hệ này.\n1. Tạo lớp Teacher có thuộc tính name.\n2. Tạo lớp Department có thuộc tính là một con trỏ kiểu Teacher*.\n3. Khi Department bị hủy, đối tượng Teacher vẫn còn tồn tại trong main.','Hard','#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Teacher {\n\n};\n\nclass Department {\n\n};\n\nint main() {\n    \n    return 0;\n}','','cpp','2026-01-31 02:09:49'),(93,103,NULL,1,'Ghi đè chính xác với override','Từ khóa override giúp đảm bảo bạn thực sự đang ghi đè một hàm ảo từ lớp cha. Nếu bạn viết sai tên hàm hoặc sai tham số, trình biên dịch sẽ báo lỗi ngay lập tức.\n1. Tạo lớp cha Base có hàm virtual void show(int x).\n2. Tạo lớp con Derived kế thừa Base.\n3. Ghi đè hàm show trong lớp Derived và sử dụng từ khóa override.','Easy','#include <iostream>\nusing namespace std;\n\nclass Base {\npublic:\n    \n};\n\nclass Derived : public Base {\npublic:\n    // 1. Ghi đè hàm show và thêm từ khóa override ở cuối\n};\n\nint main() {\n    \n    return 0;\n}','','cpp','2026-01-31 02:11:38'),(94,103,NULL,1,'Khóa lớp và hàm với final','Yêu cầu: Tạo một lớp SuperRobot và đánh dấu nó là final. Viết hàm main thử tạo một lớp con kế thừa từ nó để hiểu tại sao nó báo lỗi (sau đó xóa phần lỗi đó để nộp bài).','Medium','#include <iostream>\nusing namespace std;\n\n// 1. Định nghĩa lớp Robot có hàm ảo move()\n\n// 2. Định nghĩa lớp SuperRobot kế thừa Robot, \n//    đánh dấu hàm move() là final để lớp sau không ghi đè được nữa.\n\nint main() {\n    cout << \"Final keyword implementation success\";\n    return 0;\n}','','cpp','2026-01-31 02:12:22'),(95,NULL,28,1,'Hệ thống quản lý tiền lương nhân viên','Yêu cầu:\n1. Tính trừu tượng: Tạo lớp trừu tượng NhanVien với thuộc tính ten (private) và hàm ảo thuần túy tinhLuong().\n2. Tính đóng gói: Sử dụng Constructor để khởi tạo tên và cung cấp hàm getTen().\n3. Tính kế thừa: * Tạo lớp NhanVienFullTime kế thừa từ NhanVien, có thêm thuộc tính luongThang. Tạo lớp NhanVienPartTime kế thừa từ NhanVien, có thêm thuộc tính soGioLam và mucLuongGio.\n4. Tính đa hình: Trong main, sử dụng một mảng các con trỏ NhanVien* để lưu trữ cả hai loại nhân viên và in ra lương của từng người.','Hard','#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\n// 1. Định nghĩa lớp trừu tượng NhanVien\nclass NhanVien {\nprivate:\n    string ten;\npublic:\n    NhanVien(string t) : ten(t) {}\n    string getTen() { return ten; }\n    \n    // Khai báo hàm ảo thuần túy tinhLuong() tại đây\n};\n\n// 2. Định nghĩa lớp NhanVienFullTime (Lương = luongThang)\n\n// 3. Định nghĩa lớp NhanVienPartTime (Lương = soGioLam * mucLuongGio)\n\nint main() {\n    // 4. Tạo danh sách nhân viên bằng vector<NhanVien*> hoặc mảng con trỏ\n    // 5. Duyệt danh sách và in kết quả: [Tên] - [Lương]\n    \n    return 0;\n}','','cpp','2026-01-31 02:13:58');
/*!40000 ALTER TABLE `coding_exercises` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `courses`
--

DROP TABLE IF EXISTS `courses`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `courses` (
  `course_id` int NOT NULL AUTO_INCREMENT,
  `course_name` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL,
  `main_language` varchar(50) COLLATE utf8mb4_unicode_ci NOT NULL,
  `course_description` text COLLATE utf8mb4_unicode_ci,
  `course_image` varchar(500) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `difficulty_level` enum('Beginner','Intermediate','Advanced') COLLATE utf8mb4_unicode_ci DEFAULT 'Beginner',
  `created_at` timestamp NULL DEFAULT CURRENT_TIMESTAMP,
  `updated_at` timestamp NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  `is_active` tinyint(1) DEFAULT '1',
  PRIMARY KEY (`course_id`)
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `courses`
--

LOCK TABLES `courses` WRITE;
/*!40000 ALTER TABLE `courses` DISABLE KEYS */;
INSERT INTO `courses` VALUES (2,'Lập Trình JavaScript Cơ Bản','Javascript','Học Javascript cơ bản phù hợp cho người chưa từng học lập trình. Với hơn 100 bài học và có bài tập thực hành sau mỗi bài học',NULL,'Beginner','2026-01-28 04:33:40','2026-01-28 04:33:40',1),(3,'Lập trình C++ cơ bản','C++','Khóa học lập trình C++ từ cơ bản tới nâng cao dành cho người mới bắt đầu. Mục tiêu của khóa học này nhằm giúp các bạn nắm được các khái niệm căn cơ của lập trình, giúp các bạn có nền tảng vững chắc để chinh phục con đường trở thành một lập trình viên.',NULL,'Beginner','2026-01-29 07:11:26','2026-01-29 07:11:26',1);
/*!40000 ALTER TABLE `courses` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `lesson_contents`
--

DROP TABLE IF EXISTS `lesson_contents`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `lesson_contents` (
  `content_id` int NOT NULL AUTO_INCREMENT,
  `lesson_id` int NOT NULL,
  `content_type` enum('theory','code') COLLATE utf8mb4_unicode_ci NOT NULL,
  `content_order` int NOT NULL,
  `content_title` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `body` text COLLATE utf8mb4_unicode_ci NOT NULL,
  `code_language` varchar(50) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `code_explanation` text COLLATE utf8mb4_unicode_ci,
  `created_at` timestamp NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`content_id`),
  KEY `idx_lesson_order` (`lesson_id`,`content_order`),
  CONSTRAINT `lesson_contents_ibfk_1` FOREIGN KEY (`lesson_id`) REFERENCES `lessons` (`lesson_id`) ON DELETE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=587 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `lesson_contents`
--

LOCK TABLES `lesson_contents` WRITE;
/*!40000 ALTER TABLE `lesson_contents` DISABLE KEYS */;
INSERT INTO `lesson_contents` VALUES (9,2,'theory',1,'JavaScript không chỉ là một ngôn ngữ, đó là sức mạnh của Web','Chào mừng bạn đến với khóa học JavaScript cơ bản! Trước khi gõ dòng code đầu tiên, bạn cần hiểu rằng JavaScript (JS) là linh hồn của mọi trang web hiện đại. Nếu HTML là khung xương, CSS là bộ quần áo, thì JS chính là bộ não giúp trang web \"sống\" và tương tác được.\n\nĐừng cố học thuộc lòng. Lập trình là tư duy giải quyết vấn đề, không phải là kỳ thi học thuộc. Bạn không cần nhớ mọi hàm hay mọi cú pháp ngay lập tức. Quan trọng là bạn biết \"tại sao\" chúng ta dùng nó và \"tìm nó ở đâu\" khi cần.',NULL,NULL,'2026-01-28 05:20:44'),(10,2,'theory',2,'Bạn cần chuẩn bị những gì?','Để chinh phục JavaScript một cách mượt mà nhất, bạn nên có kiến thức cơ bản về:\n- HTML: Biết cách tạo ra các thẻ, ID và Class.\n- CSS: Biết cách định dạng cơ bản và hiểu về Box Model.\n\nNếu bạn chưa biết gì về 2 cái trên, lời khuyên chân thành là hãy dành ra khoảng 2-3 ngày để lướt qua chúng trước. JavaScript sinh ra để điều khiển HTML và CSS, nên nếu không có \"đối tượng\" để điều khiển, bạn sẽ thấy JS rất trừu tượng và khó hiểu.',NULL,NULL,'2026-01-28 05:21:20'),(11,2,'theory',3,'Phương pháp học (Hands-on)','Đừng chỉ ngồi xem video hay đọc tài liệu. Hãy áp dụng quy tắc sau:\n- Xem: Hiểu khái niệm (20% thời gian).\n- Gõ (Code along): Gõ lại chính xác những gì bài học hướng dẫn (40% thời gian).\n- Phá (Modify): Thử thay đổi các thông số, xóa một vài ký tự để xem code lỗi thế nào (40% thời gian).\n\nChỉ khi bạn làm cho code \"chết\" và tự tay hồi sinh nó, bạn mới thực sự làm chủ được kiến thức đó.',NULL,NULL,'2026-01-28 05:22:13'),(12,2,'code',4,'Làm quen với việc nhìn thấy lỗi','// Một lỗi sai cú pháp phổ biến\nconso.log(\"Hello World\"; \n\n/* Lỗi 1: Sai tên hàm (conso thay vì console)\n   Lỗi 2: Thiếu dấu đóng ngoặc đơn \")\"\n*/','javascript','Khi bạn thấy những dòng chữ đỏ hiện lên trong tab Console, đừng hoảng sợ! Lập trình viên giỏi không phải là người không bao giờ tạo ra lỗi, mà là người biết đọc thông báo lỗi để sửa. Trong JavaScript, thông báo lỗi thường chỉ rõ cho bạn biết lỗi ở dòng nào và loại lỗi là gì (SyntaxError, ReferenceError,...). Hãy tập yêu những dòng chữ đỏ đó!','2026-01-28 05:22:46'),(13,2,'theory',5,'Lộ trình học tập tại CodePulse','Khóa học này được thiết kế theo lộ trình thực chiến:\n- Chương 1-3: Nền tảng (Biến, Kiểu dữ liệu, Câu lệnh điều kiện, Vòng lặp).\n- Chương 4-5: Xử lý logic (Hàm, Mảng, Đối tượng).\n- Chương 6: Tương tác với trình duyệt (DOM - giúp bạn tạo hiệu ứng click, ẩn hiện phần tử).\n- Chương 7: Dự án nhỏ (Xây dựng một ứng dụng To-do list hoặc Máy tính cầm tay).\n\n**Cam kết**: Nếu bạn dành ra ít nhất 1 tiếng mỗi ngày để code, mình tin chắc sau 1 tháng bạn sẽ tự tay làm được những trang web có tính tương tác cao',NULL,NULL,'2026-01-28 05:23:45'),(14,3,'theory',1,'Bộ công cụ của một Web Developer chuyên nghiệp','Để phát triển JavaScript, chúng ta cần 3 \"mảnh ghép\" chính:\n- Trình duyệt (Browser): Nơi thực thi và hiển thị kết quả. Google Chrome là lựa chọn số 1 vì bộ công cụ DevTools của nó cực kỳ mạnh mẽ cho lập trình viên.\n- Trình soạn thảo mã nguồn (Code Editor): Nơi chúng ta viết code. Visual Studio Code (VS Code) hiện đang chiếm ưu thế tuyệt đối nhờ tốc độ nhanh, miễn phí và kho tiện ích khổng lồ.\n- Môi trường thực thi (Runtime): Node.js. Dù ban đầu chúng ta học JS trên trình duyệt, nhưng cài đặt Node.js sẽ giúp bạn sử dụng được các công cụ quản lý thư viện (NPM) sau này.',NULL,NULL,'2026-01-28 05:35:02'),(15,3,'theory',1,'Hướng dẫn cài đặt và cấu hình VS Code','Các bước cài đặt:\n- Truy cập: code.visualstudio.com.\n- Tải bản ổn định (Stable) cho Windows/macOS.\n**Lưu ý cực kỳ quan trọng**: Trong quá trình cài đặt trên Windows, hãy tích vào ô \"Add to PATH\". Điều này cho phép bạn gõ lệnh code . trên terminal để mở dự án ngay lập tức.\n\nGiao diện cơ bản cần nhớ:\n- Ctrl + B: Ẩn/hiện thanh quản lý file bên trái.\n- Ctrl + ` (dấu huyền): Mở Terminal ngay trong VS Code.\n- Ctrl + P: Tìm kiếm nhanh tên file trong dự án.',NULL,NULL,'2026-01-28 05:35:59'),(16,3,'theory',1,'Cài đặt Extensions','Mở mục Extensions (biểu tượng 4 ô vuông) trong VS Code và cài đặt các tiện ích sau:\n- Live Server: Giúp tạo một máy chủ ảo. Mỗi khi bạn nhấn Ctrl + S để lưu code, trình duyệt sẽ tự động làm mới để cập nhật kết quả mà không cần tải lại trang thủ công.\n- Prettier - Code formatter: Tự động căn lề, thêm dấu chấm phẩy... giúp code của bạn luôn sạch đẹp và chuẩn hóa.\n- Auto Close Tag: Tự động đóng các thẻ HTML khi bạn vừa gõ xong thẻ mở.',NULL,NULL,'2026-01-28 05:36:45'),(17,3,'code',1,'Chạy dòng code đầu tiên (Hello World)','<!DOCTYPE html>\n<html lang=\"vi\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Học JS tại CodePulse</title>\n</head>\n<body>\n    <h1>Kiểm tra bảng điều khiển (Console)</h1>\n\n    <script src=\"script.js\"></script>\n</body>\n</html>','html','Giải thích: Lập trình viên chuyên nghiệp luôn tách biệt HTML (cấu trúc) và JavaScript (xử lý logic). Thẻ <script src=\"script.js\"></script> nên được đặt ngay trước thẻ đóng </body>. Điều này giúp trình duyệt tải xong toàn bộ giao diện rồi mới chạy đến phần xử lý, tránh tình trạng trang web bị \"đơ\" khi tải','2026-01-28 05:37:51'),(18,3,'code',1,'Sử dụng console.log() để kiểm tra','// Bước 3: Tạo file script.js cùng thư mục với index.html\nconsole.log(\"Chúc mừng! Bạn đã cài đặt môi trường thành công.\");\nconsole.log(\"Hệ thống CodePulse đã sẵn sàng đồng hành cùng bạn.\");\n\n// Thử tạo một hộp thoại thông báo\nalert(\"Chào mừng bạn đến với bài học JavaScript!\");','javascript','Giải thích:\n- console.log(): In thông tin ra tab Console của trình duyệt (F12). Đây là cách chính để chúng ta gỡ lỗi (debug).\n- alert(): Tạo một thông báo bật lên (popup) trên màn hình.\n- Cách chạy: Chuột phải vào file index.html -> Chọn \"Open with Live Server\".','2026-01-28 05:38:47'),(19,4,'theory',1,'Biến là gì?','rong lập trình, biến (variable) được hiểu đơn giản là một \"thùng chứa\" dùng để lưu trữ dữ liệu. Mỗi thùng chứa này sẽ có một tên gọi (định danh) để chúng ta có thể gọi ra và sử dụng hoặc thay đổi giá trị bên trong nó khi cần thiết.\n\nViệc sử dụng biến giúp chúng ta:\n- Lưu trữ dữ liệu để tái sử dụng nhiều lần.\n- Giúp mã nguồn dễ đọc và dễ bảo trì hơn.\n- Thực hiện các phép tính toán linh hoạt.',NULL,NULL,'2026-01-28 05:41:10'),(20,4,'code',1,'Cách khai báo biến với let và const (ES6+)','// 1. Khai báo biến có thể thay đổi giá trị\nlet score = 100;\nscore = 150; // Thay đổi giá trị mới\n\n// 2. Khai báo hằng số (không thể thay đổi giá trị)\nconst websiteName = \"CodePulse\";\n// websiteName = \"Other\"; // Sẽ gây ra lỗi TypeError\n\nconsole.log(score);\nconsole.log(websiteName);','javascript','- let: Dùng cho các biến mà bạn dự định sẽ thay đổi giá trị trong quá trình chương trình chạy (ví dụ: điểm số, số lượng hàng trong giỏ).\n- const: Viết tắt của \"constant\" (hằng số). Dùng cho các giá trị mà bạn muốn giữ nguyên từ đầu đến cuối (ví dụ: tên công ty, số Pi, mã lỗi).\n- Lưu ý: Ngày nay, lập trình viên rất hạn chế dùng var vì nó dễ gây ra các lỗi phạm vi (scope) không mong muốn.','2026-01-28 05:42:15'),(21,4,'theory',1,'Quy tắc đặt tên biến','Để code của bạn chuyên nghiệp và tránh lỗi, hãy tuân thủ các quy tắc sau:\n- Tính hợp lệ: Tên biến chỉ bao gồm chữ cái, chữ số, dấu gạch dưới _ và dấu $. Không được bắt đầu bằng chữ số.\n- Phân biệt hoa thường: fullName và fullname là hai biến hoàn toàn khác nhau.\n- Từ khóa: Không được đặt tên biến trùng với các từ khóa của ngôn ngữ (ví dụ: let, const, if, while).\n- Quy tắc CamelCase: Trong JavaScript, chúng ta thường dùng quy tắc \"lạc đà\". Ví dụ: userFirstName, productPrice, isLoggedIn.',NULL,NULL,'2026-01-28 05:42:49'),(22,4,'code',1,'Sử dụng biến trong thực tế','let price = 500;\nlet quantity = 3;\nconst taxRate = 0.1; // Thuế 10%\n\n// Tính tổng tiền\nlet total = (price * quantity) * (1 + taxRate);\n\nconsole.log(\"Tổng hóa đơn của bạn là:\");\nconsole.log(total);','javascript','Ví dụ này cho thấy sức mạnh của biến. Nếu ngày mai giá sản phẩm (price) thay đổi, bạn chỉ cần sửa giá trị ở một dòng duy nhất, toàn bộ các phép tính phía dưới sẽ tự động cập nhật chính xác.','2026-01-28 05:43:23'),(23,4,'theory',1,'Khi nào dùng let và khi nào dùng const','Một thói quen tốt của các lập trình viên JavaScript giỏi là:\n- Luôn ưu tiên dùng const mặc định cho mọi biến.\n- Chỉ chuyển sang dùng let khi bạn chắc chắn rằng giá trị của biến đó buộc phải thay đổi ở các dòng code tiếp theo.\nĐiều này giúp code của bạn an toàn hơn, tránh việc vô tình thay đổi dữ liệu quan trọng dẫn đến lỗi logic khó tìm.',NULL,NULL,'2026-01-28 05:43:50'),(24,5,'theory',1,'Tại sao cần sử dụng Comment?','Trong lập trình, Comment (Ghi chú) là những đoạn văn bản được viết trong mã nguồn nhưng không được thực thi bởi trình duyệt hoặc máy tính. Chúng chỉ phục vụ con người đọc.\n\nTác dụng của Comment:\n- Giải thích code: Giúp người khác (hoặc chính bạn trong tương lai) hiểu tại sao đoạn code đó lại được viết như vậy.\n- Ghi chú công việc (To-do): Nhắc nhở những phần cần hoàn thiện hoặc chỉnh sửa.\n- Vô hiệu hóa code (Tạm thời): Ẩn đi một đoạn mã mà không cần xóa nó, phục vụ cho việc kiểm tra lỗi (debugging).',NULL,NULL,'2026-01-28 05:45:03'),(25,5,'code',1,'Single-line Comments','// Đây là một ghi chú trên một dòng\n\nlet website = \"CodePulse\"; // Ghi chú sau một câu lệnh\n\n// console.log(\"Dòng này sẽ không chạy\");\nconsole.log(\"Dòng này sẽ chạy bình thường\");','javascript','Sử dụng hai dấu gạch chéo xuôi // để tạo ghi chú trên một dòng. Bất kỳ nội dung nào nằm sau dấu // trên cùng dòng đó sẽ bị trình duyệt lờ đi. Đây là cách nhanh nhất để giải thích các dòng lệnh ngắn gọn.','2026-01-28 05:45:32'),(26,5,'code',1,'Multi-line Comments','/* Đây là ghi chú\n   trên nhiều dòng khác nhau.\n   Thường dùng để giải thích các thuật toán phức tạp\n   hoặc mô tả chức năng của một đoạn code lớn.\n*/\n\nconst tax = 0.1;','javascript','Sử dụng cặp ký hiệu /* để bắt đầu và */ để kết thúc khối ghi chú. Tất cả nội dung nằm giữa cặp dấu này sẽ được coi là ghi chú, bất kể nó dài bao nhiêu dòng.','2026-01-28 05:46:00'),(27,5,'theory',1,'Cách Comment trong VS Code','Thay vì gõ từng dấu gạch chéo, các lập trình viên chuyên nghiệp thường sử dụng phím tắt trên Visual Studio Code:\n- Windows/Linux: Ctrl + / (Nhấn một lần để comment, nhấn lại lần nữa để bỏ comment).\n- macOS: Command + /.\n\n**Mẹo nhỏ**: Bạn có thể bôi đen một đoạn mã dài rồi nhấn phím tắt trên, VS Code sẽ tự động thêm dấu // vào đầu mỗi dòng cho bạn.',NULL,NULL,'2026-01-28 05:46:42'),(28,5,'theory',1,'Viết ghi chú sao cho chuyên nghiệp?','Đừng lạm dụng comment cho những thứ quá hiển nhiên.\n- *Nên tránh*: let a = 5; // Khai báo biến a bằng 5 (Code đã tự nói lên điều đó).\n- *Nên làm*: Giải thích lý do (Why) thay vì giải thích cái gì (What). Ví dụ: // Phải trừ đi 5px vì padding của container cha.\n\n**Châm ngôn lập trình**: Code tốt nhất là code tự giải thích được chính nó mà không cần quá nhiều ghi chú',NULL,NULL,'2026-01-28 05:47:49'),(29,6,'theory',1,'Định nghĩa Built-in trong lập trình','Trong tiếng Anh, Built-in có nghĩa là \"tích hợp sẵn\". Trong lập trình JavaScript, thuật ngữ này dùng để chỉ những hàm (functions), đối tượng (objects) hoặc hằng số đã được ngôn ngữ JavaScript xây dựng sẵn cho bạn.\n\nBạn có thể sử dụng chúng ngay lập tức mà không cần phải tự viết mã để định nghĩa chúng hay cài đặt thêm bất kỳ thư viện bên ngoài nào. Hãy tưởng tượng JavaScript giống như một ngôi nhà \"full nội thất\", và các hàm Built-in chính là những tiện nghi có sẵn như đèn, quạt, điều hòa... bạn chỉ việc bật công tắc và dùng thôi!',NULL,NULL,'2026-01-28 05:49:05'),(30,6,'code',1,'Các hàm Built-in tương tác cơ bản','// 1. Hàm hiển thị thông báo\nalert(\"Chào mừng bạn!\");\n\n// 2. Hàm yêu cầu nhập dữ liệu\nlet name = prompt(\"Tên bạn là gì?\");\n\n// 3. Hàm xác nhận hành động\nlet isReady = confirm(\"Bạn đã sẵn sàng học chưa?\");\n\n// 4. Hàm in dữ liệu ra màn hình debug\nconsole.log(\"Dữ liệu người dùng nhập:\", name);','javascript','Đây là những hàm Built-in giúp bạn tương tác nhanh với người dùng. Bạn không cần viết code để tạo ra cái hộp thông báo (alert box), JavaScript đã làm sẵn việc đó cho bạn thông qua từ khóa alert.','2026-01-28 05:49:38'),(31,6,'theory',1,'Phân loại các nhóm Built-in','JavaScript cung cấp rất nhiều nhóm Built-in để xử lý các bài toán khác nhau:\n- Nhóm tương tác (Popup): alert(), prompt(), confirm().\n- Nhóm xử lý Số học (Math): Math.random() (tạo số ngẫu nhiên), Math.round() (làm tròn số).\n- Nhóm xử lý Thời gian (Date): new Date() (lấy thời gian hiện tại).\n- Nhóm xử lý Chuỗi (String): Các phương thức giúp cắt chuỗi, viết hoa, viết thường.\n- Nhóm Debug: console.log(), console.warn(), console.error().',NULL,NULL,'2026-01-28 05:50:22'),(32,6,'theory',1,'Tại sao phải sử dụng Built-in?','Lợi ích của việc tận dụng các hàm có sẵn:\n**- Tiết kiệm thời gian**: Bạn không cần \"phát minh lại chiếc bánh xe\". Thay vì ngồi viết hàng chục dòng code để tính căn bậc hai, bạn chỉ cần dùng Math.sqrt().\n**- Hiệu suất cao**: Các hàm Built-in được tối ưu hóa cực tốt bởi các kỹ sư hàng đầu phát triển trình duyệt (như Google, Mozilla).\n**- Tính tiêu chuẩn**: Dù bạn chạy code trên Chrome, Firefox hay Safari, các hàm Built-in này đều hoạt động giống hệt nhau.',NULL,NULL,'2026-01-28 05:51:09'),(33,7,'theory',1,'Khái niệm toán tử và toán hạng','Trong lập trình, toán tử (Operator) là những ký hiệu đặc biệt dùng để thực hiện các hành động trên các giá trị dữ liệu. Các giá trị mà toán tử tác động lên được gọi là toán hạng (Operand).\n\nVí dụ đơn giản: 10 + 5\n- + là toán tử (thực hiện phép cộng).\n- 10 và 5 là các toán hạng.\n\nViệc nắm vững toán tử là chìa khóa để bạn xây dựng logic cho chương trình, từ việc tính toán đơn giản đến việc xử lý các điều kiện phức tạp.',NULL,NULL,'2026-01-28 05:55:00'),(39,7,'theory',1,'Các nhóm toán tử chính trong JavaScript','Trong chương này, chúng ta sẽ lần lượt đi qua 5 nhóm toán tử quan trọng nhất:\n- Toán tử số học (Arithmetic): Dùng để tính toán (+, -, *, /, ...).\n- Toán tử gán (Assignment): Dùng để đưa giá trị vào biến (=, +=, -=, ...).\n- Toán tử so sánh (Comparison): Dùng để so sánh hai giá trị (>, <, ===, ...). Kết quả trả về là true hoặc false.\n- Toán tử logic (Logical): Dùng để kết hợp nhiều điều kiện (&&, ||, !).\n- Toán tử chuỗi (String): Dùng để nối các đoạn văn bản lại với nhau.',NULL,NULL,'2026-01-28 06:01:34'),(40,7,'code',1,'Cách các toán tử phối hợp với nhau','// 1. Toán tử gán (=)\nlet a = 10;\nlet b = 20;\n\n// 2. Toán tử số học (+)\nlet sum = a + b; \n\n// 3. Toán tử so sánh (>)\nlet isGreater = a > b; \n\nconsole.log(\"Tổng là:\", sum);       // 30\nconsole.log(\"a có lớn hơn b?\", isGreater); // false','javascript','Đoạn code trên minh họa cách chúng ta gán giá trị cho biến, thực hiện tính toán và sau đó so sánh chúng. Bạn thấy đấy, chỉ với 3 dòng code, chúng ta đã sử dụng đến 3 loại toán tử khác nhau.','2026-01-28 06:02:04'),(41,7,'theory',1,'Quy tắc thực hiện (Precedence)','Cũng giống như trong toán học \"nhân chia trước, cộng trừ sau\", JavaScript cũng có một bảng Thứ tự ưu tiên.\n- Các phép toán trong ngoặc () luôn được thực hiện đầu tiên.\n- Toán tử nhân * và chia / có mức ưu tiên cao hơn cộng + và trừ -.\n- Khi các toán tử có cùng mức ưu tiên, chúng thường được thực hiện từ trái sang phải.',NULL,NULL,'2026-01-28 06:02:38'),(42,7,'theory',1,'Ghi nhớ trước khi bắt đầu','Đừng cố gắng học thuộc lòng bảng thứ tự ưu tiên ngay lúc này.\n\n**Lời khuyên từ CodePulse**: Nếu bạn không chắc chắn về thứ tự thực hiện, hãy luôn sử dụng cặp ngoặc đơn (). Nó không chỉ giúp code chạy đúng ý bạn mà còn giúp người khác đọc code của bạn dễ hiểu hơn rất nhiều.',NULL,NULL,'2026-01-28 06:03:21'),(43,9,'theory',1,'Danh sách các toán tử số học','Trong JavaScript, chúng ta có các ký hiệu toán học quen thuộc để làm việc với dữ liệu kiểu số:\n- Phép cộng (+): Dùng để tính tổng hai giá trị.\n- Phép trừ (-): Dùng để lấy hiệu của hai giá trị.\n- Phép nhân (*): Dùng để tính tích.\n- Phép chia (/): Dùng để tính thương. Lưu ý rằng kết quả của phép chia trong JS sẽ trả về số thập phân nếu phép chia không hết (ví dụ: 5 / 2 sẽ ra 2.5).',NULL,NULL,'2026-01-28 06:05:21'),(44,9,'code',1,'Áp dụng cộng, trừ, nhân, chia trong mã nguồn','let a = 20;\nlet b = 5;\n\nlet tong = a + b; // 25\nlet hieu = a - b; // 15\nlet tich = a * b; // 100\nlet thuong = a / b; // 4\n\nconsole.log(\"Kết quả phép chia 10 cho 3 là:\", 10 / 3);','javascript','Các toán tử này hoạt động như trong máy tính bỏ túi. Điểm cần nhớ là JavaScript không tự động làm tròn số nguyên trong phép chia, bạn sẽ nhận được một dãy số thập phân dài nếu kết quả là số vô hạn tuần hoàn.','2026-01-28 06:05:50'),(45,9,'theory',1,'Toán tử Chia lấy dư (%) và Lũy thừa (**)','Ngoài các phép tính cơ bản, JavaScript cung cấp hai toán tử cực kỳ hữu ích:Toán tử số dư (Modulus - %): - - Phép tính này trả về phần dư còn lại sau khi thực hiện phép chia nguyên. Đây là \"vũ khí\" bí mật để lập trình viên kiểm tra xem một số là chẵn hay lẻ (số chẵn khi chia cho 2 sẽ dư 0).\n- Toán tử lũy thừa (**): Dùng để tính số mũ. Ví dụ: $2^3$ sẽ được viết là 2 ** 3. Đây là cú pháp mới (ES6) giúp thay thế cho hàm Math.pow() dài dòng trước đây.',NULL,NULL,'2026-01-28 06:06:28'),(46,9,'code',1,'Cách dùng % và ** trong thực tế','// Kiểm tra số dư\nlet n = 11;\nlet soDu = n % 2; \nconsole.log(\"11 chia 2 dư bao nhiêu?\", soDu); // Kết quả: 1\n\n// Tính lũy thừa\nlet base = 5;\nlet result = base ** 2; // Tương đương 5 bình phương\nconsole.log(\"5 mũ 2 bằng:\", result); // Kết quả: 25','javascript','Nếu n % 2 bằng 0, số đó là số chẵn. Nếu bằng 1, đó là số lẻ. Còn với toán tử **, bạn có thể tính các số mũ rất lớn một cách cực kỳ nhanh chóng.','2026-01-28 06:06:53'),(47,9,'theory',1,'Thứ tự ưu tiên của toán tử','JavaScript tuân thủ nghiêm ngặt quy tắc toán học về thứ tự thực hiện các phép tính:\n- Dấu ngoặc đơn () luôn được ưu tiên cao nhất.\n- Lũy thừa ** đứng thứ hai.\n- Nhân *, Chia / và Chia lấy dư % đứng thứ ba.\n- Cộng + và Trừ - đứng cuối cùng.\n\nKhi các phép tính có cùng mức ưu tiên, JavaScript sẽ thực hiện từ trái sang phải. Nếu bạn muốn thay đổi thứ tự này, hãy luôn bọc các phần muốn tính trước vào trong cặp ngoặc đơn.',NULL,NULL,'2026-01-28 06:07:39'),(48,9,'theory',1,'Những điều cần khắc cốt ghi tâm','Sử dụng + - * / cho toán học thông thường.\nDùng % để kiểm tra tính chia hết (chia lấy dư).\nDùng ** thay cho Math.pow() khi muốn tính số mũ.\nĐừng bao giờ quên dấu ngoặc đơn () khi biểu thức của bạn bắt đầu phức tạp để tránh kết quả sai lệch \"đi vào lòng đất\".',NULL,NULL,'2026-01-28 06:08:08'),(49,10,'theory',1,'Ý nghĩa của dấu bằng trong lập trình','Trong toán học, dấu = dùng để chỉ sự bằng nhau. Nhưng trong lập trình JavaScript, dấu = là toán tử gán. Nó có nhiệm vụ lấy giá trị ở phía bên phải và đưa vào biến ở phía bên trái.\n\nVí dụ: let x = 10; có nghĩa là \"gán giá trị 10 cho biến x\", chứ không phải là x bằng 10 theo nghĩa so sánh. Luôn ghi nhớ luồng dữ liệu sẽ đi từ phải sang trái.',NULL,NULL,'2026-01-28 06:10:38'),(50,10,'code',1,'Cách viết tắt khi tăng giá trị','let x = 10;\n\n// Cách viết thông thường:\nx = x + 5; \n\n// Cách viết tắt dùng toán tử gán:\nx += 5; \n\nconsole.log(x); // Kết quả: 20','javascript','Phép toán x += 5 hoàn toàn tương đương với x = x + 5. Đây là cách viết cực kỳ phổ biến khi bạn muốn cộng thêm một giá trị vào chính biến đó mà không muốn gõ lại tên biến hai lần.','2026-01-28 06:11:05'),(51,10,'theory',1,'Các toán tử gán kết hợp khác','Tương tự như phép cộng, chúng ta có các toán tử gán kết hợp cho mọi phép tính số học khác:\n- Toán tử -=: x -= y tương đương với x = x - y.\n- Toán tử *=: x *= y tương đương với x = x * y.\n- Toán tử /=: x /= y tương đương với x = x / y.\n- Toán tử **=: x **= y tương đương với x = x ** y (lũy thừa).\n- Toán tử %=: x %= y tương đương với x = x % y (chia lấy dư).',NULL,NULL,'2026-01-28 06:11:44'),(52,10,'code',1,'Áp dụng tính toán nhanh','let a = 10;\nlet b = 2;\n\na *= b; // a = 10 * 2 = 20\nconsole.log(\"Sau khi nhân bằng 2:\", a);\n\na /= 4; // a = 20 / 4 = 5\nconsole.log(\"Sau khi chia bằng 4:\", a);\n\na **= 2; // a = 5 mũ 2 = 25\nconsole.log(\"Sau khi lũy thừa bằng 2:\", a);','javascript','Việc sử dụng các toán tử này giúp mã nguồn của bạn ngắn gọn hơn, giảm thiểu sai sót khi phải gõ lại những tên biến dài và phức tạp.','2026-01-28 06:12:09'),(53,10,'code',1,'Toán tử gán với chuỗi','let greeting = \"Chào mừng bạn \";\ngreeting += \"đến với CodePulse!\";\n\nconsole.log(greeting);\n// Kết quả: \"Chào mừng bạn đến với CodePulse!\"','javascript','Toán tử += không chỉ dùng cho số mà còn cực kỳ hữu ích để nối thêm văn bản vào một chuỗi có sẵn. Đây là kỹ thuật thường dùng để xây dựng các câu thông báo hoặc các đoạn mã HTML động.','2026-01-28 06:12:35'),(54,10,'theory',1,'Ghi nhớ nhanh','- Luôn nhớ dấu = là gán (phải sang trái).\n- Các toán tử +=, -=, *=, /= là cách viết tắt để cập nhật giá trị của chính biến đó.\n- Sử dụng shorthand (viết tắt) giúp code sạch sẽ và chuyên nghiệp hơn.',NULL,NULL,'2026-01-28 06:13:01'),(55,11,'theory',1,'Toán tử đơn tử (Unary Operators)','Toán tử ++ (tăng 1 đơn vị) và -- (giảm 1 đơn vị) được gọi là toán tử đơn tử vì chúng chỉ tác động lên một toán hạng duy nhất (một biến).\n\nTuy nhiên, vị trí đặt toán tử trước hay sau tên biến sẽ quyết định cách thức JavaScript thực thi câu lệnh đó. Chúng ta chia làm 2 loại:\n- Postfix (Hậu tố): Toán tử nằm sau biến (Ví dụ: x++, x--).\n- Prefix (Tiền tố): Toán tử nằm trước biến (Ví dụ: ++x, --x).',NULL,NULL,'2026-01-28 06:16:38'),(56,11,'theory',1,'Nguyên lý Postfix (x++ hoặc x--)','Khi bạn sử dụng toán tử theo kiểu Postfix (hậu tố), JavaScript sẽ thực hiện theo 3 bước cực kỳ nhanh:\n- Tạo ra một bản sao giá trị hiện tại của biến (biến tạm).\n- Thực hiện thay đổi (tăng/giảm) giá trị của biến thật.\n- Trả về bản sao (giá trị cũ) cho biểu thức đang tính toán.\n\n**Kết quả**: Ở dòng lệnh đó, bạn vẫn thấy giá trị cũ, nhưng ở dòng lệnh tiếp theo, biến đã mang giá trị mới.',NULL,NULL,'2026-01-28 06:17:11'),(57,11,'code',1,'Ví dụ về Postfix (x++)','let a = 5;\nlet b = a++; // b sẽ nhận giá trị của a trước khi tăng\n\nconsole.log(\"Giá trị của b (kết quả trả về):\", b); // 5\nconsole.log(\"Giá trị của a (sau khi đã tăng):\", a); // 6','javascript','Ở dòng 2, a++ sẽ trả về giá trị 5 để gán cho b trước, sau đó a mới âm thầm tăng lên thành 6. Đây chính là lý do bạn thấy b vẫn bằng 5.','2026-01-28 06:17:42'),(58,11,'theory',1,'Nguyên lý Prefix (++x hoặc --x)','Với kiểu Prefix (tiền tố), quy trình diễn ra đơn giản và trực diện hơn:\n- Thực hiện thay đổi (tăng/giảm) giá trị của biến ngay lập tức.\n- Trả về giá trị mới vừa thay đổi cho biểu thức.\n\nKết quả: Ngay tại dòng lệnh đó, cả biến và biểu thức đều mang giá trị mới đã được tăng/giảm.',NULL,NULL,'2026-01-28 06:18:44'),(59,11,'code',1,'Ví dụ về Prefix (++x)','let x = 10;\nlet y = ++x; // x tăng lên 11 trước, sau đó y nhận giá trị 11\n\nconsole.log(\"Giá trị của y:\", y); // 11\nconsole.log(\"Giá trị của x:\", x); // 11','javascript','Vì dấu ++ nằm trước, JavaScript ưu tiên thực hiện việc tăng giá trị cho x lên 11 trước rồi mới lấy số 11 đó gán cho y. Do đó cả hai đều bằng 11.','2026-01-28 06:24:32'),(60,11,'code',1,'Kết hợp nhiều toán tử','let output = 1;\n\n// Phép toán phức tạp:\n// Kết quả = 1 + 2 (sau đó output thành 2) + 2 (sau khi output đã thành 2)\nlet result = output++ + ++output;\n\nconsole.log(\"Result:\", result); // 4\nconsole.log(\"Output cuối cùng:\", output); // 3','javascript','1. output++: Trả về 1, sau đó output tăng lên 2.\n2. ++output: output đang là 2 tăng vọt lên 3, sau đó trả về 3. \n3. Phép tính trở thành: 1 + 3 = 4. output cuối cùng dừng lại ở giá trị 3.','2026-01-28 06:25:41'),(61,11,'theory',1,'Ghi nhớ nguyên lý','- Tiền tố (++x): Tăng trước, trả về sau (Dùng giá trị mới).\n\n- Hậu tố (x++): Trả về trước, tăng sau (Dùng giá trị cũ).\n\n**Lời khuyên chuyên nghiệp**: Trong thực tế, để tránh gây nhầm lẫn và khó đọc code (như ví dụ ở Phần 6), các lập trình viên thường tách việc tăng giá trị và việc tính toán ra các dòng riêng biệt. Hãy ưu tiên viết code dễ hiểu hơn là viết code quá ngắn gọn mà gây hại não cho đồng nghiệp!',NULL,NULL,'2026-01-28 06:28:47'),(62,12,'theory',1,'Khái niệm về nối chuỗi','Trong JavaScript, khi toán tử + được sử dụng với các toán hạng là kiểu chuỗi (String), nó sẽ không thực hiện phép cộng số học mà chuyển sang chức năng nối chuỗi.\n\nPhép toán này sẽ ghép nội dung của chuỗi phía sau vào ngay sau nội dung của chuỗi phía trước để tạo thành một chuỗi mới dài hơn.',NULL,NULL,'2026-01-28 06:30:03'),(63,12,'code',1,'Cách nối chuỗi cơ bản','let firstName = \"Nguyễn\";\nlet lastName = \"Văn A\";\n\n// Nối các chuỗi và thêm một khoảng trắng ở giữa\nlet fullName = firstName + \" \" + lastName;\n\nconsole.log(fullName); // Kết quả: \"Nguyễn Văn A\"\n\nlet msg = \"Chào mừng \" + fullName + \" đến với CodePulse!\";\nconsole.log(msg);','javascript','Để tên hiển thị đẹp mắt, chúng ta thường phải chủ động cộng thêm một chuỗi rỗng có khoảng trắng \" \" ở giữa các biến. Nếu không, các chữ sẽ dính liền vào nhau thành \"NguyễnVăn A\".','2026-01-28 06:30:30'),(64,12,'theory',1,'Sự ưu tiên của kiểu chuỗi','Một đặc điểm cực kỳ quan trọng của JavaScript là khi bạn thực hiện phép cộng giữa một số và một chuỗi, JavaScript sẽ tự động chuyển đổi số đó sang kiểu chuỗi rồi thực hiện phép nối.\n\n**Quy tắc**: Số + Chuỗi = Chuỗi.\n\nTuy nhiên, các toán tử khác như -, *, / lại cố gắng chuyển chuỗi thành số để tính toán. Đây là điểm rất dễ gây nhầm lẫn cho người mới bắt đầu.',NULL,NULL,'2026-01-28 06:30:55'),(65,12,'code',1,'Cẩn thận khi tính toán với chuỗi','let x = 10 + 20;      // Kết quả: 30 (Số + Số)\nlet y = \"10\" + 20;    // Kết quả: \"1020\" (Chuỗi + Số)\nlet z = \"10\" + \"20\";  // Kết quả: \"1020\" (Chuỗi + Chuỗi)\n\nconsole.log(y);\nconsole.log(\"Phép trừ với chuỗi:\", \"10\" - 2); // Kết quả: 8 (Lạ chưa!)','javascript','- Ở biến y, số 20 bị biến thành chuỗi \"20\" và dính vào sau \"10\".\n- Ở dòng cuối, vì toán tử - không có chức năng nối chuỗi, nên JS ép kiểu chuỗi \"10\" thành số 10 để trừ cho 2. Đây là lý do bạn cần cực kỳ cẩn thận khi nhận dữ liệu từ người dùng (thường là kiểu chuỗi).','2026-01-28 06:31:34'),(66,12,'theory',1,'Template Literals - Cách nối chuỗi hiện đại (ES6)','Việc sử dụng quá nhiều dấu + và dấu ngoặc kép khiến code rất rối mắt. JavaScript hiện đại cung cấp cách nối chuỗi thông minh hơn gọi là Template Literals.\n- Sử dụng cặp dấu backtick ( ` ) (phím nằm dưới nút Esc).\n- Để đưa biến vào chuỗi, ta dùng cú pháp: ${tên_biến\n- Cách này cho phép bạn xuống dòng thoải mái mà không làm hỏng chuỗi.',NULL,NULL,'2026-01-28 06:32:51'),(67,12,'code',1,'Code sạch hơn với Template Literals','let product = \"Laptop Dell\";\nlet price = 1500;\nlet quantity = 2;\n\n// Cách cũ:\n// console.log(\"Bạn đã mua \" + quantity + \" cái \" + product + \" với giá \" + (price * quantity) + \" USD\");\n\n// Cách hiện đại:\nconsole.log(`Bạn đã mua ${quantity} cái ${product} với giá ${price * quantity} USD`);','javascript','Bạn có thể thấy cách viết thứ hai dễ đọc hơn nhiều. Bạn có thể thực hiện cả phép tính toán ngay bên trong dấu ${}. Đây là cách mà hầu hết các lập trình viên JavaScript hiện nay tin dùng.','2026-01-28 06:33:30'),(68,12,'theory',1,'Ghi nhớ nhanh','- Toán tử + dùng để nối chuỗi.\n- Bất cứ thứ gì cộng với chuỗi đều trở thành chuỗi.\n- Ưu tiên sử dụng Template Literals (dấu backtick) để code sạch sẽ và chuyên nghiệp hơn.',NULL,NULL,'2026-01-28 06:37:56'),(69,13,'theory',1,'Toán tử so sánh là gì?','Toán tử so sánh được sử dụng để so sánh hai giá trị với nhau. Kết quả của một phép so sánh không phải là một con số, mà luôn luôn là một giá trị Boolean: hoặc là true (Đúng) hoặc là false (Sai).\n\nHãy tưởng tượng toán tử so sánh như một câu hỏi:\n- \"Số A có lớn hơn số B không?\"\n- \"Tên đăng nhập có khớp với dữ liệu không?\"\n\nNếu đúng, JavaScript trả về true. Nếu sai, nó trả về false. Đây là nền tảng cốt lõi để chúng ta viết các câu lệnh điều kiện (If/Else) sau này.',NULL,NULL,'2026-01-28 06:38:58'),(70,13,'code',1,'Các toán tử so sánh quan hệ','let a = 10;\nlet b = 20;\n\nconsole.log(a > b);  // Lớn hơn -> false\nconsole.log(a < b);  // Nhỏ hơn -> true\nconsole.log(a >= 10); // Lớn hơn hoặc bằng -> true\nconsole.log(b <= 20); // Nhỏ hơn hoặc bằng -> true','javascript','- > và <: So sánh nghiêm ngặt.\n- >= và <=: So sánh bao gồm cả trường hợp bằng nhau.\nLưu ý: Khi so sánh số với số, JavaScript hoạt động y hệt toán học thông thường.','2026-01-28 06:39:44'),(71,13,'theory',1,'Sự khác biệt giữa == và ===','Trong JavaScript, có hai cách để so sánh \"Bằng\":\n- So sánh tương đối (==): Chỉ so sánh giá trị, không quan tâm đến kiểu dữ liệu. JavaScript sẽ cố gắng ép kiểu để hai bên giống nhau rồi mới so sánh.\n- So sánh tuyệt đối (===): So sánh cả Giá trị và Kiểu dữ liệu. Hai giá trị chỉ bằng nhau nếu chúng vừa giống nhau về nội dung, vừa cùng là số (Number) hoặc cùng là chuỗi (String).\n\n**Lời khuyên vàng**: Luôn luôn sử dụng === để tránh những lỗi logic khó hiểu do JavaScript tự động ép kiểu gây ra.',NULL,NULL,'2026-01-28 06:40:22'),(72,13,'code',1,'Đừng để JavaScript lừa bạn','let x = 10;     // Kiểu Number\nlet y = \"10\";   // Kiểu String\n\nconsole.log(x == y);  // true (Vì giá trị đều là 10)\nconsole.log(x === y); // false (Vì một bên là số, một bên là chữ)\n\n// So sánh khác (Not Equal)\nconsole.log(x != y);  // false (Vì chúng \"tương đối\" bằng nhau)\nconsole.log(x !== y); // true (Vì chúng \"tuyệt đối\" khác nhau)','javascript','- !== là toán tử \"Khác tuyệt đối\". Nó sẽ trả về true nếu hai giá trị khác nhau về nội dung HOẶC khác nhau về kiểu dữ liệu.\n- Trong thực tế, cặp bài trùng === và !== là những lựa chọn an toàn nhất cho mọi lập trình viên.','2026-01-28 06:41:09'),(73,13,'code',1,'So sánh chuỗi (String Comparison)','let name1 = \"An\";\nlet name2 = \"Anh\";\n\nconsole.log(name1 === \"An\"); // true\nconsole.log(\"A\" < \"B\");      // true (Dựa trên bảng mã ASCII/Unicode)\nconsole.log(name1 < name2);  // true','javascript','Khi so sánh chuỗi, JavaScript so sánh từng ký tự một từ trái sang phải dựa trên giá trị trong bảng mã Unicode. Ký tự nào đứng sau trong bảng chữ cái sẽ có giá trị \"lớn hơn\". \nLưu ý: Chữ hoa và chữ thường có giá trị khác nhau hoàn toàn!','2026-01-28 06:41:43'),(74,13,'theory',1,'Tổng kết ghi nhớ','- Kết quả so sánh luôn là true hoặc false.\n- > , < , >= , <= : Dùng cho so sánh số lượng.\n- === : So sánh bằng tuyệt đối (Khuyên dùng).\n- !== : So sánh khác tuyệt đối (Khuyên dùng).\n- Tránh dùng == và != trừ khi bạn thực sự hiểu mình đang làm gì.',NULL,NULL,'2026-01-28 06:42:20'),(75,14,'theory',1,'Boolean là gì?','Trong JavaScript, Boolean là một kiểu dữ liệu nguyên thủy chỉ có thể nhận một trong hai giá trị duy nhất: true (Đúng) hoặc false (Sai).\n\nTên gọi \"Boolean\" được đặt theo tên của nhà toán học George Boole, người đã đặt nền móng cho logic đại số. Trong lập trình, kiểu dữ liệu này giống như một chiếc công tắc đèn: chỉ có thể là Bật hoặc Tắt. Nó được dùng để trả lời cho các câu hỏi mang tính chất khẳng định/phủ định trong code.',NULL,NULL,'2026-01-28 06:43:29'),(76,14,'code',1,'Gán trực tiếp và kết quả từ phép so sánh','// 1. Gán trực tiếp giá trị\nlet isSuccess = true;\nlet isError = false;\n\n// 2. Kết quả từ một phép so sánh (Như đã học ở bài 26)\nlet isGreater = 10 > 5; // true\nlet isLess = 10 < 5;    // false\n\nconsole.log(typeof isSuccess); // \"boolean\"\nconsole.log(isGreater);        // true','javascript','- Bạn có thể gán true hoặc false trực tiếp cho biến để làm \"cờ hiệu\" (flag).\n- Phổ biến hơn, Boolean thường là kết quả của các phép so sánh. Hàm typeof sẽ giúp bạn xác nhận một biến có phải là kiểu Boolean hay không.','2026-01-28 06:43:59'),(77,14,'theory',1,'Tại sao Boolean lại quan trọng?','Boolean đóng vai trò là \"người điều khiển giao thông\" trong mã nguồn của bạn. Chúng được sử dụng để:\n- Kiểm tra trạng thái: Người dùng đã đăng nhập chưa? (isLoggedIn)\n- Kiểm tra điều kiện: Sản phẩm còn hàng không? (isInStock)\n- Điều hướng: Nếu isSuccess là true, hãy chuyển trang. Nếu là false, hãy hiển thị thông báo lỗi.\n\nHầu hết các logic \"Nếu... thì...\" (If... Else) mà bạn sắp học đều dựa trên việc kiểm tra xem một giá trị là true hay false.',NULL,NULL,'2026-01-28 06:44:34'),(78,14,'code',1,'Boolean và sự linh hoạt của JavaScript','let name = \"CodePulse\";\nlet age = 25;\n\n// Sử dụng hàm Boolean() để kiểm tra\nconsole.log(Boolean(name)); // true\nconsole.log(Boolean(age));  // true\nconsole.log(Boolean(0));    // false','javascript','JavaScript có một đặc điểm thú vị là mọi giá trị khác (chuỗi, số, đối tượng) đều có thể được coi là \"tương đương\" với true hoặc false','2026-01-28 06:45:03'),(79,14,'theory',1,'Tổng kết ghi nhớ','Boolean:\n- Chỉ có 2 giá trị: true và false.\n- Không viết hoa (viết là true, không phải True).\n- Không đặt trong dấu ngoặc kép (nếu viết \"true\" thì nó trở thành một chuỗi văn bản, không còn là Boolean).\n- Là nền tảng để máy tính đưa ra quyết định.',NULL,NULL,'2026-01-28 06:45:54'),(80,15,'theory',1,'Tư duy Nếu - Thì trong lập trình','Trong cuộc sống, chúng ta luôn đưa ra quyết định dựa trên điều kiện: \"Nếu trời mưa, tôi sẽ mang ô\". Trong lập trình, câu lệnh if thực hiện nhiệm vụ y hệt như vậy.\n\nCâu lệnh if cho phép bạn kiểm tra một điều kiện (thường là một phép so sánh trả về Boolean).\n- Nếu điều kiện đó là true, khối mã bên trong dấu ngoặc nhọn {} sẽ được thực thi.\n- Nếu điều kiện đó là false, JavaScript sẽ bỏ qua khối mã đó và chạy tiếp các dòng bên dưới.',NULL,NULL,'2026-01-28 06:47:29'),(81,15,'code',1,'Cách viết câu lệnh If đơn giản','let isPayDay = true;\n\nif (isPayDay) {\n    console.log(\"Đi ăn lẩu thôi nào!\");\n}\n\nconsole.log(\"Tiếp tục làm việc...\");','javascript','Cấu trúc gồm từ khóa if, theo sau là cặp ngoặc đơn () chứa điều kiện. Nếu isPayDay là true, dòng chữ \"Đi ăn lẩu\" sẽ hiện ra. Lưu ý rằng dòng \"Tiếp tục làm việc\" luôn luôn chạy vì nó nằm ngoài khối if.','2026-01-28 06:47:55'),(82,15,'theory',1,'Xử lý trường hợp ngược lại với Else','Sẽ ra sao nếu bạn muốn thực hiện một hành động khác khi điều kiện là false? Đó là lúc chúng ta dùng thêm từ khóa else.\n\nelse đóng vai trò là phương án dự phòng. Nếu điều kiện trong if không thỏa mãn, khối mã bên trong else chắc chắn sẽ được thực thi. Điều này tạo ra một sự lựa chọn \"hoặc cái này, hoặc cái kia\".',NULL,NULL,'2026-01-28 06:48:17'),(83,15,'code',1,'Kiểm tra quyền truy cập nội dung','let userAge = 16;\n\nif (userAge >= 18) {\n    console.log(\"Bạn đủ điều kiện đăng ký lái xe.\");\n} else {\n    console.log(\"Bạn cần đủ 18 tuổi để thực hiện thao tác này.\");\n}','javascript','Đây là logic rất phổ biến trên các website. JavaScript sẽ kiểm tra biến userAge. Vì 16 nhỏ hơn 18, điều kiện userAge >= 18 trả về false, do đó đoạn mã trong phần else sẽ được chạy.','2026-01-28 06:48:46'),(84,15,'code',1,'Kết hợp nhiều điều kiện với Else If','let score = 8.5;\n\nif (score >= 9) {\n    console.log(\"Hạng: Xuất sắc\");\n} else if (score >= 8) {\n    console.log(\"Hạng: Giỏi\");\n} else if (score >= 6.5) {\n    console.log(\"Hạng: Khá\");\n} else {\n    console.log(\"Hạng: Trung bình\");\n}','javascript','Khi bạn có nhiều hơn 2 sự lựa chọn, hãy dùng else if. JavaScript sẽ kiểm tra từ trên xuống dưới, hễ gặp điều kiện nào đúng đầu tiên thì thực hiện khối mã đó và thoát khỏi toàn bộ cấu trúc if... else if.','2026-01-28 06:49:22'),(85,15,'theory',1,'Lưu ý quan trọng khi dùng If else','- Luôn bọc điều kiện trong cặp ngoặc đơn ().\n- Nên luôn sử dụng cặp ngoặc nhọn {} ngay cả khi chỉ có một dòng lệnh để code rõ ràng và tránh lỗi.\n- else luôn đứng ở cuối cùng và không kèm theo điều kiện nào cả.\n- Đừng quên thụt lề (indentation) cho các dòng code bên trong để dễ theo dõi logic.',NULL,NULL,'2026-01-28 06:49:53'),(86,16,'theory',1,'Tại sao cần toán tử Logical?','Trong thực tế, một hành động thường chỉ xảy ra khi thỏa mãn đồng thời nhiều điều kiện hoặc một trong nhiều điều kiện. Ví dụ:\n- Để đăng nhập: Cần đúng Email VÀ đúng Mật khẩu.\n- Để được miễn phí giao hàng: Cần đơn hàng trên 500k HOẶC có mã giảm giá.\n\nJavaScript cung cấp 3 toán tử logic chính để thực hiện việc này:\n- AND (&&): Trả về true nếu tất cả các điều kiện đều đúng.\n- OR (||): Trả về true nếu ít nhất một điều kiện đúng.\n- NOT (!): Nghịch đảo giá trị Boolean hiện tại.',NULL,NULL,'2026-01-28 06:51:44'),(87,16,'code',1,'Toán tử AND (&&)','let age = 25;\nlet hasLicense = true;\n\n// Điều kiện: Phải đủ 18 tuổi VÀ có bằng lái\nif (age >= 18 && hasLicense === true) {\n    console.log(\"Bạn đủ điều kiện lái xe ô tô.\");\n} else {\n    console.log(\"Bạn không được phép lái xe.\");\n}','javascript','Toán tử && yêu cầu mọi vế so sánh phải là true. Chỉ cần một vế là false, toàn bộ biểu thức sẽ trả về false ngay lập tức. Đây là cách kiểm tra tính chặt chẽ của dữ liệu.','2026-01-28 06:52:08'),(88,16,'code',1,'Toán tử OR (||)','let isWeekend = true;\nlet isHoliday = false;\n\n// Điều kiện: Là cuối tuần HOẶC là ngày lễ thì được nghỉ\nif (isWeekend || isHoliday) {\n    console.log(\"Hôm nay được nghỉ, đi chơi thôi!\");\n} else {\n    console.log(\"Vẫn phải đi làm/đi học nhé.\");\n}','javascript','Với toán tử ||, chỉ cần một trong các điều kiện trả về true, toàn bộ biểu thức sẽ là true. Nó chỉ trả về false khi tất cả các vế đều sai.','2026-01-28 06:52:31'),(89,16,'code',1,'Toán tử NOT (!)','let isLoggedIn = false;\n\n// Nếu \"KHÔNG\" đăng nhập\nif (!isLoggedIn) {\n    console.log(\"Vui lòng đăng nhập để xem nội dung này.\");\n}\n\nlet isSuccess = true;\nconsole.log(\"Đảo ngược của true là:\", !isSuccess); // false','javascript','Toán tử ! đặt trước một giá trị Boolean để đảo ngược nó. Nó cực kỳ hữu ích khi bạn muốn kiểm tra các trường hợp phủ định (ví dụ: kiểm tra nếu giỏ hàng trống, nếu người dùng chưa điền tên...).','2026-01-28 06:52:57'),(90,16,'theory',1,'Cách JavaScript tối ưu hóa việc kiểm tra','JavaScript rất thông minh khi xử lý toán tử logic để tiết kiệm tài nguyên:\n- Với &&: Nếu vế đầu tiên đã là false, JavaScript sẽ dừng lại luôn và trả về false mà không cần kiểm tra các vế sau (vì kết quả chắc chắn sai rồi).\n- Với ||: Nếu vế đầu tiên đã là true, JavaScript sẽ dừng lại và trả về true ngay (vì kết quả chắc chắn đúng rồi).\n\nHiểu nguyên lý này giúp bạn tránh được các lỗi khi truy cập vào các biến chưa tồn tại hoặc tối ưu tốc độ xử lý của ứng dụng.',NULL,NULL,'2026-01-28 06:53:28'),(91,16,'theory',1,'Tổng kết ghi nhớ','- a && b: Đúng khi cả a và b cùng đúng.\n- a || b: Đúng khi chỉ cần a hoặc b đúng.\n- !a: Biến đúng thành sai, sai thành đúng.\n\n**Kết hợp nhiều toán tử**: Hãy sử dụng ngoặc đơn ( ) để xác định rõ nhóm nào cần tính trước, tránh nhầm lẫn.',NULL,NULL,'2026-01-28 06:53:57'),(92,17,'theory',1,'Tổng quan và Đặc tính Dynamic Typing','Trong các ngôn ngữ như Java hay C++, bạn phải khai báo rõ biến đó là số hay chữ. Nhưng với JavaScript, nó là một ngôn ngữ Dynamic Typing (Kiểu dữ liệu động). Bạn không cần khai báo kiểu, JavaScript sẽ tự nhìn vào giá trị bạn gán để quyết định kiểu của biến đó.\n\nChúng ta chia kiểu dữ liệu thành 2 nhóm chính:\n- Kiểu nguyên thủy (Primitive Data): Dữ liệu đơn giản, không thể thay đổi nội dung (String, Number, Boolean, Null, Undefined, Symbol, BigInt).\n- Kiểu dữ liệu phức tạp (Complex/Reference Data): Dữ liệu có thể chứa nhiều giá trị khác bên trong (Object, Array, Function).',NULL,NULL,'2026-01-28 09:01:39'),(93,17,'code',1,'Kiểu dữ liệu Số (Number) và Chuỗi (String)','// 1. Number: Bao gồm cả số nguyên và số thập phân\nlet age = 25;\nlet pi = 3.14;\n\n// 2. String: Phải đặt trong dấu \'\', \"\" hoặc ``\nlet name = \'CodePulse\';\nlet message = \"Chào mừng bạn đến với \'JavaScript\'\";','javascript','- Với Number, JavaScript không phân biệt int (số nguyên) hay float (số thập phân) như các ngôn ngữ khác, tất cả đều là Number.\n- Với String, bạn có thể dùng nháy đơn hoặc nháy đôi, miễn là bắt đầu và kết thúc phải đồng nhất.','2026-01-28 09:02:11'),(94,17,'theory',1,'Phân biệt Undefined và Null','Đây là hai khái niệm mà người mới rất hay nhầm:\n- Undefined: Xuất hiện khi bạn khai báo một biến nhưng chưa gán giá trị cho nó. Nó giống như một chiếc hộp trống không có gì bên trong.\n- Null: Là một giá trị bạn chủ động gán cho biến để báo hiệu rằng \"biến này hiện tại không có giá trị gì cả\". Nó giống như việc bạn cố tình để chiếc hộp trống.',NULL,NULL,'2026-01-28 09:02:39'),(95,17,'code',1,'Kiểu dữ liệu phức tạp (Object)','// Object: Lưu trữ dưới dạng cặp key - value\nlet user = {\n    name: \'Hoàng\',\n    age: 20,\n    isVip: true\n};\n\n// Array: Danh sách các phần tử (cũng là một dạng Object)\nlet colors = [\'Red\', \'Green\', \'Blue\'];\n\nconsole.log(user.name); // \'Hoàng\'\nconsole.log(colors[0]); // \'Red\'','javascript','Object cho phép bạn gom nhóm các thông tin liên quan lại với nhau. Array lại giúp bạn lưu trữ một danh sách theo thứ tự. Đây là những kiểu dữ liệu cực kỳ quyền năng mà bạn sẽ dùng để nhận dữ liệu từ các Server (API).','2026-01-28 09:03:00'),(96,17,'code',1,'Cách kiểm tra kiểu dữ liệu với typeof','console.log(typeof 10);          // \"number\"\nconsole.log(typeof \"Hello\");     // \"string\"\nconsole.log(typeof true);        // \"boolean\"\nconsole.log(typeof undefined);   // \"undefined\"\nconsole.log(typeof null);        // \"object\" (Đây là một lỗi lịch sử của JS)\nconsole.log(typeof {a: 1});      // \"object\"','javascript','Toán tử typeof trả về một chuỗi cho biết kiểu dữ liệu của biến. Lưu ý đặc biệt: typeof null trả về \"object\". Đây là một lỗi nổi tiếng từ phiên bản đầu tiên của JavaScript nhưng không được sửa vì để đảm bảo tính tương thích. Hãy nhớ kỹ điều này để không bị \"lừa\" khi làm bài thi hoặc phỏng vấn!','2026-01-28 09:03:21'),(97,17,'theory',1,'Tổng kết bài học','- Kiểu nguyên thủy: Number, String, Boolean, Null, Undefined.\n- Kiểu phức tạp: Object, Array, Function.\n- JavaScript tự động nhận diện kiểu dữ liệu (Dynamic Typing).\n- Sử dụng typeof để kiểm tra kiểu của một biến trước khi thực hiện logic phức tạp',NULL,NULL,'2026-01-28 09:03:48'),(98,18,'theory',1,'Truthy và Falsy là gì?','Trong JavaScript, khi bạn đưa một giá trị không phải kiểu Boolean (như một con số, một chuỗi, hoặc một đối tượng) vào một ngữ cảnh cần Boolean (ví dụ như trong câu lệnh if), JavaScript sẽ tự động ép kiểu giá trị đó về true hoặc false.\n- Falsy: Là những giá trị khi chuyển đổi sang Boolean sẽ cho kết quả là false.\n- Truthy: Là tất cả những giá trị còn lại (khi chuyển sang Boolean sẽ cho kết quả là true).\n\nHiểu đơn giản: Falsy là những thứ mang tính chất \"không có gì\", \"trống rỗng\" hoặc \"sai lệch\".',NULL,NULL,'2026-01-28 09:07:24'),(99,18,'theory',1,'Danh sách 6 giá trị Falsy duy nhất','rong JavaScript, chỉ có duy nhất 6 giá trị sau đây được coi là Falsy. Bất cứ thứ gì nằm ngoài danh sách này đều là Truthy:\n- false: Chính nó là sai rồi.\n- 0: Số không (bao gồm cả -0).\n- \"\" (hoặc \'\'): Chuỗi rỗng (không có ký tự nào bên trong).\n- null: Giá trị rỗng có chủ đích.\n- undefined: Biến chưa được gán giá trị.\n- NaN: Not a Number (kết quả của phép toán sai)',NULL,NULL,'2026-01-28 09:07:58'),(100,18,'code',1,'Thế nào là Truthy?','console.log(Boolean(\" \"));      // true (Chuỗi có 1 dấu cách là Truthy!)\nconsole.log(Boolean(\"0\"));      // true (Chuỗi chứa số 0 là Truthy!)\nconsole.log(Boolean([]));       // true (Mảng rỗng là Truthy!)\nconsole.log(Boolean({}));       // true (Đối tượng rỗng là Truthy!)\nconsole.log(Boolean(function(){})); // true (Hàm rỗng là Truthy!)','javascript','Đây là những \"cú lừa\" kinh điển. Lưu ý lớn nhất là Mảng rỗng [] và Đối tượng rỗng {} luôn là Truthy. Nhiều người mới thường lầm tưởng chúng là Falsy vì chúng \"trống rỗng\", nhưng thực tế chúng vẫn là những thực thể tồn tại trong bộ nhớ.','2026-01-28 09:08:26'),(101,18,'code',1,'Ứng dụng để viết code ngắn gọn','let username = \"Hoàng\";\n\n// Cách viết dài:\nif (username !== \"\" && username !== null && username !== undefined) {\n    console.log(\"Chào mừng \" + username);\n}\n\n// Cách viết \"Sạch\" (Dựa vào Truthy):\nif (username) {\n    console.log(`Chào mừng ${username} (viết ngắn gọn)`);\n}','javascript','Vì chuỗi có nội dung là Truthy, nên if (username) sẽ trả về true. Nếu username là chuỗi rỗng \"\" (Falsy), đoạn mã bên trong sẽ không chạy. Cách viết này giúp code của bạn trông chuyên nghiệp và gọn gàng hơn rất nhiều.','2026-01-28 09:08:55'),(102,18,'code',1,'Mẹo nhỏ với toán tử !!','let msg = \"Hello\";\n\nconsole.log(!!msg); // true\nconsole.log(!!0);   // false','javascript','Toán tử ! đầu tiên sẽ chuyển giá trị thành Boolean và đảo ngược nó. Toán tử ! thứ hai sẽ đảo ngược lại một lần nữa. Kết quả là bạn nhận được giá trị Boolean chuẩn của bất kỳ biến nào.','2026-01-28 09:09:17'),(103,18,'theory',1,'Ghi nhớ nhanh','- Falsy (6 giá trị): false, 0, \"\", null, undefined, NaN.\n- Truthy: Mọi thứ khác (bao gồm cả mảng rỗng và đối tượng rỗng)\n- Tận dụng Truthy/Falsy trong câu lệnh if để code sạch đẹp hơn.',NULL,NULL,'2026-01-28 09:09:38'),(104,19,'theory',1,'Tại sao cần kết hợp Logical vào If?','Trong các bài trước, chúng ta chỉ kiểm tra một điều kiện đơn giản (ví dụ: if (a > b)). Tuy nhiên, thực tế yêu cầu nhiều hơn thế.\n\nHãy tưởng tượng logic của một website bán hàng: \"Nếu người dùng đã đăng nhập VÀ giỏ hàng không trống THÌ mới cho phép thanh toán\". Lúc này, câu lệnh if đơn thuần là không đủ, chúng ta cần các toán tử Logical để \"xâu chuỗi\" các điều kiện lại với nhau.',NULL,NULL,'2026-01-28 09:11:49'),(105,19,'code',1,'Sử dụng toán tử AND (&&) trong câu lệnh If','let email = \"admin@codepulse.vn\";\nlet password = \"123\";\n\n// Cần đúng cả email VÀ mật khẩu\nif (email === \"admin@codepulse.vn\" && password === \"123\") {\n    console.log(\"Đăng nhập thành công!\");\n} else {\n    console.log(\"Thông tin tài khoản không chính xác.\");\n}','javascript','JavaScript sẽ kiểm tra vế thứ nhất, sau đó đến vế thứ hai. Chỉ khi cả hai vế đều là true (Truthy), khối mã bên trong if mới được thực thi. Nếu một trong hai sai, nó sẽ nhảy xuống else.','2026-01-28 09:12:10'),(106,19,'code',1,'Sử dụng toán tử OR (||) trong câu lệnh If','let isVip = false;\nlet totalBill = 1000000; // 1 triệu đồng\n\n// Nếu là khách VIP HOẶC hóa đơn trên 500k thì được miễn phí giao hàng\nif (isVip || totalBill > 500000) {\n    console.log(\"Chúc mừng! Bạn được Free Ship.\");\n} else {\n    console.log(\"Phí giao hàng của bạn là 30.000đ.\");\n}','javascript','Toán tử || linh hoạt hơn. Chỉ cần bạn thỏa mãn một trong các tiêu chuẩn đặt ra, điều kiện tổng thể sẽ là true.','2026-01-28 09:12:29'),(107,19,'code',1,'Kết hợp nhiều toán tử (Phức hợp)','let age = 20;\nlet hasTicket = true;\nlet isWithParent = false;\n\n// Điều kiện vào xem phim 18+: (Đủ 18 tuổi VÀ có vé) HOẶC đi cùng bố mẹ\nif ((age >= 18 && hasTicket) || isWithParent) {\n    console.log(\"Mời bạn vào xem phim.\");\n} else {\n    console.log(\"Rất tiếc, bạn chưa đủ điều kiện.\");\n}','javascript','Lưu ý quan trọng: Chúng ta nên dùng cặp ngoặc đơn () để nhóm các điều kiện lại. Trong ví dụ này, JavaScript sẽ tính toán cụm (age >= 18 && hasTicket) trước, sau đó mới lấy kết quả đó để so sánh || với isWithParent.','2026-01-28 09:13:00'),(108,19,'theory',1,'Nguyên lý ngắt mạch (Short-circuit) trong If','Bạn cần nhớ rằng JavaScript kiểm tra các điều kiện từ trái sang phải:\n- Với &&: Nếu gặp một vế false, nó dừng lại ngay và kết luận là false (vì có kiểm tra tiếp cũng không thể đúng được).\n- Với ||: Nếu gặp một vế true, nó dừng lại ngay và kết luận là true.\n\nĐiều này giúp ứng dụng của bạn chạy nhanh hơn và tránh được các lỗi khi truy cập vào dữ liệu chưa tồn tại ở các vế phía sau.',NULL,NULL,'2026-01-28 09:13:30'),(109,19,'theory',1,'Quy tắc viết If-Logical chuyên nghiệp','1. Luôn dùng ngoặc đơn: Để phân tách rõ ràng các nhóm điều kiện, tránh lỗi thứ tự ưu tiên. \n2. Đừng viết quá dài: Nếu một câu lệnh if có quá 3-4 điều kiện, hãy cân nhắc tách chúng ra các biến trung gian để code dễ đọc hơn. \n3. Tận dụng Truthy/Falsy: Thay vì viết if (isLoggedIn === true), hãy viết ngắn gọn if (isLoggedIn).',NULL,NULL,'2026-01-28 09:13:53'),(110,20,'theory',1,'Định nghĩa về hàm trong lập trình','Trong lập trình, Hàm (Function) là một khối mã được thiết kế để thực hiện một nhiệm vụ cụ thể. Hãy tưởng tượng hàm giống như một \"chương trình con\" nằm bên trong chương trình lớn của bạn.\n\nHàm không tự chạy ngay khi bạn viết xong. Nó sẽ đứng chờ cho đến khi bạn \"gọi\" (invoke/call) nó thì nó mới thực thi các câu lệnh bên trong.\n\nĐể dễ hiểu, hãy coi hàm như một chiếc máy xay sinh tố:\n- Đầu vào (Input): Bạn bỏ trái cây, đường, sữa vào (trong code gọi là Tham số/Arguments).\n- Xử lý (Process): Chiếc máy thực hiện việc xay nhuyễn theo quy trình đã cài sẵn (trong code gọi là Thân hàm/Function Body).\n- Đầu ra (Output): Bạn nhận được một ly sinh tố ngon lành (trong code gọi là Giá trị trả về/Return value).',NULL,NULL,'2026-01-28 09:15:37'),(111,20,'code',1,'Cấu trúc cơ bản của một hàm','// 1. Khai báo hàm (Declaration)\nfunction showMessage() {\n    console.log(\"Chào mừng bạn đến với khóa học Hàm!\");\n    console.log(\"Chúc bạn học tập hiệu quả.\");\n}\n\n// 2. Gọi hàm để thực thi (Call/Invoke)\nshowMessage();\nshowMessage();','javascript','- function: Từ khóa bắt buộc để khai báo.\n- showMessage: Tên của hàm (nên đặt theo dạng động từ + danh từ).\n- () : Cặp ngoặc tròn nơi chứa các tham số (bài này tạm thời để trống).\n- {} : Cặp ngoặc nhọn chứa các câu lệnh bạn muốn thực hiện.\n- Khi bạn gọi showMessage() hai lần, đoạn code bên trong sẽ chạy lại đúng hai lần mà bạn không cần phải viết lại nội dung console.log.','2026-01-28 09:17:05'),(112,20,'theory',1,'Tại sao chúng ta cần sử dụng hàm?','Sử dụng hàm mang lại 3 lợi ích to lớn:\n- Tái sử dụng (Reusability): Viết một lần, dùng mãi mãi ở bất cứ đâu trong dự án.\n- Dễ bảo trì: Nếu bạn muốn thay đổi câu chào, bạn chỉ cần sửa ở duy nhất một nơi (trong thân hàm) thay vì phải đi tìm và sửa ở hàng chục chỗ khác nhau.\n- Code sạch sẽ hơn: Thay vì viết 100 dòng code phức tạp, bạn chia nhỏ nó thành 10 hàm, mỗi hàm thực hiện một việc. Điều này giúp mã nguồn cực kỳ dễ đọc.',NULL,NULL,'2026-01-28 09:17:31'),(113,20,'theory',1,'Phân biệt Khai báo và Thực thi','Đây là lỗi phổ biến nhất của người mới học:\n- showMessage: Đây là việc bạn đang nói về cái tên của hàm (nhưng nó không chạy).\n- showMessage(): Có thêm cặp ngoặc tròn nghĩa là bạn đang ra lệnh: \"Hàm ơi, chạy ngay đi!\".',NULL,NULL,'2026-01-28 09:17:52'),(114,20,'theory',1,'Tổng kết bài học','- Hàm là một khối mã dùng để thực hiện một nhiệm vụ.\n- Hàm giúp code ngắn gọn, dễ quản lý (DRY).\n- Cấu trúc: function name() { ... }.\n- Phải gọi hàm bằng tên kèm cặp ngoặc () thì code bên trong mới thực thi',NULL,NULL,'2026-01-28 09:18:15'),(115,21,'theory',1,'Khái niệm Tham số','Nếu coi hàm là một chiếc máy xay sinh tố, thì Tham số chính là các nguyên liệu bạn bỏ vào (trái cây, sữa, đá). Tùy vào nguyên liệu bạn bỏ vào là gì mà kết quả đầu ra sẽ khác nhau (sinh tố bơ hay sinh tố dâu).\n\nTrong lập trình, tham số là những biến được khai báo bên trong cặp ngoặc đơn () của hàm. Chúng đóng vai trò là những biến tạm chỉ tồn tại bên trong hàm đó để đại diện cho dữ liệu mà người dùng sẽ truyền vào.',NULL,NULL,'2026-01-28 09:19:14'),(116,21,'code',1,'Cách sử dụng tham số cơ bản','// \'name\' là tham số (parameter)\nfunction writeLog(message) {\n    console.log(\"Hệ thống thông báo: \" + message);\n}\n\n// \"Chào mừng bạn\" là đối số (argument)\nwriteLog(\"Chào mừng bạn đến với CodePulse!\");\nwriteLog(\"Bạn vừa đăng nhập thành công.\");','javascript','- message: Là tên biến đại diện (Tham số). Bạn có thể đặt tên bất kỳ.\n- Khi gọi writeLog(\"Chào mừng...\"), giá trị văn bản này sẽ được gán vào biến message và thực thi bên trong thân hàm.','2026-01-28 09:19:44'),(117,21,'theory',1,'Phân biệt Tham số (Parameter) và Đối số (Argument)','Tuy thường được dùng thay thế cho nhau, nhưng chúng có sự khác biệt về mặt kỹ thuật:\n- Tham số (Parameter): Là các tên biến được liệt kê khi bạn định nghĩa hàm (nằm trong ngoặc đơn ở dòng khai báo).\n- Đối số (Argument): Là giá trị thực tế mà bạn truyền vào hàm khi bạn gọi hàm đó để chạy.\n\n**Mẹo nhớ**: Tham số là \"vỏ hộp\" chờ sẵn, Đối số là \"món đồ\" bạn đặt vào trong hộp.',NULL,NULL,'2026-01-28 09:20:11'),(118,21,'code',1,'Hàm có nhiều tham số','function showInfor(firstName, lastName) {\n    console.log(`Họ và tên: ${firstName} ${lastName}`);\n}\n\n// Thứ tự truyền vào rất quan trọng\nshowInfor(\"Nguyễn\", \"Văn A\");\nshowInfor(\"Trần\", \"Thị B\");','javascript','Bạn có thể định nghĩa bao nhiêu tham số tùy thích, ngăn cách chúng bằng dấu phẩy ,. Khi gọi hàm, hãy chú ý truyền đối số đúng theo thứ tự mà bạn đã khai báo tham số để tránh việc \"râu ông nọ chắp cằm bà kia\".','2026-01-28 09:20:30'),(119,21,'theory',1,'Tính linh hoạt của tham số trong JavaScript','JavaScript rất \"dễ tính\" với tham số:\n- Không cần khai báo kiểu dữ liệu: Bạn có thể truyền vào chuỗi, số, mảng hay đối tượng đều được.\n- Số lượng không bắt buộc: Nếu bạn định nghĩa 2 tham số nhưng chỉ truyền 1 đối số, tham số còn lại sẽ tự động nhận giá trị là undefined\n- Tính riêng tư: Các tham số chỉ có ý nghĩa bên trong hàm. Bạn không thể gọi biến message ở bên ngoài hàm writeLog được (đây gọi là Scope - Phạm vi biến).',NULL,NULL,'2026-01-28 09:20:59'),(120,21,'theory',1,'Tổng kết bài học','- Tham số giúp hàm xử lý dữ liệu động.\n- Khai báo trong () khi định nghĩa hàm.\n- Truyền giá trị vào () khi gọi hàm.\n- Tên tham số nên có ý nghĩa rõ ràng (ví dụ: userName, productPrice).',NULL,NULL,'2026-01-28 09:21:29'),(121,22,'theory',1,'Return - Đưa kết quả ra ngoài hàm','Trong các bài trước, chúng ta thường dùng console.log() bên trong hàm để xem kết quả. Tuy nhiên, trong thực tế, chúng ta cần hàm thực hiện một phép tính và trả lại kết quả đó để chúng ta có thể tiếp tục sử dụng cho các việc khác (như tính toán tiếp hoặc lưu vào cơ sở dữ liệu).\n\nTừ khóa return có hai nhiệm vụ chính:\n- Trả về một giá trị cho nơi gọi hàm.\n- Dừng ngay lập tức việc thực thi hàm (thoát khỏi hàm)',NULL,NULL,'2026-01-28 09:22:23'),(122,22,'code',1,'Hàm tính tổng có kết quả trả về','function tinhTong(a, b) {\n    return a + b; // Trả về kết quả của a + b\n}\n\n// Lúc này, kết quả của hàm có thể được gán vào một biến\nlet tong = tinhTong(10, 20);\n\nconsole.log(\"Tổng là: \" + tong); // 30\nconsole.log(\"Tính tiếp với tổng:\", tong * 2); // 60','javascript','Lệnh return a + b giúp giá trị tổng \"thoát\" ra khỏi phạm vi của hàm. Nhờ đó, biến tong ở bên ngoài có thể hứng được giá trị này. Nếu không có return, biến tong sẽ nhận giá trị là undefined.','2026-01-28 09:22:50'),(123,22,'theory',1,'Tính chất Dừng thực thi của return','Ngay khi JavaScript gặp từ khóa return, nó sẽ thực hiện trả về giá trị (nếu có) và thoát khỏi hàm ngay lập tức. Mọi dòng code nằm dưới từ khóa return bên trong khối mã đó sẽ bị bỏ qua và không bao giờ được chạy.\n\nĐặc tính này thường được dùng để \"thoát sớm\" (Early Exit) khi gặp dữ liệu không hợp lệ, giúp code sạch sẽ hơn và tránh lồng ghép nhiều câu lệnh if...else.',NULL,NULL,'2026-01-28 09:23:11'),(124,22,'code',1,'Kiểm tra dữ liệu với return','function chiaHaiSo(a, b) {\n    if (b === 0) {\n        return \"Lỗi: Không thể chia cho số 0!\";\n    }\n\n    // Dòng này chỉ chạy nếu b khác 0\n    return a / b;\n}\n\nconsole.log(chiaHaiSo(10, 2)); // 5\nconsole.log(chiaHaiSo(10, 0)); // \"Lỗi: Không thể chia cho số 0!\"','javascript','Nếu b === 0, hàm gặp return đầu tiên và thoát ra ngay lập tức với thông báo lỗi. Dòng return a / b phía dưới sẽ không bao giờ bị đụng tới trong trường hợp này.','2026-01-28 09:23:31'),(125,22,'code',1,'Trả về các kiểu dữ liệu phức tạp','function taoUser(ten, tuoi) {\n    return {\n        name: ten,\n        age: tuoi,\n        role: \"Học viên\"\n    };\n}\n\nconst user1 = taoUser(\"Hoàng\", 20);\nconsole.log(user1.name); // \"Hoàng\"','javascript','Hàm không chỉ trả về số hay chuỗi, nó có thể trả về bất kỳ kiểu dữ liệu nào trong JavaScript, bao gồm cả Object (đối tượng) và Array (mảng). Điều này giúp bạn đóng gói dữ liệu cực kỳ mạnh mẽ.','2026-01-28 09:23:52'),(126,22,'theory',1,'Ghi nhớ quan trọng về return','- Hàm không có return sẽ mặc định trả về undefined.\n- return phải đi kèm với giá trị bạn muốn trả về trên cùng một dòng (hoặc dùng dấu ngoặc đơn nếu xuống dòng).\n- Sử dụng return để kết thúc hàm khi đã đạt được mục đích hoặc gặp lỗi.\n- Giá trị trả về có thể được dùng làm đối số cho một hàm khác.',NULL,NULL,'2026-01-28 09:24:20'),(127,23,'theory',1,'Tại sao có nhiều cách viết hàm?','Trong JavaScript, không chỉ có một cách duy nhất để định nghĩa một hàm. Tùy vào thời điểm ra đời (ES5 hay ES6+) và mục đích sử dụng (tính bao đóng, tính ngắn gọn), chúng ta có 3 loại hàm phổ biến nhất:\n- Declaration Function (Hàm khai báo).\n- Expression Function (Hàm biểu thức).\n- Arrow Function (Hàm mũi tên).\n\nViệc hiểu rõ sự khác biệt giữa chúng giúp bạn đọc hiểu code của người khác và chọn được cách viết tối ưu nhất cho bài toán của mình.',NULL,NULL,'2026-01-28 09:26:32'),(128,23,'code',1,'Cú pháp và đặc tính Hoisting','// Có thể gọi hàm TRƯỚC khi khai báo\nshowMessage(); \n\nfunction showMessage() {\n    console.log(\"Đây là Declaration Function\");\n}','javascript','Đây là cách viết cổ điển nhất. Đặc điểm quan trọng nhất của nó là Hoisting: Trình duyệt sẽ \"nhấc\" phần khai báo hàm lên đầu file trước khi thực thi code. Do đó, bạn có thể gọi hàm ở dòng 1 dù dòng 3 mới định nghĩa hàm.','2026-01-28 09:26:50'),(129,23,'code',1,'Expression Function (Hàm biểu thức)','// Không thể gọi trước khi khai báo (Sẽ lỗi)\nconst sayHello = function() {\n    console.log(\"Đây là Expression Function\");\n};\n\nsayHello();','javascript','Ở đây, chúng ta tạo ra một hàm không tên (Anonymous function) và gán nó vào một biến.\n- Không có Hoisting: Bạn buộc phải định nghĩa biến trước khi gọi.\n- Tên hàm: Tên của biến chính là tên để gọi hàm. Cách này giúp kiểm soát phạm vi của hàm tốt hơn.','2026-01-28 09:27:18'),(130,23,'code',1,'Arrow Function (Hàm mũi tên)','// 1. Cú pháp đầy đủ\nconst sum = (a, b) => {\n    return a + b;\n};\n\n// 2. Viết gọn nếu chỉ có 1 dòng return\nconst multiply = (a, b) => a * b;\n\n// 3. Viết gọn nếu chỉ có 1 tham số\nconst square = n => n * n;\n\nconsole.log(multiply(5, 2)); // 10','javascript','- Ra đời từ phiên bản ES6 (2015), Arrow Function sử dụng ký hiệu => (mũi tên).\n- Nếu thân hàm chỉ có một câu lệnh trả về giá trị, bạn có thể bỏ qua cặp ngoặc {} và từ khóa return.\n- Lưu ý: Arrow Function không có đối tượng this riêng, điều này rất quan trọng khi làm việc với Object (sẽ học ở chương sau).','2026-01-28 09:27:49'),(131,23,'theory',1,'So sánh nhanh các loại hàm','- Declaration: Có Hoisting, cú pháp rõ ràng, dùng cho các hàm quan trọng dùng chung.\n- Expression: Không Hoisting, dùng khi muốn giới hạn hàm trong một biến hoặc làm tham số cho hàm khác (Callback).\n- Arrow Function: Cú pháp ngắn nhất, không có this, được dùng nhiều nhất trong lập trình React/Vue hoặc xử lý mảng hiện đại.',NULL,NULL,'2026-01-28 09:28:10'),(133,25,'theory',1,'Định nghĩa về chuỗi (String)','Trong lập trình, Chuỗi (String) là một tập hợp các ký tự (chữ cái, chữ số, ký hiệu, khoảng trắng) được đặt bên trong các dấu bao quanh. Bạn có thể coi chuỗi như một sợi dây xâu chuỗi các hạt cườm lại với nhau, mỗi hạt là một ký tự.\n\nJavaScript rất linh hoạt, nó cho phép bạn tạo chuỗi bằng 3 cách:\n- Dấu nháy đơn (\'...\')\n- Dấu nháy kép (\"...\")\n- Dấu huyền - Template Literals (`...`)',NULL,NULL,'2026-01-28 09:31:50'),(134,25,'code',1,'Khai báo chuỗi trong JavaScript','// 1. Dùng nháy đơn hoặc nháy kép (Phổ biến)\nlet brand = \'CodePulse\';\nlet slogan = \"Học lập trình thực chiến\";\n\n// 2. Dùng dấu huyền - Backticks (Hiện đại)\nlet welcome = `Chào mừng bạn đến với ${brand}`;\n\nconsole.log(typeof brand); // \"string\"','javascript','- Cả nháy đơn và nháy kép đều có giá trị như nhau. Tuy nhiên, nếu bạn bắt đầu bằng nháy đơn thì phải kết thúc bằng nháy đơn.\n- Template Literals (dấu huyền) là cách mạnh mẽ nhất vì nó cho phép bạn đưa biến vào chuỗi dễ dàng bằng cú pháp ${}.','2026-01-28 09:32:15'),(135,25,'theory',1,'Ký tự đặc biệt và Escape Character','Sẽ ra sao nếu bạn muốn viết một chuỗi có chứa dấu nháy bên trong? Ví dụ: I\'m a developer. Nếu bạn dùng nháy đơn bao quanh, JavaScript sẽ bị nhầm lẫn.\n\nĐể giải quyết, chúng ta dùng dấu gạch chéo ngược \\ (Escape character) để \"bảo vệ\" ký tự phía sau nó:\n- \\\': Dấu nháy đơn.\n- \\\": Dấu nháy kép.\n- \\\\: Dấu gạch chéo ngược.\n- \\n: Xuống dòng mới (New line).',NULL,NULL,'2026-01-28 09:32:40'),(136,25,'code',1,'Viết chuỗi phức tạp','// Sử dụng dấu gạch chéo để tránh lỗi cú pháp\nlet text1 = \'I\\\'m a \"JavaScript\" developer\';\n\n// Xuống dòng bên trong một chuỗi\nlet longText = \"Dòng một\\nDòng hai\";\n\nconsole.log(text1);\nconsole.log(longText);','javascript','Dấu \\ nói với JavaScript rằng: \"Này, cái dấu nháy phía sau tôi chỉ là văn bản thôi, đừng coi nó là lệnh kết thúc chuỗi nhé!\".','2026-01-28 09:33:04'),(137,25,'theory',1,'Thuộc tính độ dài của chuỗi (Length)','Mỗi chuỗi trong JavaScript đều có một thuộc tính đi kèm là length. Nó cho bạn biết chính xác có bao nhiêu ký tự bên trong chuỗi đó (bao gồm cả khoảng trắng và các ký hiệu).\n\nĐây là thuộc tính cực kỳ hữu ích khi bạn cần kiểm tra xem người dùng có nhập mật khẩu quá ngắn hay không, hoặc giới hạn số ký tự của một bài viết.',NULL,NULL,'2026-01-28 09:33:16'),(138,25,'code',1,'','let email = \"contact@codepulse.vn\";\nlet password = \"123\";\n\nconsole.log(\"Độ dài email:\", email.length); // 20\n\nif (password.length < 6) {\n    console.log(\"Cảnh báo: Mật khẩu quá ngắn!\");\n}','javascript','length là một thuộc tính (property), không phải là hàm, nên bạn không cần thêm cặp ngoặc tròn () phía sau nó. Nó sẽ trả về một con số nguyên.','2026-01-28 09:33:37'),(139,26,'code',1,'Các phương thức tìm kiếm chuỗi','let string = \"Học lập trình JS tại CodePulse JS\";\n\n// 1. indexOf(): Tìm vị trí đầu tiên của chuỗi con\nconsole.log(string.indexOf(\"JS\")); // 15\n\n// 2. lastIndexOf(): Tìm vị trí cuối cùng\nconsole.log(string.lastIndexOf(\"JS\")); // 31\n\n// 3. includes(): Kiểm tra xem chuỗi có tồn tại không (trả về true/false)\nconsole.log(string.includes(\"JS\")); // true','javascript','Chỉ số (index) trong chuỗi luôn bắt đầu từ 0. Nếu phương thức indexOf không tìm thấy kết quả, nó sẽ trả về -1. Đây là cách phổ biến nhất để kiểm tra sự tồn tại của một từ trong đoạn văn.','2026-01-28 09:35:20'),(140,26,'theory',1,'Các phương thức cắt chuỗi (Extracting)','Để lấy ra một đoạn văn bản nhỏ từ một chuỗi lớn, JavaScript cung cấp 3 phương thức chính:\n- slice(start, end): Cắt từ vị trí start đến end (không bao gồm end). Điểm mạnh là nó có thể nhận số âm để cắt từ cuối chuỗi ngược lên.\n- substring(start, end): Tương tự slice nhưng không chấp nhận số âm.\n- substr(start, length): Cắt từ vị trí start và lấy ra một số lượng ký tự (length) nhất định.',NULL,NULL,'2026-01-28 09:35:42'),(141,26,'code',1,'Sử dụng slice() để lấy dữ liệ','let text = \"JavaScript is awesome\";\n\n// Cắt từ vị trí 0 đến 10\nconsole.log(text.slice(0, 10)); // \"JavaScript\"\n\n// Cắt từ vị trí 14 đến hết\nconsole.log(text.slice(14));    // \"awesome\"\n\n// Dùng số âm để lấy 7 ký tự cuối cùng\nconsole.log(text.slice(-7));    // \"awesome\"','javascript','slice() là phương thức hiện đại và linh hoạt nhất. Khi bạn truyền một tham số, nó sẽ cắt từ đó đến hết chuỗi. Khi dùng số âm, ví dụ -1 là ký tự cuối cùng, -2 là kế cuối.','2026-01-28 09:36:07'),(142,26,'code',1,'Thay thế và Chuyển đổi hoa thường - replace(), toUpperCase() và toLowerCase()','let title = \"Học JavaScript tại CodePulse\";\n\n// 1. Thay thế chuỗi\nconsole.log(title.replace(\"JavaScript\", \"JS\"));\n\n// 2. Chuyển thành chữ HOA\nconsole.log(title.toUpperCase()); // \"HỌC JAVASCRIPT TẠI CODEPULSE\"\n\n// 3. Chuyển thành chữ thường\nconsole.log(title.toLowerCase()); // \"học javascript tại codepulse\"','javascript','Lưu ý rằng phương thức replace() mặc định chỉ thay thế từ đầu tiên nó tìm thấy. Ngoài ra, các phương thức này không làm thay đổi chuỗi gốc mà trả về một chuỗi mới hoàn toàn.','2026-01-28 09:36:28'),(143,26,'code',1,'Làm sạch và Phân tách chuỗi - trim() và split()','// 1. trim(): Loại bỏ khoảng trắng thừa ở 2 đầu\nlet email = \"   contact@codepulse.vn   \";\nconsole.log(email.trim()); // \"contact@codepulse.vn\"\n\n// 2. split(): Cắt chuỗi thành Mảng (Array) dựa vào điểm chung\nlet languages = \"JS, PHP, Java, Python\";\nlet arr = languages.split(\", \");\nconsole.log(arr); // [\"JS\", \"PHP\", \"Java\", \"Python\"]','javascript','- trim() cực kỳ hữu ích khi xử lý dữ liệu nhập từ Form để tránh lỗi thừa dấu cách.\n- split() là \"cầu nối\" quan trọng để chuyển dữ liệu từ kiểu Chuỗi sang kiểu Mảng giúp việc xử lý dữ liệu lớn trở nên dễ dàng hơn.','2026-01-28 09:37:24'),(144,26,'theory',1,'Lấy ký tự theo vị trí','Để lấy ra một ký tự duy nhất tại một vị trí cụ thể, bạn có 2 cách:\n- charAt(index): Trả về ký tự tại vị trí đó.\n- Sử dụng cặp ngoặc vuông []: string[index]. Đây là cách viết hiện đại, giống như truy cập phần tử trong mảng.\nVí dụ: Với chuỗi let s = \"ABC\", thì s[0] sẽ trả về \"A\".',NULL,NULL,'2026-01-28 09:37:45'),(145,27,'theory',1,'Đặc điểm của kiểu Số trong JavaScript','Khác với nhiều ngôn ngữ lập trình khác (phân chia rạch ròi giữa số nguyên int và số thực float), JavaScript chỉ có duy nhất một kiểu số gọi là Number.\n\nTất cả các con số, dù là số nguyên ($10$) hay số thập phân ($10.5$), đều được lưu trữ dưới dạng số thực dấu phẩy động 64-bit (IEEE 754). Điều này giúp JS linh hoạt nhưng cũng đôi khi gây ra những sai số nhỏ khi tính toán số thập phân mà bạn cần lưu ý.',NULL,NULL,'2026-01-28 09:40:21'),(146,27,'code',1,'Cách tạo dữ liệu kiểu Số','// 1. Cách thông thường (Literal) - Khuyên dùng\nlet age = 25;\nlet price = 99.99;\n\n// 2. Cách dùng đối tượng Number (Object) - Ít dùng\nlet count = new Number(10); \n\nconsole.log(typeof age);   // \"number\"\nconsole.log(typeof count); // \"object\"','javascript','Hãy luôn sử dụng cách khai báo thông thường. Việc sử dụng new Number() sẽ tạo ra một đối tượng, điều này làm chậm tốc độ xử lý và gây rắc rối khi so sánh bằng toán tử ===.','2026-01-28 09:40:37'),(147,27,'code',1,'Làm việc với phương thức toFixed()','let pi = 3.14159265;\n\n// Làm tròn lấy 2 chữ số sau dấu phẩy\nconsole.log(pi.toFixed(2)); // \"3.14\"\n\n// Làm tròn lấy 0 chữ số (thành số nguyên)\nconsole.log(pi.toFixed(0)); // \"3\"\n\nlet balance = 12.5;\nconsole.log(balance.toFixed(2)); // \"12.50\"','javascript','- toFixed() là phương thức cực kỳ quan trọng khi làm web bán hàng hoặc tài chính.\n- Lưu ý cực lớn: toFixed() trả về kết quả là một Chuỗi (String). Nếu bạn muốn tiếp tục tính toán, hãy chuyển nó ngược lại thành Số.','2026-01-28 09:40:59'),(148,27,'code',1,'Chuyển đổi sang chuỗi với toString()','let myNumber = 100;\n\nlet myString = myNumber.toString();\n\nconsole.log(typeof myString); // \"string\"\nconsole.log((15).toString()); // \"15\"','javascript','Phương thức này hữu ích khi bạn cần nối số vào một chuỗi văn bản hoặc khi cần sử dụng các phương thức của Chuỗi (như .length) trên một con số.','2026-01-28 09:41:17'),(149,27,'theory',1,'Kiểm tra số với Number.isInteger() và Number.isNaN()','Để đảm bảo chương trình không bị lỗi \"vớ vẩn\", chúng ta cần kiểm tra dữ liệu:\n- Number.isInteger(value): Trả về true nếu giá trị là số nguyên, false nếu là số thập phân hoặc kiểu dữ liệu khác.\n- Number.isNaN(value): Kiểm tra xem một giá trị có phải là \"Không phải là số\" (NaN) hay không. Đây là cách an toàn nhất để kiểm tra kết quả của các phép tính bị lỗi (ví dụ: \"abc\" / 2).',NULL,NULL,'2026-01-28 09:41:39'),(150,27,'code',1,'','console.log(Number.isInteger(20));    // true\nconsole.log(Number.isInteger(20.5));  // false\n\nlet result = \"Hello\" / 5; \nconsole.log(result); // NaN\nconsole.log(Number.isNaN(result));    // true','javascript','Luôn sử dụng Number.isInteger() trước khi thực hiện các logic chỉ dành cho số nguyên (như kiểm tra số dư % hoặc chạy vòng lặp).','2026-01-28 09:42:03'),(151,27,'theory',1,'Tổng kết','- JavaScript chỉ có một kiểu số duy nhất (Number).\n- toFixed() dùng để làm tròn nhưng trả về Chuỗi.\n- toString() để biến số thành chữ.\n- Number.isInteger() giúp kiểm tra số nguyên cực kỳ chính xác.',NULL,NULL,'2026-01-28 09:42:25'),(152,28,'theory',1,'Khái niệm về danh sách dữ liệu','Trong lập trình, Mảng (Array) là một kiểu dữ liệu dùng để lưu trữ một danh sách các giá trị. Thay vì phải khai báo 10 biến khác nhau để lưu tên của 10 học sinh, bạn chỉ cần một mảng duy nhất mang tên students.\n\nMảng giúp tối ưu hóa mã nguồn, dễ dàng quản lý và thực hiện các thao tác hàng loạt như tìm kiếm, sắp xếp hoặc lọc dữ liệu. Mỗi giá trị trong mảng được gọi là một phần tử (element).',NULL,NULL,'2026-01-28 14:10:05'),(153,28,'code',1,'Cách tạo mảng trong JavaScript','// 1. Cách phổ biến nhất (Sử dụng Array Literal)\nlet languages = [\'JavaScript\', \'PHP\', \'Ruby\', \'Python\'];\n\n// 2. Cách dùng từ khóa \'new\' (Sử dụng Array Constructor)\nlet colors = new Array(\'Red\', \'Green\', \'Blue\');\n\nconsole.log(languages);\nconsole.log(typeof languages); // \"object\"','javascript','- Cách sử dụng cặp ngoặc vuông [] luôn được khuyên dùng vì tính ngắn gọn và tốc độ xử lý nhanh hơn.\n- Lưu ý: Trong JavaScript, khi bạn kiểm tra typeof của một mảng, kết quả trả về sẽ là \"object\".','2026-01-28 14:10:38'),(154,28,'theory',1,'Chỉ số (Index) và Truy xuất phần tử','Mỗi phần tử trong mảng được gắn với một con số để định vị, gọi là Chỉ số (Index).\n\nQuy tắc quan trọng nhất: Chỉ số của mảng bắt đầu từ 0, không phải từ 1.\n- Phần tử thứ nhất có index là 0.\n- Phần tử thứ hai có index là 1.\n- Phần tử cuối cùng có index là tổng số phần tử - 1.',NULL,NULL,'2026-01-28 14:11:17'),(155,28,'code',1,'','let cars = [\'Toyota\', \'BMW\', \'Honda\'];\n\n// 1. Lấy giá trị của phần tử\nconsole.log(cars[0]); // \"Toyota\"\nconsole.log(cars[1]); // \"BMW\"\n\n// 2. Thay đổi giá trị của phần tử\ncars[2] = \'Mazda\'; \nconsole.log(cars); // [\"Toyota\", \"BMW\", \"Mazda\"]','javascript','Để truy cập hoặc thay đổi một phần tử, bạn dùng tên_mảng[chỉ_số]. Nếu bạn truy cập vào một chỉ số không tồn tại (ví dụ cars[10]), JavaScript sẽ trả về giá trị undefined.','2026-01-28 14:11:40'),(156,28,'code',1,'Thuộc tính độ dài (length)','let fruits = [\'Táo\', \'Cam\', \'Xoài\', \'Mận\'];\n\nconsole.log(fruits.length); // 4\n\n// Mẹo: Lấy phần tử cuối cùng của mảng\nconsole.log(fruits[fruits.length - 1]); // \"Mận\"','javascript','Giống như chuỗi, mảng có thuộc tính .length để cho biết tổng số phần tử đang có. Đây là công cụ cực kỳ quan trọng để bạn chạy các vòng lặp qua mảng ở các bài sau.','2026-01-28 14:12:02'),(157,28,'theory',1,'Đặc tính linh hoạt của mảng JavaScript','Một mảng trong JavaScript rất \"tự do\":\n- Không giới hạn kiểu dữ liệu: Bạn có thể để số, chuỗi, boolean, thậm chí là một mảng khác hoặc một hàm vào trong cùng một mảng.\n- Kích thước động: Bạn không cần khai báo trước mảng sẽ có bao nhiêu phần tử, mảng sẽ tự co giãn khi bạn thêm hoặc xóa dữ liệu.',NULL,NULL,'2026-01-28 14:12:30'),(158,29,'code',1,'Chuyển đổi mảng sang chuỗi toString() và join()','let languages = [\'JavaScript\', \'PHP\', \'Ruby\'];\n\n// 1. toString(): Chuyển mảng thành chuỗi, ngăn cách bằng dấu phẩy\nconsole.log(languages.toString()); // \"JavaScript,PHP,Ruby\"\n\n// 2. join(): Tương tự toString nhưng bạn có thể chọn ký tự ngăn cách\nconsole.log(languages.join(\' - \')); // \"JavaScript - PHP - Ruby\"\nconsole.log(languages.join(\'\'));    // \"JavaScriptPHPRuby\"','javascript','join() là phiên bản nâng cấp của toString(). Nó rất hữu ích khi bạn muốn hiển thị danh sách sản phẩm ngăn cách bởi dấu gạch đứng | hoặc dấu xuống dòng','2026-01-28 14:15:43'),(159,29,'theory',1,'Thao tác với phần tử ở hai đầu mảng: Pop, Push, Shift và Unshift','Đây là 4 phương thức cơ bản nhất để thay đổi kích thước mảng:\n- pop(): Xóa phần tử cuối cùng và trả về chính phần tử đó.\n- push(): Thêm một hoặc nhiều phần tử vào cuối mảng và trả về độ dài mới.\n- shift(): Xóa phần tử đầu tiên và trả về phần tử đó (làm các phần tử sau bị đẩy lên).\n- unshift(): Thêm một hoặc nhiều phần tử vào đầu mảng và trả về độ dài mới.',NULL,NULL,'2026-01-28 14:16:19'),(160,29,'code',1,'','let fruits = [\'Táo\', \'Cam\'];\n\nfruits.push(\'Xoài\');    // [\'Táo\', \'Cam\', \'Xoài\']\nfruits.pop();           // [\'Táo\', \'Cam\'] (Xoài bị xóa)\n\nfruits.shift();         // [\'Cam\'] (Táo bị xóa)\nfruits.unshift(\'Nho\');  // [\'Nho\', \'Cam\']','javascript','Hãy nhớ: Push/Pop làm việc ở phía cuối (nhanh hơn), còn Shift/Unshift làm việc ở phía đầu (chậm hơn một chút vì phải đánh lại chỉ số cho toàn bộ mảng)','2026-01-28 14:16:37'),(161,29,'theory',1,'Splice()','splice() là phương thức mạnh mẽ nhất. Cú pháp: array.splice(vị_trí_bắt_đầu, số_lượng_xóa, các_phần_tử_thêm_vào)\n- Nếu bạn chỉ muốn xóa: fruits.splice(1, 1) (Xóa 1 phần tử tại vị trí 1).\n- Nếu bạn muốn chèn: fruits.splice(1, 0, \'Mận\') (Chèn \'Mận\' vào vị trí 1 mà không xóa gì).\n- Nếu bạn muốn thay thế: fruits.splice(1, 1, \'Dâu\') (Xóa 1 cái tại vị trí 1 và đặt \'Dâu\' vào đó).',NULL,NULL,'2026-01-28 14:17:10'),(162,29,'code',1,'Nối và Cắt mảng (Concat & Slice)','let arr1 = [\'JS\', \'PHP\'];\nlet arr2 = [\'Java\', \'Dart\'];\n\n// 1. concat(): Nối các mảng lại với nhau\nlet total = arr1.concat(arr2); // [\'JS\', \'PHP\', \'Java\', \'Dart\']\n\n// 2. slice(): Cắt một phần của mảng (không làm hỏng mảng gốc)\nlet subArr = total.slice(1, 3); // [\'PHP\', \'Java\']','javascript','Khác với các phương thức trên, concat() và slice() không làm thay đổi mảng ban đầu mà trả về một mảng mới. slice(0) cũng là một cách rất hay để sao chép (clone) một mảng.','2026-01-28 14:17:29'),(163,29,'theory',1,'Bảng ghi nhớ nhanh các phương thức','- Chuyển sang chuỗi: toString, join.\n- Xử lý cuối mảng: push (thêm), pop (xóa).\n- Xử lý đầu mảng: unshift (thêm), shift (xóa).\n- Đa năng: splice.\n- Nối mảng: concat.\n- Cắt/Sao chép: slice.',NULL,NULL,'2026-01-28 14:17:59'),(164,30,'theory',1,'Object - Cách máy tính nhìn nhận thực tế','Trong thực tế, một vật thể không chỉ là một giá trị đơn lẻ. Ví dụ: Một chiếc điện thoại không chỉ là \"iPhone\", nó còn có màu sắc, dung lượng pin, giá tiền...\n\nObject trong JavaScript là một kiểu dữ liệu dùng để lưu trữ các thông tin này dưới dạng các cặp Key: Value (Khóa: Giá trị).\n- Key (Khóa): Tên của đặc điểm (ví dụ: color).\n- Value (Giá trị): Nội dung của đặc điểm đó (ví dụ: Black).',NULL,NULL,'2026-01-28 14:19:42'),(165,30,'theory',1,'Khi nào dùng Array, khi nào dùng Object?','Mảng (Array): Dùng khi bạn có một danh sách các món đồ cùng loại và quan tâm đến thứ tự (ví dụ: danh sách tên học sinh).\n\nĐối tượng (Object): Dùng khi bạn muốn mô tả chi tiết về một đối tượng cụ thể và muốn truy cập thông qua tên gọi thay vì số thứ tự.',NULL,NULL,'2026-01-28 14:20:21'),(166,30,'code',1,'Cách tạo Object (Object Literal)','// Tạo một đối tượng mô tả sinh viên\nlet student = {\n    name: \"Nguyễn Văn A\",\n    age: 20,\n    address: \"Hà Nội\",\n    isVip: true\n};\n\nconsole.log(student);','javascript','Chúng ta sử dụng cặp ngoặc nhọn {}. Mỗi cặp key-value được ngăn cách bởi dấu phẩy ,. Key và Value được ngăn cách bởi dấu hai chấm :. Đây là cách khai báo phổ biến và trực quan nhất.','2026-01-28 14:20:56'),(167,30,'theory',1,'Thuộc tính (Property) và Phương thức (Method)','1. Thuộc tính (Property): Là những thông tin, đặc điểm của đối tượng (như name, age ở ví dụ trên). \n2. Phương thức (Method): Khi một giá trị trong Object là một hàm (function), ta gọi đó là phương thức. Nó mô tả hành động mà đối tượng đó có thể thực hiện.',NULL,NULL,'2026-01-28 14:21:22'),(168,30,'code',1,'Cách truy cập dữ liệu trong Object - Dot notation và Bracket notation','let car = {\n    brand: \"VinFast\",\n    model: \"VF8\"\n};\n\n// 1. Sử dụng dấu chấm (.) - Phổ biến nhất\nconsole.log(car.brand); // \"VinFast\"\n\n// 2. Sử dụng ngoặc vuông [] - Dùng khi key là một biến\nlet keyName = \"model\";\nconsole.log(car[keyName]); // \"VF8\"','javascript','Dấu chấm . giúp code trông sạch sẽ và dễ đọc. Tuy nhiên, ngoặc vuông [] lại cực kỳ mạnh mẽ khi bạn muốn lấy dữ liệu một cách linh hoạt thông qua một biến số hoặc khi key có chứa ký tự đặc biệt/khoảng trắng.','2026-01-28 14:21:57'),(169,30,'code',1,'Thêm và thay đổi thuộc tính','let user = { name: \"Hoàng\" };\n\n// Thêm thuộc tính mới\nuser.email = \"hoang@gmail.com\";\n\n// Thay đổi giá trị cũ\nuser.name = \"Hoàng Pro\";\n\n// Xóa thuộc tính\ndelete user.email;\n\nconsole.log(user);','javascript','Bạn không cần phải định nghĩa tất cả ngay từ đầu. JavaScript cho phép bạn \"đắp\" thêm thịt vào khung xương của Object bất cứ lúc nào bằng phép gán đơn giản.','2026-01-28 14:22:36'),(170,31,'theory',1,'Object constructor là gì?','Object constructor thực chất là một hàm (function). Nó đóng vai trò như một cái khuôn mẫu để từ đó bạn có thể đúc ra nhiều đối tượng khác nhau có cùng cấu trúc nhưng giá trị dữ liệu khác nhau.\n\nHãy tưởng tượng Object constructor là một chiếc khuôn làm bánh, và các Object được tạo ra chính là những chiếc bánh. Bạn chỉ cần tạo khuôn một lần, và có thể làm ra vô số chiếc bánh từ cái khuôn đó.',NULL,NULL,'2026-01-28 14:23:33'),(171,31,'code',1,'Khai báo hàm tạo với từ khóa this','function User(firstName, lastName, avatar) {\n    this.firstName = firstName;\n    this.lastName = lastName;\n    this.avatar = avatar;\n\n    this.getName = function() {\n        return `${this.firstName} ${this.lastName}`;\n    };\n}','javascript','- Tên hàm: Theo quy ước, tên hàm constructor thường được viết hoa chữ cái đầu (ví dụ: User thay vì user) để phân biệt với hàm thông thường.\n- Từ khóa this: Đại diện cho đối tượng mà bạn chuẩn bị tạo ra. Nó giúp gán giá trị từ tham số vào thuộc tính của đối tượng đó.','2026-01-28 14:24:12'),(172,31,'code',1,'Tạo đối tượng từ Constructor với từ khóa new','// Tạo đối tượng cụ thể (instance)\nconst author = new User(\'Sơn\', \'Đặng\', \'Avatar 1\');\nconst student = new User(\'Hoàng\', \'Trần\', \'Avatar 2\');\n\nconsole.log(author.getName());  // \"Sơn Đặng\"\nconsole.log(student.getName()); // \"Hoàng Trần\"','javascript','Khi bạn dùng từ khóa new đứng trước hàm tạo, JavaScript sẽ thực hiện 3 bước ngầm định\n- Tạo ra một đối tượng rỗng {}.\n- Gán các giá trị thông qua từ khóa this.\n- Trả về đối tượng vừa tạo đó. Nếu thiếu từ khóa new, hàm sẽ không hoạt động như một constructor và có thể gây lỗi.','2026-01-28 14:25:00'),(173,31,'theory',1,'Thêm thuộc tính riêng cho từng đối tượng','Sau khi được tạo ra từ constructor, mỗi đối tượng là một thực thể độc lập. Bạn hoàn toàn có thể thêm các thuộc tính hoặc phương thức riêng cho một đối tượng cụ thể mà không làm ảnh hưởng đến các đối tượng khác cùng \"khuôn\".\n\nVí dụ: Bạn có thể thêm author.title = \'Admin\', nhưng đối tượng student sẽ không có thuộc tính title này.',NULL,NULL,'2026-01-28 14:30:01'),(174,31,'code',1,'','const admin = new User(\'Admin\', \'Vip\', \'Avatar Admin\');\n\n// Thêm thuộc tính riêng cho admin\nadmin.role = \'Super Admin\';\n\n// Thêm phương thức riêng cho admin\nadmin.deleteUser = function() {\n    console.log(\"Đã xóa người dùng!\");\n};\n\nconsole.log(admin.role); // \"Super Admin\"\n// student.deleteUser(); // Lỗi! student không có hàm này.','javascript','Điều này cho thấy tính kế thừa và tùy biến cực mạnh của JavaScript. Constructor tạo ra cái \"khung\", còn việc trang trí thêm gì là quyền của bạn đối với từng thực thể.','2026-01-28 14:30:21'),(175,31,'theory',1,'Những điều cần nhớ về Constructor','- Constructor là bản thiết kế chung để tạo nhiều đối tượng\n- Viết hoa chữ cái đầu của tên hàm tạo để phân biệt.\n- Luôn sử dụng từ khóa new để khởi tạo đối tượng.\n- Sử dụng this để định nghĩa thuộc tính và phương thức trong bản thiết kế.',NULL,NULL,'2026-01-28 14:30:45'),(176,32,'theory',1,'Object prototype là gì?','Trong JavaScript, mỗi hàm tạo (constructor) đều có một thuộc tính đi kèm gọi là prototype. Bạn có thể coi đây là một kho lưu trữ chung.\n\nTất cả các đối tượng được tạo ra từ cùng một constructor đều có quyền truy cập và sử dụng những gì bạn cất trong \"kho\" này mà không cần phải tự mình sở hữu một bản sao riêng.',NULL,NULL,'2026-01-28 14:31:50'),(177,32,'theory',1,'Tại sao phải dùng Prototype?','Hãy tưởng tượng bạn tạo ra 1.000 đối tượng User. Nếu bạn định nghĩa phương thức getClassName trực tiếp trong constructor, JavaScript sẽ tạo ra 1.000 bản sao của hàm đó trong bộ nhớ.\n\nNhưng nếu bạn đưa hàm đó vào prototype, chỉ có duy nhất 1 bản sao được tạo ra. Cả 1.000 đối tượng kia sẽ chỉ trỏ (reference) về dùng chung bản sao đó. Điều này giúp ứng dụng của bạn chạy mượt mà hơn rất nhiều.',NULL,NULL,'2026-01-28 14:32:04'),(178,32,'code',1,'Sử dụng cú pháp .prototype','function Student(firstName, lastName) {\n    this.firstName = firstName;\n    this.lastName = lastName;\n}\n\n// 1. Thêm thuộc tính vào Prototype\nStudent.prototype.school = \"Đại học Bách Khoa\";\n\n// 2. Thêm phương thức vào Prototype\nStudent.prototype.getFullName = function() {\n    return `${this.firstName} ${this.lastName}`;\n};\n\nconst sv1 = new Student(\'Hoàng\', \'Trần\');\nconst sv2 = new Student(\'Sơn\', \'Đặng\');\n\nconsole.log(sv1.school);      // \"Đại học Bách Khoa\"\nconsole.log(sv2.getFullName()); // \"Sơn Đặng\"','javascript','Mặc dù chúng ta không khai báo school hay getFullName bên trong hàm Student, nhưng sv1 và sv2 vẫn sử dụng được. JavaScript sẽ tự tìm trong đối tượng, nếu không thấy, nó sẽ \"mò\" lên prototype để tìm.','2026-01-28 14:32:27'),(179,32,'theory',1,'Prototype Chain (Chuỗi nguyên mẫu)','Khi bạn truy cập một thuộc tính của đối tượng, JavaScript sẽ thực hiện theo các bước:\n- Tìm trong chính đối tượng đó. Nếu thấy, dùng luôn.\n- Nếu không thấy, tìm trong Prototype của nó.\n- Nếu vẫn không thấy, tìm tiếp trong Prototype của lớp cha (cứ thế đi lên cho đến khi gặp Object.prototype).\n- Nếu đến cuối cùng vẫn không thấy, kết quả trả về là undefined.\nCơ chế này được gọi là Prototype Chain.',NULL,NULL,'2026-01-28 14:32:52'),(180,32,'theory',1,'Điểm khác biệt giữa thuộc tính trực tiếp và Prototype','Khi bạn console.log một đối tượng, các thuộc tính trong Prototype sẽ không hiện ra trực tiếp mà nằm ẩn trong mục [[Prototype]] (hoặc __proto__ trên trình duyệt).\n\nBạn chỉ nên đưa các thông tin/hành động dùng chung cho mọi đối tượng vào Prototype. Những thông tin riêng biệt (như tên, tuổi, email) thì vẫn phải để trong Constructor.',NULL,NULL,'2026-01-28 14:33:14'),(181,32,'theory',1,'Ghi nhớ về Prototype','- Prototype giúp định nghĩa các thuộc tính/phương thức dùng chung.\n- Tiết kiệm bộ nhớ cho ứng dụng.\n- Là nền tảng để JavaScript thực hiện việc kế thừa (Inheritance).\n- Cú pháp: ConstructorName.prototype.tenThuocTinh = giaTri;',NULL,NULL,'2026-01-28 14:34:07'),(182,33,'theory',1,'Khởi tạo và lưu ý về mốc thời gian','Để làm việc với ngày giờ, chúng ta cần khởi tạo đối tượng Date bằng từ khóa new.\n**Lưu ý** \"hại não\" nhất: Trong JavaScript, tháng (Month) được tính từ 0 đến 11. Nghĩa là tháng 1 là 0 và tháng 12 là 11. Ngược lại, ngày (Date) vẫn tính từ 1 đến 31.',NULL,NULL,'2026-01-28 14:36:40'),(183,33,'code',1,'','const now = new Date(); // Lấy thời gian hiện tại (Năm 2026)\n\nconst year = now.getFullYear();   // 2026\nconst month = now.getMonth() + 1; // Cộng 1 để ra đúng tháng thực tế\nconst date = now.getDate();       // Ngày trong tháng\nconst day = now.getDay();         // Thứ trong tuần (0: CN, 1: Thứ 2...)\n\nconsole.log(`${date}/${month}/${year}`); // Ví dụ: 28/1/2026','javascript','','2026-01-28 14:36:55'),(184,33,'theory',1,'Đối tượng Math (Làm việc với toán học)','Khác với Date, bạn không bao giờ dùng new Math(). Bạn có thể truy cập trực tiếp các thuộc tính và phương thức của nó ngay lập tức. Đây là \"hộp dụng cụ\" chứa các hằng số toán học và các hàm xử lý số.',NULL,NULL,'2026-01-28 14:37:10'),(185,33,'code',1,'','// 1. Số Pi\nconsole.log(Math.PI); // 3.141592653589793\n\n// 2. Làm tròn số\nconsole.log(Math.round(4.6)); // 5 (Làm tròn chuẩn)\nconsole.log(Math.ceil(4.1));  // 5 (Luôn làm tròn lên - \"Trần\")\nconsole.log(Math.floor(4.9)); // 4 (Luôn làm tròn xuống - \"Sàn\")\n\n// 3. Trị tuyệt đối\nconsole.log(Math.abs(-10));   // 10\n\n// 4. Tìm Min/Max\nconsole.log(Math.max(10, 20, 5, 100)); // 100','javascript','','2026-01-28 14:37:24'),(186,33,'code',1,'Ứng dụng Math.random() để tạo số ngẫu nhiên','// Math.random() trả về số thập phân từ 0 đến sát 1\nlet random = Math.random(); \n\n// Ví dụ: Tạo số ngẫu nhiên từ 0 đến 9\nlet luckyNumber = Math.floor(Math.random() * 10);\nconsole.log(\"Số may mắn của bạn là:\", luckyNumber);','javascript','Đây là kỹ thuật cực kỳ hay dùng để làm các chức năng như: quay số trúng thưởng, lấy ngẫu nhiên một phần tử trong mảng, hoặc tạo ID tạm thời cho dữ liệu.','2026-01-28 14:37:51'),(187,33,'theory',1,'Lời khuyên khi làm việc với Date & Math','- Với Date: Luôn nhớ cộng 1 cho tháng khi hiển thị cho người dùng.\n- Với Math: Hãy tận dụng Math.floor kết hợp với Math.random để tạo ra các logic ngẫu nhiên cho ứng dụng.\n- Trong các dự án lớn, nếu việc xử lý ngày tháng của Date quá phức tạp, các lập trình viên thường dùng thêm thư viện hỗ trợ (như Moment.js hoặc Day.js), nhưng hiểu gốc rễ của đối tượng Date vẫn là quan trọng nhất.',NULL,NULL,'2026-01-28 14:38:17'),(188,34,'theory',1,'Tư duy rẽ nhánh trong lập trình','Bình thường, mã nguồn sẽ chạy từ trên xuống dưới. Tuy nhiên, để tạo ra một ứng dụng thông minh, chúng ta cần tạo ra các nhánh. Tại mỗi điểm rẽ nhánh, chương trình sẽ đặt ra một câu hỏi (điều kiện), và tùy vào câu trả lời là Đúng hay Sai mà nó sẽ đi theo những con đường khác nhau.\n\nHãy tưởng tượng đây là một ngã ba đường: Nếu bạn có vé, bạn đi lối bên trái; nếu không, bạn đi lối bên phải. Hai con đường này không bao giờ giao nhau tại cùng một thời điểm thực thi.',NULL,NULL,'2026-01-28 14:41:07'),(189,34,'code',1,'Cấu trúc If - Else If - Else (Đa nhánh)','let hour = 19;\n\nif (hour < 12) {\n    console.log(\"Chúc buổi sáng!\");\n} else if (hour < 18) {\n    console.log(\"Chúc buổi chiều!\");\n} else if (hour < 22) {\n    console.log(\"Chúc buổi tối!\");\n} else {\n    console.log(\"Chúc ngủ ngon!\");\n}','javascript','JavaScript sẽ kiểm tra từ trên xuống dưới.\n- Nếu hour < 12 sai, nó mới kiểm tra tiếp hour < 18.\n- Ngay khi tìm thấy một điều kiện Đúng, nó thực hiện khối mã đó và thoát khỏi toàn bộ cấu trúc rẽ nhánh ngay lập tức, các nhánh phía dưới sẽ bị bỏ qua hoàn toàn.','2026-01-28 14:41:37'),(190,34,'theory',1,'Lệnh If lồng nhau (Nested If)','Đôi khi một quyết định phụ thuộc vào một quyết định khác trước đó. Ví dụ: Để rút tiền, trước tiên bạn phải nhập đúng mã PIN, sau đó mới kiểm tra số dư có đủ không.\n\nViệc lồng các câu lệnh if giúp bạn kiểm tra các điều kiện theo từng lớp (layer). Tuy nhiên, hãy cẩn thận: Nếu lồng quá nhiều lớp (quá 3 lớp), code của bạn sẽ trở nên cực kỳ khó đọc và khó bảo trì.',NULL,NULL,'2026-01-28 14:41:56'),(191,34,'code',1,'','let isLogin = true;\nlet balance = 500;\nlet withdrawAmount = 200;\n\nif (isLogin) {\n    console.log(\"Đã đăng nhập thành công.\");\n\n    if (balance >= withdrawAmount) {\n        console.log(\"Đang thực hiện giao dịch rút tiền...\");\n    } else {\n        console.log(\"Số dư không đủ.\");\n    }\n} else {\n    console.log(\"Vui lòng đăng nhập để tiếp tục.\");\n}','javascript','Nhánh kiểm tra số dư chỉ được chạy nếu và chỉ nếu biến isLogin là true. Đây là cách chúng ta bảo vệ các logic quan trọng, không cho phép thực thi khi các điều kiện tiên quyết chưa đạt.','2026-01-28 14:42:09'),(192,34,'theory',1,'Tổng kết và Lời khuyên','- Thứ tự ưu tiên: Đặt các điều kiện quan trọng hoặc dễ xảy ra nhất lên trên cùng.\n- Đừng quá lạm dụng Else: Nếu một hàm có quá nhiều if-else, hãy cân nhắc sử dụng Switch-case (sẽ học ở bài sau) hoặc kỹ thuật \"Early Return\" (thoát sớm).\n- Kết hợp Logical Operators: Thay vì lồng if, hãy thử dùng && hoặc || để gộp các điều kiện lại với nhau nếu có thể để code trông phẳng và dễ nhìn hơn.',NULL,NULL,'2026-01-28 14:42:33'),(193,35,'theory',1,'Khi nào thì nên dùng Switch?','Câu lệnh switch thường được sử dụng khi bạn có một biến và muốn so sánh giá trị của biến đó với nhiều giá trị khác nhau.\n\nThay vì viết if (a === 1) {...} else if (a === 2) {...} else if (a === 3) {...}, bạn chỉ cần đưa a vào \"máy lọc\" của switch.\n\n**Điểm khác biệt:** switch-case thực hiện so sánh bằng tuyệt đối (===). Điều này có nghĩa là cả giá trị và kiểu dữ liệu đều phải khớp hoàn toàn thì nhánh đó mới được thực thi.',NULL,NULL,'2026-01-28 14:43:19'),(194,35,'code',1,'Cấu trúc cơ bản của Switch-case','let date = 2;\n\nswitch(date) {\n    case 2:\n        console.log(\"Hôm nay là Thứ hai\");\n        break;\n    case 3:\n        console.log(\"Hôm nay là Thứ ba\");\n        break;\n    case 4:\n        console.log(\"Hôm nay là Thứ tư\");\n        break;\n    default:\n        console.log(\"Không biết ngày gì luôn!\");\n}','javascript','- switch(biến): Nơi chứa giá trị cần kiểm tra.\n- case giá_trị: Các kịch bản có thể xảy ra.\n- break: Cực kỳ quan trọng! Nó ra lệnh cho chương trình \"Thoát ngay lập tức\" sau khi đã tìm thấy đúng nhánh.\n- default: Nhánh dự phòng, sẽ chạy nếu không có case nào khớp (giống như else cuối cùng).','2026-01-28 14:43:49'),(195,35,'theory',1,'Tại sao phải có từ khóa break','Nếu bạn quên break, JavaScript sẽ thực hiện một hành động kỳ lạ: Nó chạy đúng case đó, nhưng sau đó nó tiếp tục chạy tất cả các case phía dưới bất kể điều kiện có khớp hay không, cho đến khi nó gặp một từ khóa break hoặc đi hết câu lệnh switch.\n\nĐôi khi lập trình viên cố tình bỏ break để gộp nhiều trường hợp thực hiện chung một hành động. Ví dụ: Cả thứ 7 và Chủ nhật đều hiện thông báo \"Cuối tuần\".',NULL,NULL,'2026-01-28 14:44:05'),(196,35,'code',1,'Tối ưu code khi nhiều nhánh trùng hành động','let month = 2;\n\nswitch(month) {\n    case 1:\n    case 2:\n    case 3:\n        console.log(\"Mùa Xuân\");\n        break;\n    case 4:\n    case 5:\n    case 6:\n        console.log(\"Mùa Hạ\");\n        break;\n    default:\n        console.log(\"Các mùa còn lại...\");\n}','javascript','Bằng cách không viết break giữa case 1, 2 và 3, chúng ta tạo ra một nhóm logic. Chỉ cần month rơi vào một trong ba số này, thông báo \"Mùa Xuân\" sẽ xuất hiện.','2026-01-28 14:44:31'),(197,35,'theory',1,'Tổng kết bài học','- Luôn nhớ dùng break trừ khi bạn có ý định gộp các case.\n- Nhớ rằng switch so sánh bằng === (số 2 khác chuỗi \"2\").\n- default không bắt buộc nhưng nên có để xử lý các lỗi dữ liệu không mong muốn',NULL,NULL,'2026-01-28 14:44:57'),(199,36,'theory',1,'Tên gọi và ý nghĩa','Sở dĩ gọi là \"3 ngôi\" vì toán tử này gồm 3 thành phần (ngôi) chính tham gia vào một biểu thức. Đây là toán tử duy nhất trong JavaScript làm việc với 3 đối số cùng lúc.\n\nVề bản chất, nó là cách viết tắt của câu lệnh if-else nhưng thay vì thực hiện các khối mã (blocks), nó trả về một giá trị cụ thể',NULL,NULL,'2026-01-28 14:46:20'),(200,36,'code',1,'Cú pháp và Cách hoạt động','// Cú pháp:\n// điều_kiện ? giá_trị_nếu_đúng : giá_trị_nếu_sai;\n\nlet age = 20;\nlet canVote = (age >= 18) ? \"Được bầu cử\" : \"Chưa đủ tuổi\";\n\nconsole.log(canVote); // \"Được bầu cử\"','javascript','- JavaScript sẽ kiểm tra phần trước dấu ?.\n- Nếu là True (hoặc Truthy): Trả về giá trị nằm sau dấu ?.\n- Nếu là False (hoặc Falsy): Trả về giá trị nằm sau dấu :.\n- Toàn bộ biểu thức này được coi là một giá trị, nên bạn có thể gán nó trực tiếp cho một biến.','2026-01-28 14:46:56'),(201,36,'theory',1,'So sánh If-else vs Toán tử 3 ngôi','',NULL,NULL,'2026-01-28 14:47:20'),(202,36,'theory',1,'','Hãy xem cách chúng ta xử lý cùng một bài toán tính phí ship:\n- Dùng If-else:',NULL,NULL,'2026-01-28 14:47:37'),(203,36,'code',1,'','let price = 500;\nlet shipping;\nif (price > 1000) {\n    shipping = 0;\n} else {\n    shipping = 30;\n}','javascript','','2026-01-28 14:47:46'),(204,36,'theory',1,'','- Dùng Toán tử 3 ngôi:',NULL,NULL,'2026-01-28 14:48:08'),(205,36,'code',1,'','let shipping = (price > 1000) ? 0 : 30;','javascript','','2026-01-28 14:48:18'),(206,36,'theory',1,'Khi nào KHÔNG nên dùng toán tử 3 ngôi?','Toán tử 3 ngôi chỉ thực sự tốt cho các logic đơn giản. Bạn không nên lồng các toán tử 3 ngôi vào nhau (Nested Ternary) vì nó sẽ trở thành ác mộng cho người đọc code sau này.\n\n**Lời khuyên**: Nếu điều kiện của bạn phức tạp hoặc đòi hỏi thực hiện nhiều dòng lệnh (như gọi hàm, thay đổi nhiều biến...), hãy quay lại dùng if-else hoặc switch-case truyền thống.',NULL,NULL,'2026-01-28 14:48:32'),(207,36,'code',1,'Ứng dụng thực tế trong Template String','let isVip = true;\nlet message = `Chào mừng ${isVip ? \"Khách hàng VIP\" : \"Bạn\"} đã quay lại!`;\n\nconsole.log(message); // \"Chào mừng Khách hàng VIP đã quay lại!\"','javascript','Đây là ứng dụng cực kỳ phổ biến trong các Framework hiện đại như React. Nó cho phép bạn hiển thị nội dung động ngay bên trong chuỗi văn bản một cách cực kỳ linh hoạt.','2026-01-28 14:48:57'),(208,37,'theory',1,'Vòng lặp là gì?','rong cuộc sống, vòng lặp xuất hiện ở khắp mọi nơi: Kim đồng hồ quay đủ 60 giây thì quay lại từ đầu, bạn chạy bộ đủ 10 vòng sân thì nghỉ, hoặc bạn rửa bát cho đến khi cái rổ không còn chiếc bát nào nữa.\n\nTrong lập trình, Vòng lặp là một cấu trúc cho phép bạn thực hiện đi thực hiện lại một đoạn mã miễn là một điều kiện nào đó vẫn còn đúng (true). Nó giúp bạn giải quyết các tác vụ lặp lại mà không cần phải viết tay hàng trăm dòng code giống nhau.',NULL,NULL,'2026-01-28 14:50:28'),(209,37,'theory',1,'Tại sao chúng ta cần vòng lặp?','Hãy thử tưởng tượng bạn cần in ra các số từ 1 đến 1.000.\n- Cách thủ công: Viết 1.000 dòng console.log(). (Mất cả ngày và cực kỳ dễ sai).\n- Cách dùng vòng lặp: Chỉ cần 3 dòng code. Máy tính sẽ làm phần việc nặng nhọc còn lại cho bạn.\n\nVòng lặp cực kỳ quan trọng khi làm việc với Mảng (Array) và Đối tượng (Object), nơi bạn cần duyệt qua danh sách hàng nghìn sản phẩm để hiển thị lên màn hình hoặc tính tổng tiền giỏ hàng.',NULL,NULL,'2026-01-28 14:50:48'),(210,37,'theory',1,'3 Thành phần \"xương sống\" của một vòng lặp','Để một vòng lặp không chạy \"loạn\" hoặc chạy mãi không dừng, nó luôn cần 3 yếu tố:\n- Giá trị khởi tạo: Điểm bắt đầu của vòng lặp (ví dụ: bắt đầu từ số 1).\n- Điều kiện dừng: Câu hỏi để quyết định có chạy tiếp hay không (ví dụ: nếu còn nhỏ hơn 10 thì chạy tiếp).\n- Bước nhảy (Increment/Decrement): Cách thay đổi giá trị sau mỗi lần lặp để tiến dần đến điều kiện dừng (ví dụ: tăng thêm 1 sau mỗi lần chạy).',NULL,NULL,'2026-01-28 14:51:08'),(211,37,'theory',1,'Các loại vòng lặp phổ biến trong JavaScript','- \"for\"	Phổ biến nhất, dùng khi biết trước số lần lặp cụ thể.\n- \"while\"	Dùng khi không biết trước số lần lặp, chỉ quan tâm đến điều kiện đúng.\n- \"do...while\"	Giống while nhưng sẽ chạy ít nhất 1 lần trước khi kiểm tra điều kiện.\n- \"for...in\"	Dùng để duyệt qua các Key của một Đối tượng (Object).\n- \"for...of\"	Dùng để duyệt qua các Phần tử của một Mảng (Array) hoặc Chuỗi.',NULL,NULL,'2026-01-28 14:51:53'),(212,37,'theory',1,'Cạm bẫy Vòng lặp vô tận (Infinite Loop)','Một lỗi kinh điển của lập trình viên là tạo ra một vòng lặp mà điều kiện dừng không bao giờ xảy ra.\n\nVí dụ: Bạn bảo máy tính chạy khi *i > 0 * nhưng bạn lại không bao giờ tăng giá trị của *i* lên hoặc lại giảm *i* đi. Lúc này, máy tính sẽ chạy mãi mãi, ngốn sạch RAM và làm trình duyệt của bạn \"đứng hình\". Luôn kiểm tra kỹ bước nhảy của bạn trước khi nhấn \"Run\" nhé!',NULL,NULL,'2026-01-28 14:54:37'),(213,37,'theory',1,'Ghi nhớ nhanh','- Vòng lặp dùng để thực hiện các tác vụ lặp đi lặp lại.\n- Giúp tối ưu hóa code theo nguyên lý DRY (Don\'t Repeat Yourself).\n- Luôn phải có Điểm bắt đầu, Điều kiện dừng và Bước nhảy.\n- Chọn loại vòng lặp phù hợp với cấu trúc dữ liệu đang xử lý.',NULL,NULL,'2026-01-28 14:55:11'),(214,39,'theory',1,'Cấu trúc của vòng lặp For','Vòng lặp for có cấu trúc gồm 3 phần nằm trong cặp ngoặc đơn, ngăn cách bởi dấu chấm phẩy ;:\n- Biểu thức khởi tạo: Chạy duy nhất 1 lần khi vòng lặp bắt đầu (thường dùng để khai báo biến đếm let i = 0).\n- Điều kiện dừng: Kiểm tra trước mỗi lần lặp. Nếu true, mã bên trong sẽ chạy. Nếu false, vòng lặp kết thúc.\n- Biểu thức tăng/giảm: Chạy sau mỗi lần thân vòng lặp thực thi xong (thường dùng để tăng biến đếm i++).',NULL,NULL,'2026-01-28 14:56:17'),(215,39,'theory',1,'Luồng vận hành (Execution Flow)','Đây là điểm quan trọng nhất để tránh lỗi logic. Thứ tự chạy như sau:\n- Khởi tạo biến (ví dụ: i = 1).\n- Kiểm tra điều kiện (ví dụ: i <= 10?).\n- Nếu đúng, thực hiện mã trong ngoặc nhọn {}.\n- Thực hiện bước nhảy (ví dụ: i++).\n- Quay lại bước 2 (Kiểm tra điều kiện).\n\n**Lưu ý**: Bước nhảy chỉ diễn ra sau khi các câu lệnh trong thân vòng lặp đã chạy xong.',NULL,NULL,'2026-01-28 14:56:46'),(216,39,'code',1,'','for (let i = 1; i <= 5; i++) {\n    console.log(\"Lần lặp thứ: \" + i);\n}','javascript','- Vòng lặp bắt đầu với i = 1.\n- Nó in ra \"Lần lặp thứ 1\", sau đó tăng i lên 2.\n- Tiếp tục cho đến khi i = 6, điều kiện 6 <= 5 là false, vòng lặp dừng lạ','2026-01-28 14:57:14'),(219,39,'theory',1,'Tổng kết','- for là lựa chọn tốt nhất khi biết rõ số lần lặp.\n- Cấu trúc: for (khởi tạo; điều kiện; bước nhảy).\n- Luôn dùng .length để duyệt mảng một cách an toàn.\n- Cẩn thận với điều kiện dừng để tránh vòng lặp vô tận.',NULL,NULL,'2026-01-28 14:58:12'),(220,40,'theory',1,'Vòng lặp for...in là gì?','Vòng lặp for...in được sinh ra với mục đích chính là duyệt qua các thuộc tính (keys) của một đối tượng. Thay vì dùng chỉ số 0, 1, 2... như mảng, for...in sẽ lần lượt lấy ra các tên thuộc tính như name, age, address...\n\nHãy tưởng tượng một chiếc hộp có nhiều ngăn, mỗi ngăn dán một cái nhãn bên ngoài. for...in giúp bạn đọc lần lượt từng cái nhãn đó để biết bên trong ngăn đó chứa gì.',NULL,NULL,'2026-01-28 14:59:39'),(221,40,'code',1,'Cú pháp và Thực hành trên Object','const myInfo = {\n    name: \'Hoàng Trần\',\n    age: 25,\n    address: \'Hà Nội\'\n};\n\nfor (let key in myInfo) {\n    // \'key\' sẽ lần lượt là: name, age, address\n    console.log(`Thuộc tính: ${key}`); \n\n    // Lấy giá trị (value) tương ứng\n    console.log(`Giá trị: ${myInfo[key]}`); \n}','javascript','- Trong mỗi lần lặp, biến key sẽ nhận giá trị là tên của thuộc tính dưới dạng Chuỗi (String).\n- Lưu ý cực quan trọng: Bạn phải dùng cú pháp ngoặc vuông myInfo[key] để lấy giá trị. Bạn không được dùng myInfo.key vì JavaScript sẽ hiểu lầm là bạn đang tìm một thuộc tính có tên chính xác là \"key\".','2026-01-28 15:00:03'),(222,40,'theory',1,'For...in có dùng cho Array được không?','Câu trả lời là Có, nhưng không được khuyến khích. Khi dùng for...in với mảng, biến chạy sẽ trả về các chỉ số (index) của mảng dưới dạng chuỗi (\"0\", \"1\", \"2\"...) chứ không phải kiểu số.\n\nNếu bạn chỉ muốn lấy giá trị của mảng, các bài sau về for...of hoặc forEach sẽ là sự lựa chọn tốt hơn nhiều. Tuy nhiên, hiểu cách nó hoạt động trên mảng vẫn giúp bạn tránh được những lỗi logic không đáng có.',NULL,NULL,'2026-01-28 15:00:27'),(223,40,'code',1,'','// 1. Với Mảng\nlet languages = [\'Javascript\', \'PHP\', \'Ruby\'];\nfor (let index in languages) {\n    console.log(languages[index]);\n}\n\n// 2. Với Chuỗi (String)\nlet myString = \'Code\';\nfor (let charIndex in myString) {\n    console.log(myString[charIndex]); // C, o, d, e\n}','javascript','','2026-01-28 15:00:38'),(224,40,'theory',1,'Một số lưu ý quan trọng','**Thứ tự không đảm bảo**: Với Object, JavaScript không cam kết sẽ duyệt qua các key theo đúng thứ tự bạn đã viết. Mặc dù hầu hết các trình duyệt hiện nay làm khá tốt việc này, nhưng bạn không nên dựa hoàn toàn vào nó cho các logic quan trọng về thứ tự.\n\n**Tính Enumerable**: for...in chỉ duyệt qua các thuộc tính có thể liệt kê (enumerable). Các thuộc tính ẩn của hệ thống sẽ không xuất hiện trong vòng lặp này.',NULL,NULL,'2026-01-28 15:02:00'),(225,40,'theory',1,'Ghi nhớ nhanh về for...in','- Dùng chủ yếu cho Object để lấy tên thuộc tính (Key).\n- Biến chạy trong for...in luôn là kiểu Chuỗi.\n- Dùng object[key] để lấy dữ liệu bên trong.\n- Tránh dùng cho Mảng nếu bạn cần tính toán với chỉ số hoặc quan tâm đến hiệu suất.',NULL,NULL,'2026-01-28 15:02:28'),(226,41,'theory',1,'Vòng lặp for...of là gì?','Trong vòng lặp for truyền thống, bạn phải thông qua biến i để lấy giá trị (arr[i]). Với for...of, JavaScript tự động làm việc đó cho bạn. Vòng lặp này sẽ đi qua từng phần tử của một tập hợp có thể lặp (Iterable) như Mảng, Chuỗi, hoặc danh sách các Node trong DOM.\n\nĐiểm khác biệt cốt lõi: \n- for...in: Trả về Index/Key (Chỉ số/Tên thuộc tính).\n- for...of: Trả về Value (Giá trị thực tế).',NULL,NULL,'2026-01-28 15:03:30'),(227,41,'code',1,'','// 1. Duyệt Mảng\nconst languages = [\'Javascript\', \'PHP\', \'Java\', \'Python\'];\n\nfor (let value of languages) {\n    console.log(value); // Trả về trực tiếp: Javascript, PHP...\n}\n\n// 2. Duyệt Chuỗi\nconst myString = \'CodePulse\';\n\nfor (let char of myString) {\n    console.log(char); // Trả về từng ký tự: C, o, d, e...\n}','javascript','Bạn thấy đấy, code trông cực kỳ gọn gàng. Bạn không còn phải lo lắng về việc i bắt đầu từ đâu hay i < length nữa. JavaScript tự hiểu là phải đi từ đầu đến cuối tập hợp.','2026-01-28 15:03:48'),(228,41,'theory',1,'Vấn đề với Đối tượng (Object)','Nếu bạn cố tình dùng for...of cho một Object thông thường, bạn sẽ nhận được một lỗi: Uncaught TypeError: ... is not iterable.\n\nLý do là vì Object trong JavaScript không có tính chất \"có thể lặp\" (iterable) theo mặc định. Tuy nhiên, chúng ta có thể \"lách luật\" bằng cách biến đổi Object thành một mảng thông qua các phương thức của lớp Object.',NULL,NULL,'2026-01-28 15:03:59'),(229,41,'code',1,'','const user = {\n    name: \'Hoàng\',\n    age: 20\n};\n\n// Cách 1: Duyệt qua danh sách Keys\nfor (let key of Object.keys(user)) {\n    console.log(key); // name, age\n    console.log(user[key]); // Hoàng, 20\n}\n\n// Cách 2: Duyệt trực tiếp qua danh sách Values\nfor (let value of Object.values(user)) {\n    console.log(value); // Hoàng, 20\n}','javascript','- Object.keys(user) trả về một mảng: [\'name\', \'age\'].\n- Object.values(user) trả về một mảng: [\'Hoàng\', 20]. Vì kết quả trả về là một Mảng, nên lúc này for...of lại hoạt động hoàn hảo.','2026-01-28 15:04:28'),(230,41,'theory',1,'Quy tắc chọn vòng lặp','- Hãy ưu tiên for...of cho Mảng và Chuỗi để code sạch và dễ hiểu nhất.\n- Hãy dùng for...in khi bạn thực sự cần làm việc với các thuộc tính của Object.\n- Nhớ rằng for...of giúp bạn tránh được các lỗi về tính toán chỉ số (index).',NULL,NULL,'2026-01-28 15:04:50'),(231,42,'theory',1,'Vòng lặp While là gì?','Vòng lặp while kiểm tra điều kiện trước khi thực hiện khối mã bên trong. Nếu điều kiện đúng (true), nó sẽ chạy code. Sau khi chạy xong, nó quay lại kiểm tra điều kiện một lần nữa. Quá trình này lặp lại cho đến khi điều kiện trở thành sai (false).\n\nHãy tưởng tượng: \"Chừng nào bụng còn đói (điều kiện), thì vẫn tiếp tục ăn (hành động)\". Bạn không biết chắc mình sẽ ăn bao nhiêu miếng, bạn chỉ biết là mình sẽ dừng lại khi hết đói.',NULL,NULL,'2026-01-29 00:53:56'),(232,42,'code',1,'Cú pháp cơ bản của While','let i = 1; // 1. Khởi tạo biến\n\nwhile (i <= 5) { // 2. Điều kiện dừng\n    console.log(\"Lần lặp thứ: \" + i);\n\n    i++; // 3. Bước nhảy (Cực kỳ quan trọng)\n}','javascript','So với vòng lặp for, các thành phần của while nằm ở các vị trí khác nhau:\n- Biến khởi tạo phải được khai báo bên ngoài vòng lặp.\n- Điều kiện nằm trong ngoặc đơn sau từ khóa while.\n- Bước nhảy phải được viết bên trong thân vòng lặp. Nếu bạn quên bước này, giá trị của i sẽ mãi là 1, và vòng lặp sẽ chạy vô tận!','2026-01-29 00:54:23'),(233,42,'theory',1,'Khi nào nên chọn While thay vì For?','Bạn nên dùng while khi không biết trước chính xác mình cần lặp lại bao nhiêu lần.\n- Dùng for: Khi bạn muốn in ra 10 số, hoặc duyệt qua một mảng có 5 phần tử.\n- Dùng while: Khi bạn muốn yêu cầu người dùng nhập mật khẩu cho đến khi đúng thì thôi, hoặc xử lý dữ liệu cho đến khi gặp một giá trị rác nào đó.',NULL,NULL,'2026-01-29 00:54:48'),(234,42,'code',1,'Duyệt mảng với While','const myArr = [\'Javascript\', \'PHP\', \'Ruby\'];\nlet index = 0;\n\nwhile (index < myArr.length) {\n    console.log(myArr[index]);\n    index++;\n}','javascript','Kết quả cho ra hoàn toàn giống với vòng lặp for. Tuy nhiên, cách viết này giúp bạn tách biệt rõ ràng phần \"kiểm tra điều kiện\" và phần \"thực hiện logic\", giúp code linh hoạt hơn trong một số trường hợp phức tạp.','2026-01-29 00:55:23'),(235,42,'theory',1,'Ghi nhớ để tránh treo máy','- while kiểm tra điều kiện trước, thực hiện sau.\n- Luôn đảm bảo giá trị của biến điều kiện sẽ thay đổi sau mỗi lần lặp để tránh vòng lặp vô tận.\n- Sử dụng while khi điều kiện dừng phụ thuộc vào một yếu tố bên ngoài (như input người dùng) chứ không chỉ là đếm số.',NULL,NULL,'2026-01-29 00:55:59'),(236,43,'theory',1,'Sự khác biệt cốt lõi: Làm trước, hỏi sau','Trong khi for và while kiểm tra điều kiện ngay tại \"cửa ngõ\" (entry-controlled loops), thì do...while lại kiểm tra điều kiện ở \"lối ra\" (exit-controlled loop).\n\n**Điểm mấu chốt**: Khối mã bên trong do sẽ được thực thi trước khi trình biên dịch ngó tới điều kiện nằm trong while. Điều này có nghĩa là ngay cả khi điều kiện của bạn sai ngay từ đầu ($false$), chương trình vẫn sẽ \"lỡ\" chạy qua khối lệnh đó một lần.',NULL,NULL,'2026-01-29 00:58:30'),(237,43,'code',1,'Cấu trúc cú pháp và Quy tắc viết','let count = 10;\n\ndo {\n    console.log(\"Đây là lần chạy thứ: \" + count);\n    count++; // Bước nhảy\n} while (count < 10); \n\nconsole.log(\"Vòng lặp kết thúc.\");','javascript','- Từ khóa do: Bắt đầu khối lệnh bạn muốn thực thi.\n- Khối lệnh { ... }: Chứa các hành động và bước nhảy (increment/decrement).\n- Từ khóa while (condition): Nằm ở cuối khối lệnh.\n- Dấu chấm phẩy ;: Đây là lỗi phổ biến nhất! Khác với while thông thường, do...while bắt buộc phải có dấu ; sau ngoặc đơn của điều kiện để báo hiệu kết thúc câu lệnh.','2026-01-29 00:59:04'),(238,43,'theory',1,'Tại sao và Khi nào nên dùng do...while','Bạn sẽ thắc mắc: \"Tại sao không dùng while cho rồi?\". Câu trả lời nằm ở những kịch bản mà hành động phải diễn ra để sinh ra dữ liệu cho việc kiểm tra.\n\nCác ví dụ thực tế điển hình:\n- Nhập mật khẩu: Bạn phải cho người dùng nhập một lần, sau đó mới kiểm tra đúng/sai. Nếu sai mới yêu cầu nhập lại.\n- Lấy dữ liệu từ API (Retry Mechanism): Bạn thực hiện gọi lên Server 1 lần. Nếu thất bại, bạn mới kiểm tra điều kiện \"số lần thử lại còn hay không\" để lặp lại hành động đó.\n- Trò chơi (Game Loop): Vẽ nhân vật lên màn hình trước, sau đó mới kiểm tra xem người dùng có nhấn nút thoát game hay chưa.\n\n**[!TIP]** Nếu bạn muốn đảm bảo logic của mình luôn được \"chào sân\" ít nhất một lần bất kể môi trường xung quanh ra sao, do...while chính là sự lựa chọn số 1.',NULL,NULL,'2026-01-29 00:59:48'),(239,43,'code',1,'Mô phỏng hệ thống ATM','const CORRECT_PIN = \"1234\";\nlet inputPin;\nlet attempts = 0;\n\ndo {\n    // Giả lập việc người dùng nhập mã (trong thực tế có thể dùng prompt)\n    inputPin = \"1111\"; // Giả sử nhập sai\n    attempts++;\n\n    console.log(`Lần thử thứ ${attempts}: Bạn đã nhập ${inputPin}`);\n\n    if (attempts >= 3) {\n        console.log(\"Bạn đã nhập sai quá 3 lần. Tài khoản bị khóa!\");\n        break; // Thoát khẩn cấp\n    }\n\n} while (inputPin !== CORRECT_PIN);\n\nif (inputPin === CORRECT_PIN) {\n    console.log(\"Mã PIN chính xác! Đang vào hệ thống...\");\n}','javascript','','2026-01-29 01:00:04'),(240,43,'theory',1,'Cạm bẫy cần tránh (Common Pitfalls)','- Quên dấu ; ở cuối: Trình biên dịch sẽ báo lỗi hoặc hiểu sai logic của đoạn code phía sau.\n- Vòng lặp vô tận: Vì nó chạy trước rồi mới hỏi, nên nếu logic bên trong do không bao giờ làm cho điều kiện trong while trở thành *false*, trình duyệt của bạn sẽ bị \"treo\" ngay lập tức.\n- Logic \"lỡ đà\": Hãy cẩn thận với những hành động gây ảnh hưởng lớn (như xóa dữ liệu). Vì nó luôn chạy một lần, bạn có thể vô tình xóa mất dữ liệu ngay cả khi điều kiện bảo vệ đang là *false*.',NULL,NULL,'2026-01-29 01:00:58'),(241,44,'theory',1,'Từ khóa break – Lệnh dừng khẩn cấp','**Khái niệm**: Khi trình biên dịch gặp từ khóa break, nó sẽ ngay lập tức thoát ra khỏi vòng lặp gần nhất chứa nó. Mọi câu lệnh phía sau break trong thân vòng lặp và các lần lặp dự kiến còn lại đều bị hủy bỏ hoàn toàn.\n\n**Cơ chế vận hành**: break phá vỡ luồng lặp và đưa con trỏ thực thi xuống dòng code đầu tiên ngay sau khối lệnh của vòng lặp đó.\n\n**Ứng dụng thực tế (Tối ưu hiệu suất)**: Giả sử bạn cần tìm một sản phẩm trong danh sách 1 triệu món đồ. Nếu bạn tìm thấy nó ngay ở vị trí thứ 10, bạn nên dùng break để máy tính không phải kiểm tra 999.990 món đồ còn lại. Điều này giúp tiết kiệm CPU và tăng tốc độ ứng dụng đáng kể.',NULL,NULL,'2026-01-29 01:24:03'),(242,44,'theory',1,'Từ khóa continue – Nhảy cóc thông minh','**Khái niệm**: Khác với break, continue không kết thúc vòng lặp. Nó chỉ dừng lần lặp hiện tại ngay tại vị trí đó và nhảy thẳng đến bước kiểm tra điều kiện (hoặc bước nhảy i++ trong vòng lặp for) để bắt đầu một vòng đời mới.\n\n**Cơ chế vận hành**: Mọi dòng code nằm bên dưới continue (nhưng vẫn trong thân vòng lặp) sẽ bị bỏ qua trong lần lặp đó.\n\n**Ứng dụng thực tế (Lọc dữ liệu)**: Khi bạn đang xử lý danh sách bảng lương và gặp một nhân viên có dữ liệu \"Nghỉ không lương cả tháng\", bạn dùng continue để bỏ qua các bước tính toán phức tạp cho người đó và chuyển ngay sang nhân viên tiếp theo.',NULL,NULL,'2026-01-29 01:24:28'),(243,44,'code',1,'Xử lý dữ liệu thực tế: Kết hợp Break và Continue để xử lý danh sách người dùng','const users = [\n    { name: \"An\", status: \"active\", score: 85 },\n    { name: \"Bình\", status: \"banned\", score: 90 }, // Tài khoản bị khóa\n    { name: \"Chi\", status: \"active\", score: 40 }, // Điểm thấp\n    { name: \"Dũng\", status: \"active\", score: 98 }, // Mục tiêu cần tìm\n    { name: \"En\", status: \"active\", score: 70 }\n];\n\nconsole.log(\"--- Bắt đầu quét danh sách mục tiêu ---\");\n\nfor (let i = 0; i < users.length; i++) {\n    // 1. Dùng continue để bỏ qua người bị Banned\n    if (users[i].status === \"banned\") {\n        console.log(`Bỏ qua ${users[i].name} vì tài khoản bị khóa.`);\n        continue; \n    }\n\n    // 2. Logic chính: Tìm người đầu tiên có điểm > 95\n    if (users[i].score > 95) {\n        console.log(`Đã tìm thấy: ${users[i].name} (Điểm: ${users[i].score})`);\n        break; // Tìm thấy rồi, dừng toàn bộ vòng lặp để tiết kiệm tài nguyên\n    }\n\n    console.log(`Đang kiểm tra: ${users[i].name}...`);\n}','javascript','','2026-01-29 01:24:53'),(244,44,'theory',1,'Labeled Statement (Nhãn vòng lặp)','Một vấn đề nan giải là làm sao để break một vòng lặp cha (vòng lặp bên ngoài) khi đang đứng ở bên trong một vòng lặp con? JavaScript cho phép chúng ta đặt một cái Nhãn (Label) trước vòng lặp để định danh nó.',NULL,NULL,'2026-01-29 01:25:15'),(245,44,'code',1,'','// Đặt tên cho vòng lặp ngoài là \'outer\'\nouter: for (let i = 1; i <= 3; i++) {\n    for (let j = 1; j <= 3; j++) {\n        if (i === 2 && j === 2) {\n            console.log(\"Gặp điểm ngắt đặc biệt. Thoát toàn bộ!\");\n            break outer; // Thoát hẳn cả vòng lặp cha\n        }\n        console.log(`i = ${i}, j = ${j}`);\n    }\n}','javascript','Lưu ý: Chỉ sử dụng Nhãn khi thực sự cần thiết (như xử lý ma trận đa chiều) vì nó có thể làm cấu trúc code trở nên khó theo dõi nếu lạm dụng.','2026-01-29 01:25:28'),(246,44,'theory',1,'Tổng kết bài học','- Sử dụng break để tối ưu hiệu suất khi kết quả đã đạt được.\n- Sử dụng continue để giữ cho code \"sạch\" hơn, tránh việc lồng quá nhiều câu lệnh if bên trong vòng lặp.\n- Luôn cẩn thận khi dùng break trong vòng lặp lồng nhau vì nó chỉ thoát được một cấp (trừ khi dùng Label).',NULL,NULL,'2026-01-29 01:26:09'),(247,45,'theory',1,'Tư duy Bánh răng trong vòng lặp lồng nhau','**Khái niệm**: Vòng lặp lồng nhau là việc bạn đặt một vòng lặp (vòng lặp con - inner loop) nằm bên trong thân của một vòng lặp khác (vòng lặp cha - outer loop).\n\n**Cơ chế vận hành**: * Với mỗi một lần lặp của vòng lặp cha, vòng lặp con sẽ phải chạy đủ toàn bộ số lần của nó từ đầu đến cuối.\n\n**Ví dụ thực tế**: Hãy tưởng tượng chiếc kim đồng hồ. Kim giờ nhích một số (vòng lặp cha), thì kim phút phải quay đủ 60 vòng (vòng lặp con). Hoặc khi bạn đọc một cuốn sách: Bạn đi từng chương (vòng lặp cha), và trong mỗi chương bạn đọc từng dòng chữ (vòng lặp con).',NULL,NULL,'2026-01-29 01:27:30'),(248,45,'code',1,'Phân tích luồng chạy (Execution Trace)','for (let i = 1; i <= 2; i++) { // Vòng lặp CHA\n    console.log(`--- Vòng CHA bắt đầu (i = ${i}) ---`);\n\n    for (let j = 1; j <= 3; j++) { // Vòng lặp CON\n        console.log(`   Vòng CON đang chạy (j = ${j})`);\n    }\n\n    console.log(`--- Vòng CHA kết thúc (i = ${i}) ---`);\n}','javascript','- i = 1: Vòng cha bắt đầu.\n- Nó gặp vòng con: j chạy lần lượt từ 1 -> 2 -> 3. (Kết quả: in ra 3 dòng của j).\n- Vòng con kết thúc. Vòng cha hoàn thành lần lặp 1.\n- i tăng lên 2: Vòng cha bắt đầu lần lặp mới.\n- Nó lại gặp vòng con: j lại được khởi tạo lại từ đầu và chạy từ 1 -> 2 -> 3.\n- Vòng con kết thúc. Vòng cha hoàn thành lần lặp 2 và dừng lại.\nTổng số lần thực thi: 2  (vòng cha) * 3  (vòng con) = 6 lần.','2026-01-29 01:29:26'),(249,45,'code',1,'Xử lý dữ liệu bảng (Matrix)','const matrix = [\n    [1, 2, 3], // Hàng 0\n    [4, 5, 6], // Hàng 1\n    [7, 8, 9]  // Hàng 2\n];\n\nfor (let i = 0; i < matrix.length; i++) {\n    // Duyệt qua từng hàng\n    for (let j = 0; j < matrix[i].length; j++) {\n        // Duyệt qua từng cột trong hàng đó\n        console.log(`Phần tử tại [${i}][${j}] là: ${matrix[i][j]}`);\n    }\n}','javascript','Đây là cách các lập trình viên xử lý bảng tính Excel, bản đồ trong Game (tọa độ x, y) hoặc xử lý các pixel trong một hình ảnh kỹ thuật số.','2026-01-29 01:30:41'),(250,45,'theory',1,'Cảnh báo về Hiệu suất (Big O Notation)','Trong khoa học máy tính, vòng lặp lồng nhau dẫn đến độ phức tạp thời gian là O(n^2) (Quadratic Time).\n- Nếu bạn lặp 100 phần tử lồng 100 phần tử: 10,000 phép tính (Rất nhanh).\n- Nếu bạn lặp 100,000 phần tử lồng 100,000 phần tử: 10 tỷ phép tính.\n\n**Hệ quả**: Trình duyệt sẽ bị treo ngay lập tức, người dùng sẽ thấy màn hình trắng hoặc thông báo \"Page Unresponsive\".\n\n**Kinh nghiệm đi làm**: Luôn tìm cách tối ưu để tránh lồng vòng lặp nếu có thể. Ví dụ: Sử dụng Object hoặc Map để tra cứu (lookup) thay vì dùng vòng lặp thứ hai để tìm kiếm.',NULL,NULL,'2026-01-29 01:32:15'),(251,45,'theory',1,'Tổng kết bài học','- Vòng lặp con chạy hết một chu kỳ thì vòng lặp cha mới nhích một bước.\n- Sử dụng để xử lý dữ liệu đa chiều (mảng trong mảng).\n- Luôn cẩn thận với số lượng phần tử để bảo vệ hiệu suất ứng dụng.\n- Có thể sử dụng break kèm theo Label để thoát ra khỏi cả hai vòng lặp cùng lúc.',NULL,NULL,'2026-01-29 01:32:45'),(252,46,'theory',1,'Đệ quy là gì?','Đệ quy là hiện tượng một hàm tự gọi lại chính nó bên trong thân hàm.\n\nHãy tưởng tượng bạn đứng giữa hai chiếc gương song song, hình ảnh của bạn sẽ lặp lại vô tận. Hoặc hãy nghĩ về búp bê Nga Matryoshka: khi bạn mở một con búp bê lớn, bên trong lại là một con búp bê nhỏ hơn nhưng có hình dáng y hệt, cho đến khi bạn gặp con búp bê nhỏ nhất không thể mở được nữa.',NULL,NULL,'2026-01-29 01:33:38'),(253,46,'theory',1,'Hai thành phần sống còn của Đệ quy','Một hàm đệ quy chuẩn mực bắt buộc phải có 2 phần. Thiếu một trong hai, chương trình của bạn sẽ \"chết\" ngay lập tức.\n- Điểm dừng (Base Case): Đây là điều kiện để hàm ngừng gọi chính nó. Nếu không có điểm dừng, hàm sẽ gọi mãi mãi dẫn đến lỗi Stack Overflow (Tràn ngăn xếp).\n- Bước đệ quy (Recursive Step): Là lúc hàm gọi lại chính nó nhưng với một tham số mới nhỏ hơn hoặc gần với điểm dừng hơn.',NULL,NULL,'2026-01-29 01:34:04'),(254,46,'theory',1,'Cơ chế vận hành: LIFO và Call Stack','Khác với vòng lặp chạy phẳng, đệ quy hoạt động dựa trên cơ chế **Ngăn xếp (Call Stack)**.\n- Khi hàm gọi chính nó, trình duyệt sẽ \"tạm dừng\" hàm hiện tại, đẩy nó vào ngăn xếp và mở một phiên bản mới của hàm đó.\n- Quá trình này tiếp diễn cho đến khi chạm tới **Base Case**.\n- Lúc này, các hàm sẽ bắt đầu trả về kết quả theo thứ tự **LIFO** (Last In, First Out - Vào sau, ra trước). Hàm cuối cùng được gọi sẽ là hàm đầu tiên hoàn thành.',NULL,NULL,'2026-01-29 01:34:55'),(255,46,'code',1,'Bài toán Giai thừa (n!)','/**\n * Tính giai thừa của n (n!)\n * Công thức: n! = n * (n-1) * (n-2) * ... * 1\n * Quy ước đệ quy: n! = n * (n-1)!\n */\nfunction factorial(n) {\n    // 1. Điểm dừng (Base Case)\n    if (n === 0 || n === 1) {\n        return 1;\n    }\n\n    // 2. Bước đệ quy\n    return n * factorial(n - 1);\n}\n\nconsole.log(factorial(5)); // Kết quả: 120','javascript','Phân tích luồng chạy của factorial(3):\n- factorial(3) gọi 3 * factorial(2)\n- factorial(2) gọi 2 * factorial(1)\n- factorial(1) chạm Base Case, trả về 1\n- Quay ngược lại: 2 * 1 = 2\n- Quay ngược lại: 3 * 2 = 6. Kết quả cuối cùng là 6.','2026-01-29 01:35:48'),(256,46,'theory',1,'Khi nào nên dùng đệ quy?','Đừng dùng đệ quy cho những bài toán cộng trừ đơn giản. Hãy dùng đệ quy khi bạn đối mặt với **Cấu trúc dữ liệu dạng cây (Tree)** hoặc **Dữ liệu phân cấp**.\n\nVí dụ: Duyệt các thư mục trong máy tính (Thư mục -> Thư mục con -> File), hoặc duyệt các menu đa cấp trên website.\nVí dụ: Thuật toán sắp xếp nhanh (Quick Sort) hoặc tìm kiếm nhị phân (Binary Search).',NULL,NULL,'2026-01-29 01:36:21'),(257,46,'theory',1,'Tổng kết bài học','- Đệ quy là hàm tự gọi chính nó.\n- Luôn luôn phải có điểm dừng (Base case).\n- Mỗi bước gọi lại phải tiến gần hơn về điểm dừng.\n- Cẩn thận với hiệu suất nếu dữ liệu quá lớn (đệ quy quá sâu).',NULL,NULL,'2026-01-29 01:36:44'),(258,47,'theory',1,'Tại sao phải vượt qua vòng lặp For?','Trong các bài học trước, chúng ta đã dùng vòng lặp for truyền thống để duyệt mảng. Tuy nhiên, trong môi trường thực tế, việc quản lý các chỉ số *(i=0; i < length; i++)* rất dễ gây ra sai sót \"lệch 1 đơn vị\" (Off-by-one error).\n\nLập trình hiện đại hướng tới tư duy **Khai báo (Declarative)**: Bạn chỉ cần nói cho máy tính biết bạn muốn kết quả là gì, thay vì chỉ dẫn chi tiết từng bước lặp. Các phương thức nâng cao như map, filter, hay reduce không chỉ giúp code ngắn gọn hơn mà còn giúp tách biệt hoàn toàn logic xử lý dữ liệu ra khỏi luồng điều khiển của chương trình.',NULL,NULL,'2026-01-29 01:46:58'),(259,47,'code',1,'Kiểm tra logic tập hợp với Every và Some','const orders = [\n    { id: 1, status: \'shipped\' },\n    { id: 2, status: \'shipped\' },\n    { id: 3, status: \'pending\' }\n];\n\n// 1. every(): Trả về true nếu TẤT CẢ đều thỏa mãn\nconst isAllShipped = orders.every(order => order.status === \'shipped\'); \n// Kết quả: false\n\n// 2. some(): Trả về true nếu ít nhất MỘT phần tử thỏa mãn\nconst hasPending = orders.some(order => order.status === \'pending\'); \n// Kết quả: true','javascript','Hãy coi every là phép toán logic AND và some là phép toán OR trên toàn bộ mảng. Điểm đặc biệt là chúng có cơ chế \"ngắt sớm\" (short-circuiting): every sẽ dừng ngay khi gặp phần tử đầu tiên sai, và some sẽ dừng ngay khi gặp phần tử đầu tiên đúng. Điều này giúp tối ưu hiệu suất cực lớn khi xử lý mảng hàng nghìn phần tử.','2026-01-29 01:47:32'),(260,47,'theory',1,'Tìm kiếm chính xác với Find và Filter','Sự khác biệt giữa Tìm một và Lấy tất cả:\n- find(): Được dùng khi bạn muốn lấy ra duy nhất một thực thể. Ngay khi tìm thấy phần tử thỏa mãn điều kiện, nó sẽ trả về chính phần tử đó và kết thúc việc tìm kiếm. Nếu không thấy, kết quả là undefined. Thường dùng để tìm kiếm theo ID duy nhất.\n- filter(): Được dùng khi bạn muốn \"sàng lọc\" ra một danh sách mới. Nó sẽ đi qua toàn bộ mảng và gom tất cả các phần tử thỏa mãn điều kiện vào một mảng mới. Nếu không có phần tử nào thỏa mãn, nó trả về một mảng rỗng [].',NULL,NULL,'2026-01-29 01:48:18'),(261,47,'code',1,'Map - Nghệ thuật biến hình dữ liệu','const users = [\n    { firstName: \'Sơn\', lastName: \'Đặng\' },\n    { firstName: \'Hoàng\', lastName: \'Trần\' }\n];\n\n// Tạo mảng mới chứa tên đầy đủ\nconst fullNames = users.map(user => {\n    return `${user.firstName} ${user.lastName}`;\n});\n\nconsole.log(fullNames); // [\"Sơn Đặng\", \"Hoàng Trần\"]','javascript','map() không bao giờ làm thay đổi mảng gốc. Nó giống như một dây chuyền sản xuất: bạn đưa nguyên liệu vào một đầu, và nhận lại thành phẩm ở đầu kia với số lượng không đổi. Đây là phương thức cốt lõi để chuyển đổi dữ liệu từ API thành các định dạng hiển thị cho người dùng.','2026-01-29 01:48:37'),(262,47,'theory',1,'Reduce - Sức mạnh của sự tích lũy','reduce() là \"trùm cuối\" của các phương thức mảng. Nhiệm vụ của nó là thu gọn (reduce) một mảng gồm nhiều phần tử về duy nhất một giá trị.\n\nGiá trị này có thể là bất cứ thứ gì: một con số tổng, một chuỗi văn bản, hoặc thậm chí là một Object mới. Chìa khóa để làm chủ reduce là hiểu về initialValue (giá trị khởi tạo). Nếu bạn muốn tính tổng tiền, khởi tạo là 0. Nếu muốn gom nhóm vào đối tượng, khởi tạo là {}.\nCông thức toán học của nó có thể hiểu là: Result = f(f(f(initialValue, item_1), item_2), ...)\n',NULL,NULL,'2026-01-29 01:49:29'),(263,48,'theory',1,'Tư duy về sự ủy thác hành động','Trong đời sống, hãy tưởng tượng bạn đi đặt một ly cà phê. Thay vì đứng chôn chân tại quầy để đợi (làm tắc nghẽn hàng đợi), bạn để lại số điện thoại và ra bàn ngồi làm việc. Khi cà phê xong, nhân viên sẽ gọi lại cho bạn. Số điện thoại của bạn chính là một \"Callback\".\n\nTrong lập trình, Callback đơn giản là một hàm được truyền dưới dạng đối số vào một hàm khác. Thay vì thực thi ngay lập tức, hàm này \"hứa\" sẽ được gọi lại vào một thời điểm thích hợp sau đó. Đây là cách JavaScript quản lý việc \"ủy thác\" công việc: \"Tôi đưa cho anh hành động này, khi nào anh xong việc của anh thì hãy thực hiện hành động của tôi\".',NULL,NULL,'2026-01-29 01:51:47'),(264,48,'theory',1,'Hai điều kiện để một hàm là Callback','Một hàm được coi là Callback khi và chỉ khi nó thỏa mãn đồng thời hai điều kiện sau:\n- Nó được truyền qua đối số của một hàm khác.\n- Nó được thực thi bên trong hàm đó.\n\nJavaScript coi Hàm là First-class citizens (công dân hạng nhất). Điều này có nghĩa là bạn có thể đối xử với một hàm giống như một biến: gán nó vào một biến, lưu nó vào mảng, và quan trọng nhất là truyền nó vào một hàm khác như một tham số.',NULL,NULL,'2026-01-29 01:52:07'),(265,48,'code',1,'Cách truyền và thực thi Callback','// 1. Định nghĩa hàm Callback\nfunction notify(name) {\n    console.log(`Khóa học ${name} đã sẵn sàng!`);\n}\n\n// 2. Định nghĩa hàm nhận Callback\nfunction prepareCourse(courseName, callback) {\n    console.log(`Đang chuẩn bị dữ liệu cho: ${courseName}...`);\n    // Sau khi chuẩn bị xong, thực hiện \"gọi lại\"\n    callback(courseName);\n}\n\n// 3. Thực thi\nprepareCourse(\'Javascript Pro\', notify);','javascript','Ở đây, notify là hàm Callback. Chúng ta truyền tên hàm notify vào hàm prepareCourse. \nLưu ý: ta truyền tên hàm (reference), không phải thực thi hàm bằng cặp ngoặc (). \nHàm prepareCourse đóng vai trò là hàm chủ quản, nó quyết định khi nào thì hàm notify được phép chạy.','2026-01-29 01:52:29'),(266,48,'theory',1,'Tại sao Callback lại quan trọng?','ại sao chúng ta không viết thẳng lệnh console.log vào trong hàm prepareCourse? Câu trả lời là sự linh hoạt. Bằng cách dùng Callback, hàm prepareCourse trở nên đa năng. Hôm nay bạn muốn thông báo qua Console, bạn truyền hàm notify. Ngày mai bạn muốn gửi Email, bạn chỉ cần viết một hàm sendEmail và truyền vào thay thế.\n\nHàm chủ quản không cần quan tâm hành động tiếp theo là gì, nó chỉ cần biết là nó sẽ thực hiện \"lời hứa\" gọi lại hàm mà bạn cung cấp. Đây chính là nền tảng của các phương thức như .map(), .filter() mà bạn đã học ở chương trước.',NULL,NULL,'2026-01-29 01:52:40'),(267,48,'theory',1,'Callback trong lập trình bất đồng bộ','JavaScript là ngôn ngữ đơn luồng (Single-threaded). Nếu một tác vụ tốn 5 giây (như tải ảnh từ server) mà chúng ta bắt trình duyệt đợi, website sẽ bị \"đơ\".\n\nCallback cho phép chúng ta nói với trình duyệt: \"Hãy cứ tải ảnh đi, tôi sẽ làm việc khác. Khi nào tải xong thì hãy chạy hàm Callback này để hiển thị ảnh lên\". Đây là cách JavaScript xử lý hàng triệu yêu cầu cùng lúc mà không bao giờ bị treo máy. Tuy nhiên, nếu lạm dụng quá nhiều Callback lồng nhau, bạn sẽ rơi vào một \"thảm họa\" được gọi là Callback Hell (Địa ngục Callback) mà chúng ta sẽ học cách giải quyết ở các bài sau.',NULL,NULL,'2026-01-29 01:52:51'),(268,48,'theory',1,'Tổng kết bài học','- Callback là hàm được truyền qua tham số.\n- Được gọi lại (execute) bởi một hàm khác.\n- Giúp mã nguồn linh hoạt và có khả năng tái sử dụng cao.\n- Là công cụ chính để xử lý các tác vụ tốn thời gian (bất đồng bộ).\n- Luôn nhớ: truyền hàm (tên hàm), đừng thực thi hàm ngay khi truyền.',NULL,NULL,'2026-01-29 01:53:13'),(269,49,'theory',1,'Tư duy Thợ rèn - Tại sao phải viết lại hàm có sẵn?','Trong quá trình phát triển dự án, chúng ta sử dụng các phương thức mảng hàng ngày. Tuy nhiên, nếu bạn chỉ coi chúng là các \"hộp đen\" nhận đầu vào và trả đầu ra, bạn sẽ gặp khó khăn khi cần xử lý các logic tùy biến phức tạp.\n\nViệc tự viết lại myMap hay myFilter giúp bạn hiểu được sợi dây liên kết giữa Vòng lặp (Loop) và Sự ủy thác (Callback). Bạn sẽ thấy rằng Callback không hề bí ẩn; nó chỉ là một lời gọi hàm được đặt khéo léo bên trong một vòng lặp để xử lý dữ liệu theo ý muốn của người dùng. Đây chính là bước đệm để bạn làm chủ các thư viện lớn sau này.',NULL,NULL,'2026-01-29 01:56:22'),(270,49,'theory',1,'Cơ chế Prototype và sự mở rộng mảng','Để tạo ra một phương thức mà mọi mảng đều có thể sử dụng (ví dụ: [1, 2].myMap()), chúng ta cần can thiệp vào Prototype của đối tượng Array.\n\nHãy tưởng tượng Array.prototype giống như một bản thiết kế gốc của chiếc tủ mảng. Khi bạn thêm một ngăn chức năng mới vào bản thiết kế này, tất cả các chiếc tủ được tạo ra sau đó (hoặc đã tồn tại) đều sẽ sở hữu ngăn chức năng đó. Trong các ví dụ dưới đây, chúng ta sẽ dùng từ khóa this bên trong Prototype để đại diện cho chính mảng đang thực hiện phương thức.',NULL,NULL,'2026-01-29 01:56:35'),(271,49,'code',1,'Tái hiện phương thức myMap','// 1. Định nghĩa phương thức mới trong Prototype của Array\nArray.prototype.myMap = function(callback) {\n    const output = [];\n    const arrayLength = this.length;\n\n    for (let i = 0; i < arrayLength; i++) {\n        // Thực thi callback và đẩy kết quả vào mảng mới\n        const result = callback(this[i], i, this);\n        output.push(result);\n    }\n\n    return output;\n};\n\n// 2. Sử dụng thực tế\nconst numbers = [1, 2, 3];\nconst double = numbers.myMap(num => num * 2);\n\nconsole.log(double); // [2, 4, 6]','javascript','Trong mã nguồn trên, this chính là mảng numbers. Vòng lặp for đóng vai trò là \"động cơ\" duyệt qua từng phần tử. Tại mỗi bước lặp, chúng ta \"nhờ\" hàm callback xử lý phần tử hiện tại (this[i]) và lấy kết quả trả về để đưa vào mảng output. Đây chính là cách map() tạo ra một bản sao mới mà không làm hỏng dữ liệu gốc.','2026-01-29 01:56:57'),(272,49,'theory',1,'Bài toán về các phần tử trống (Empty elements)','Một chi tiết mà ít lập trình viên để ý: Mảng có thể có các \"lỗ hổng\" dữ liệu (ví dụ: [1, , 3]). Các phương thức mảng chuẩn của JavaScript như forEach hay map sẽ tự động bỏ qua các ngăn tủ trống này thay vì trả về undefined.\n\nKhi tự viết lại các phương thức này, chúng ta cần sử dụng phương thức hasOwnProperty() để kiểm tra xem tại chỉ số i đó có thực sự chứa dữ liệu hay không. Việc xử lý tinh tế các trường hợp biên (edge cases) như thế này chính là điểm khác biệt giữa một lập trình viên nghiệp dư và một chuyên gia thực thụ.',NULL,NULL,'2026-01-29 01:57:15'),(273,49,'code',1,'Logic sàng lọc dữ liệu với Callback - myFilter','Array.prototype.myFilter = function(callback) {\n    const output = [];\n\n    for (let index in this) {\n        // for...in chỉ duyệt qua các phần tử thực sự tồn tại (has property)\n        if (this.hasOwnProperty(index)) {\n            const isValid = callback(this[index], index, this);\n            \n            // Nếu callback trả về true, mới thêm vào mảng kết quả\n            if (isValid) {\n                output.push(this[index]);\n            }\n        }\n    }\n\n    return output;\n};\n\nconst shortWords = [\'apple\', \'banana\', \'cat\'].myFilter(word => word.length < 5);\nconsole.log(shortWords); // [\'apple\', \'cat\']','javascript','Khác với myMap, myFilter sử dụng kết quả của Callback (isValid) như một chiếc \"vé thông hành\". Chỉ những phần tử nào được Callback \"cho phép\" (trả về giá trị Truthy) mới được đưa vào mảng kết quả. Việc sử dụng vòng lặp for...in kết hợp hasOwnProperty giúp chúng ta tối ưu hiệu suất bằng cách bỏ qua các phần tử trống một cách tự động.','2026-01-29 01:57:49'),(274,49,'theory',1,'Tổng kết và tư duy làm chủ','- Tư duy Prototype: Hiểu rằng bạn có thể mở rộng ngôn ngữ theo ý mình.\n- Tư duy Callback: Coi Callback là một bản hợp đồng logic mà bạn ủy thác cho hàm khác thực thi.\n- Xử lý mảng thực tế: Luôn nhớ kiểm tra tính tồn tại của dữ liệu để tránh các lỗi logic không đáng có. Khi bạn đã có thể tự viết lại toàn bộ thư viện mảng, việc sử dụng các Framework như React hay Express.js sẽ trở nên cực kỳ dễ dàng vì bạn đã nắm thấu \"linh hồn\" của Javascript.',NULL,NULL,'2026-01-29 01:58:08'),(275,50,'theory',1,'Tư duy Tìm kiếm sự hiện diện (mySome)','Phương thức some() hoạt động giống như một chiếc chuông báo động. Nhiệm vụ của nó không phải là kiểm tra toàn bộ danh sách một cách máy móc, mà là đi tìm bằng chứng đầu tiên thỏa mãn điều kiện.\n\nTrong thực tế, nếu bạn kiểm tra xem trong giỏ hàng có sản phẩm nào là \"Hàng dễ vỡ\" hay không, ngay khi tìm thấy món đồ đầu tiên có nhãn này, bạn sẽ dừng lại và dán nhãn cảnh báo cho cả kiện hàng. Bạn không cần phí sức kiểm tra 99 món đồ còn lại. Đó chính là cơ chế Ngắt sớm (Short-circuiting) – bí quyết để some() hoạt động cực nhanh trên các tập dữ liệu khổng lồ.',NULL,NULL,'2026-01-29 02:00:02'),(276,50,'code',1,'','Array.prototype.mySome = function(callback) {\n    // Duyệt qua từng index trong mảng\n    for (let index in this) {\n        if (this.hasOwnProperty(index)) {\n            // Nếu tìm thấy 1 phần tử thỏa mãn (true)\n            if (callback(this[index], index, this)) {\n                return true; // Dừng vòng lặp và trả về true ngay lập tức\n            }\n        }\n    }\n    // Duyệt hết mảng mà không thấy ai đúng\n    return false;\n};\n\nconst numbers = [1, 3, 5, 8, 11];\n// Kiểm tra xem có số chẵn nào không\nconst hasEven = numbers.mySome(num => num % 2 === 0);\n\nconsole.log(hasEven); // true (Dừng lại ngay khi gặp số 8)','javascript','Lệnh return true đặt bên trong vòng lặp chính là \"nút ngắt\". Nó giúp thoát khỏi hàm ngay khi điều kiện được thỏa mãn. Việc sử dụng for...in kết hợp hasOwnProperty giúp chúng ta bảo vệ mã nguồn khỏi các phần tử trống (empty slots), đảm bảo Callback chỉ được thực thi trên các dữ liệu thực tế.','2026-01-29 02:00:15'),(277,50,'theory',1,'Tư duy Kiểm soát tuyệt đối (myEvery)','Ngược lại với some(), phương thức every() đóng vai trò như một người giám thị nghiêm khắc. Nó đòi hỏi sự hoàn hảo tuyệt đối: Tất cả phần tử phải vượt qua bài kiểm tra.\n\nTuy nhiên, cách tiếp cận của nó rất thông minh: Thay vì đi tìm cái đúng, nó đi tìm cái sai đầu tiên. Nếu bạn kiểm tra xem tất cả học sinh đã đóng học phí chưa, ngay khi gặp người đầu tiên chưa đóng, bạn kết luận ngay là \"Chưa hoàn tất\" và dừng việc kiểm tra. every() chỉ trả về true khi nó đã đi đến cuối mảng mà không bắt gặp bất kỳ sự thất bại nào.',NULL,NULL,'2026-01-29 02:00:30'),(278,50,'code',1,'','Array.prototype.myEvery = function(callback) {\n    let result = true; // Giả định ban đầu là tất cả đều đúng\n\n    for (let index in this) {\n        if (this.hasOwnProperty(index)) {\n            // Nếu gặp bất kỳ ai không thỏa mãn (false)\n            if (!callback(this[index], index, this)) {\n                result = false;\n                break; // Thoát khỏi vòng lặp ngay lập tức\n            }\n        }\n    }\n\n    return result;\n};\n\nconst students = [\n    { name: \'An\', point: 8 },\n    { name: \'Bình\', point: 4 }, // Điểm dưới trung bình\n    { name: \'Chi\', point: 9 }\n];\n\n// Kiểm tra tất cả có đỗ không (điểm > 5)\nconst isAllPassed = students.myEvery(s => s.point > 5);\nconsole.log(isAllPassed); // false','javascript','Ở đây chúng ta dùng từ khóa break. Khi Callback trả về một giá trị falsy, chúng ta lật biến result thành false và \"bẻ gãy\" vòng lặp. Điều này giúp tối ưu tài nguyên vì chúng ta không cần kiểm tra các phần tử phía sau khi đã biết chắc kết quả cuối cùng là thất bại.','2026-01-29 02:00:45'),(279,50,'theory',1,'Khi nào dùng Some, khi nào dùng Every?','Để lựa chọn đúng phương thức, hãy đặt câu hỏi cho mục tiêu của bạn:\n- Nếu bạn đang tìm kiếm ngoại lệ, tìm kiếm một dấu hiệu tích cực trong đám đông: Hãy dùng some().\n- Nếu bạn đang cần sự đảm bảo đồng nhất, xác thực tính hợp lệ toàn diện: Hãy dùng every().\n\nHiểu được cơ chế \"ngắt sớm\" của hai hàm này sẽ giúp bạn viết nên những đoạn mã xử lý dữ liệu cực kỳ tinh tế, chuyên nghiệp và tiết kiệm tài nguyên bộ nhớ cho trình duyệt.',NULL,NULL,'2026-01-29 02:01:10'),(280,51,'theory',1,'Cầu nối giữa mã nguồn và giao diện','Hãy tưởng tượng HTML là khung xương của một ngôi nhà, còn JavaScript là người thợ điện. Vấn đề là: Làm thế nào để người thợ điện (JS) có thể chạm vào và điều khiển các thiết bị trong ngôi nhà (HTML) khi hai thực thể này hoàn toàn khác biệt?\n\n**HTML DOM (Document Object Model)** chính là câu trả lời. Nó là một giao diện lập trình (API) đóng vai trò là \"bản dịch\". Khi trình duyệt tải một trang HTML, nó sẽ tự động chuyển đổi toàn bộ cấu trúc mã đó thành một mô hình các đối tượng (Object). Nhờ có DOM, JavaScript có thể \"nhìn\" thấy HTML dưới dạng các Object quen thuộc và bắt đầu thực hiện các quyền năng của mình như: thay đổi màu sắc, ẩn/hiện nội dung, hoặc tạo ra các hiệu ứng chuyển động.',NULL,NULL,'2026-01-29 02:02:52'),(281,51,'theory',1,'Cấu trúc hình cây (The DOM Tree)','Một đặc điểm cốt lõi của HTML là tính lồng nhau (nesting). Thẻ <body> chứa thẻ <div>, thẻ <div> lại chứa thẻ <h1>. Để mô phỏng sự phân cấp này, DOM tổ chức dữ liệu theo sơ đồ Cây (Tree).\n\nTrong cây DOM:\n- **Gốc (Root)**: Luôn là đối tượng document, đại diện cho toàn bộ trang web.\n- **Nút (Node)**: Mỗi thành phần trong HTML (từ thẻ tag, thuộc tính cho đến một đoạn văn bản) đều được coi là một \"nút\" trên cây.\n- **Quan hệ**: Các nút được liên kết với nhau theo quan hệ Cha (Parent), Con (Child) và Anh em (Sibling). Hiểu được sơ đồ cây này là chìa khóa để bạn có thể \"du hành\" đến bất kỳ vị trí nào trên trang web để sửa đổi dữ liệu.',NULL,NULL,'2026-01-29 02:03:33'),(282,51,'theory',1,'3 Thành phần chính của một Element trong DOM','Khi JavaScript truy cập vào một thẻ HTML thông qua DOM, nó sẽ nhìn thấy 3 thành phần riêng biệt mà bạn có thể tác động:\n- Element Node: Chính là bản thân thẻ HTML (ví dụ: <a>, <h1>, <div>).\n- Attribute Node: Các thuộc tính nằm bên trong thẻ (ví dụ: href, src, class, id).\n- Text Node: Phần nội dung văn bản nằm giữa thẻ đóng và thẻ mở.\n\nViệc tách bạch 3 thành phần này cho phép bạn kiểm soát chi tiết tuyệt đối: Bạn có thể vừa thay đổi chữ hiển thị (Text), vừa đổi màu sắc (Attribute/Style) mà vẫn giữ nguyên cấu trúc thẻ (Element).',NULL,NULL,'2026-01-29 02:03:56'),(283,51,'code',1,'Sức mạnh của JavaScript thông qua DOM','// DOM cho phép JS truy cập vào một thẻ HTML bằng ID\nconst heading = document.getElementById(\'main-title\');\n\n// JS có thể đổi nội dung văn bản (Text)\nheading.innerText = \'Chào mừng bạn đến với CodePulse!\';\n\n// JS có thể đổi màu sắc (Style - một dạng Attribute)\nheading.style.color = \'blue\';\n\n// JS có thể lắng nghe hành động của người dùng\nheading.onclick = function() {\n    alert(\'Bạn vừa click vào tiêu đề!\');\n};','javascript','Trong đoạn mã trên, document chính là điểm bắt đầu của DOM. Phương thức getElementById giúp chúng ta \"nhắm\" trúng mục tiêu trên cây DOM. Sau khi đã nắm giữ được đối tượng đó, chúng ta có toàn quyền thay đổi thuộc tính hoặc gán cho nó các hành động (Event) như onclick. Đây là nền tảng của mọi trang web tương tác hiện nay.','2026-01-29 02:04:15'),(284,51,'theory',1,'Tổng kết bài học','- DOM không phải là HTML, nó là đại diện của HTML dưới dạng Object.\n- DOM được trình duyệt tạo ra ngay khi trang web được tải.\n- Cấu trúc DOM là cấu trúc hình cây với quan hệ Cha - Con chặt chẽ.\n- JavaScript dùng DOM làm \"cầu nối\" để giao tiếp và thay đổi giao diện.\n- Mọi thành phần trên trang web (thẻ, thuộc tính, văn bản) đều là các Node trong DOM.',NULL,NULL,'2026-01-29 02:04:43'),(285,52,'theory',1,'Tư duy phân biệt khái niệm','Trong thế giới lập trình, chúng ta thường nghe cả hai thuật ngữ này. Hãy tưởng tượng bạn đang lắp ráp một mô hình Lego:\n- HTML DOM: Chính là mô hình hoàn thiện mà bạn nhìn thấy trên sách hướng dẫn. Nó quy định mảnh nào gắn với mảnh nào, mảnh nào là con của mảnh nào.\n- DOM API: Chính là đôi tay và các dụng cụ của bạn. Nó cho phép bạn nhấc một mảnh ra, gắn thêm mảnh mới, hoặc đổi màu cho một khối gạch.\n\nNói cách khác, HTML DOM là kết quả (mô hình dữ liệu), còn DOM API là phương tiện (tập hợp các hàm/phương thức) để chúng ta chạm vào kết quả đó.',NULL,NULL,'2026-01-29 02:06:12'),(286,52,'theory',1,'HTML DOM - Chuẩn mực về cấu trúc','HTML DOM (Document Object Model) là một quy chuẩn được đưa ra bởi W3C. Nó định nghĩa trang web dưới dạng một cây đối tượng bất biến về mặt logic. Nó quy định rằng:\n- Mọi thẻ HTML đều là một Element.\n- Mọi nội dung bên trong thẻ là Text.\n- Mọi thuộc tính của thẻ là Attribute.\n\nKhi bạn nói \"Tôi đang tìm hiểu về cấu trúc DOM\", nghĩa là bạn đang nghiên cứu về cách các thẻ HTML lồng nhau và phân cấp như thế nào trong bộ nhớ trình duyệt.',NULL,NULL,'2026-01-29 02:06:34'),(287,52,'theory',1,'DOM API - Cánh tay nối dài của JavaScript','API (Application Programming Interface) là một tập hợp các quy tắc và cơ chế mà một ứng dụng (ở đây là trình duyệt) cung cấp cho ứng dụng khác (JavaScript) để tương tác.\n\nDOM API chính là danh sách các \"lệnh\" mà trình duyệt cho phép JavaScript sử dụng. Các hàm quen thuộc như document.querySelector(), element.addEventListener(), hay thuộc tính element.innerHTML thực chất đều thuộc về DOM API. JavaScript bản thân nó không biết HTML là gì; nó chỉ biết gọi các hàm từ DOM API để yêu cầu trình duyệt thực hiện thay đổi.',NULL,NULL,'2026-01-29 02:06:46'),(288,52,'code',1,'API tương tác với mô hình DOM','// 1. Chúng ta dùng DOM API (phương thức querySelector) \n// để truy cập vào một nút trên cây HTML DOM\nconst btn = document.querySelector(\'.submit-btn\');\n\n// 2. Chúng ta dùng thuộc tính của API để thay đổi trạng thái \n// của đối tượng trong mô hình DOM\nbtn.disabled = true; \nbtn.textContent = \'Đang xử lý...\';\n\n// 3. Chúng ta dùng API để can thiệp vào hành vi\nbtn.onclick = () => console.log(\'Đã cập nhật DOM!\');','javascript','Trong ví dụ này, document.querySelector là một công cụ thuộc DOM API. Nó đi vào HTML DOM (cái cây đang hiển thị trên màn hình) để tìm đúng đối tượng có class là .submit-btn. Sau khi tìm thấy, chúng ta lại dùng các thuộc tính API khác như disabled và textContent để cập nhật lại trạng thái cho đối tượng đó ngay trên giao diện.','2026-01-29 02:07:03'),(289,52,'theory',1,'Bảng đối chiếu nhanh','- HTML DOM: Là cái cây, là sơ đồ tổ chức, là đối tượng tĩnh trong bộ nhớ.\n- DOM API: Là các hàm, là phương thức, là hành động tương tác động.\n- Mối quan hệ: JavaScript sử dụng DOM API để thao tác trên HTML DOM.\n\nHiểu rõ sự phân tách này giúp bạn nhận ra rằng: DOM không thuộc về JavaScript. DOM là của trình duyệt, và JavaScript chỉ là một trong những ngôn ngữ có thể sử dụng API để điều khiển nó.',NULL,NULL,'2026-01-29 02:07:26'),(291,54,'theory',1,'Định nghĩa về đối tượng Document','Trong môi trường trình duyệt, document là một đối tượng toàn cục (global object) đại diện cho toàn bộ trang HTML đang được hiển thị. Nó chính là nút gốc (Root Node) của cây DOM.\n\nTất cả các thành phần khác như thẻ <html>, <head>, <body>, các đoạn văn, hình ảnh... đều là \"con\" hoặc \"cháu\" nằm bên trong đối tượng document. Mọi thao tác JavaScript muốn can thiệp vào giao diện đều phải bắt đầu bằng từ khóa document. Nếu không có đối tượng này, JavaScript sẽ hoàn toàn bị \"cô lập\" và không thể tương tác với thế giới bên ngoài.',NULL,NULL,'2026-01-29 02:09:09'),(292,54,'code',1,'Truy xuất thông tin cơ bản của trang web','// 1. Lấy tiêu đề của trang web\nconsole.log(document.title); \n\n// 2. Thay đổi tiêu đề trang web ngay lập tức\ndocument.title = \'CodePulse - Học lập trình thực chiến\';\n\n// 3. Lấy địa chỉ URL hiện tại\nconsole.log(document.URL);\n\n// 4. Kiểm tra bộ mã hóa ngôn ngữ\nconsole.log(document.characterSet); // Thường là UTF-8','javascript','Đối tượng document chứa sẵn các thuộc tính giúp bạn đọc và ghi các thông tin mang tính \"toàn trang\". Ví dụ, việc thay đổi document.title sẽ làm tiêu đề trên tab trình duyệt thay đổi ngay lập tức mà không cần tải lại trang. Đây là cách các ứng dụng hiện đại cập nhật thông báo hoặc trạng thái cho người dùng.','2026-01-29 02:09:30'),(293,54,'theory',1,'Lối tắt truy cập các thành phần nòng cốt Head và Body','Thay vì phải dùng các bộ lọc phức tạp để tìm kiếm, document cung cấp các lối tắt trực tiếp để bạn chạm vào những phần quan trọng nhất của trang web:\n- document.head: Truy cập vào phần đầu trang, nơi chứa các thẻ meta, link CSS và script.\n- document.body: Truy cập vào phần thân trang, nơi chứa toàn bộ nội dung hiển thị cho người dùng.\n- document.documentElement: Truy cập thẳng vào thẻ <html> - cấp cao nhất của tài liệu.\n\nViệc sử dụng các lối tắt này giúp mã nguồn của bạn chạy nhanh hơn và ngắn gọn hơn khi cần thực hiện các thao tác diện rộng như đổi màu nền trang web hoặc thêm các thẻ SEO động.',NULL,NULL,'2026-01-29 02:10:01'),(294,54,'code',1,'Quyền năng khởi tạo và ghi dữ liệu','// 1. Ghi nội dung trực tiếp ra luồng tài liệu\ndocument.write(\'Chào mừng bạn đến với bài học Document!\');\n\n// 2. Tạo ra một thẻ <h1> mới hoàn toàn trong bộ nhớ\nconst newHeading = document.createElement(\'h1\');\nnewHeading.innerText = \'Phần tử được tạo từ JS\';\n\n// 3. Đưa phần tử mới vào trong thẻ body để hiển thị\ndocument.body.appendChild(newHeading);','javascript','document không chỉ dùng để xem, mà còn dùng để xây dựng. Phương thức createElement cho phép bạn tạo ra bất kỳ thẻ HTML nào ngay trong bộ nhớ JavaScript. Tuy nhiên, phần tử này sẽ \"vô hình\" cho đến khi bạn dùng các hàm như appendChild để gắn nó vào một vị trí cụ thể trên cây DOM. Lưu ý: document.write thường chỉ dùng để thử nghiệm nhanh vì nó có thể ghi đè toàn bộ trang web nếu gọi không đúng lúc.','2026-01-29 02:10:22'),(295,54,'theory',1,'Tổng kết bài học','- document là đối tượng đại diện cho toàn bộ trang web.\n- Nó là nút gốc duy nhất, chứa tất cả các phần tử khác.\n- Cung cấp các thuộc tính để quản lý thông tin chung (title, URL, domain).\n- Cung cấp các lối tắt để truy cập nhanh các vùng quan trọng (head, body).\n- Là công cụ chính để tạo mới, xóa bỏ hoặc chỉnh sửa các Node trên giao diện.',NULL,NULL,'2026-01-29 02:10:44'),(296,55,'theory',1,'Tại sao cần nhiều phương thức truy xuất khác nhau?','Trong một trang web phức tạp với hàng nghìn thẻ HTML, việc tìm đúng phần tử cần thao tác giống như việc tìm một người trong một thành phố lớn. JavaScript cung cấp cho chúng ta nhiều \"chiến thuật\" tìm kiếm: tìm theo tên khai sinh (ID), tìm theo đặc điểm nhận dạng (Class), hoặc tìm theo địa chỉ chính xác (CSS Selector).\n\nViệc lựa chọn đúng phương thức không chỉ giúp mã nguồn của bạn chạy nhanh hơn mà còn giúp code trở nên tường minh, dễ hiểu cho các lập trình viên khác khi đọc vào. Chúng ta sẽ đi từ những phương thức cổ điển, hiệu suất cao đến những phương thức hiện đại, linh hoạt.',NULL,NULL,'2026-01-29 02:12:04'),(297,55,'code',1,'Các phương thức truy xuất cổ điển (Legacy Methods)','// 1. getElementById: Tìm theo ID duy nhất\n// Trả về duy nhất 1 phần tử hoặc null\nconst header = document.getElementById(\'main-header\');\n\n// 2. getElementsByClassName: Tìm theo tên Class\n// Trả về một HTMLCollection (giống mảng nhưng không phải mảng)\nconst items = document.getElementsByClassName(\'list-item\');\n\n// 3. getElementsByTagName: Tìm theo tên thẻ HTML\nconst paragraphs = document.getElementsByTagName(\'p\');','javascript','getElementById là phương thức có hiệu suất cao nhất vì trình duyệt quản lý ID theo cơ chế băm (hash), giúp tìm kiếm gần như tức thời. Các phương thức có chữ s ở cuối (Elements) luôn trả về một HTMLCollection. Lưu ý: HTMLCollection là một danh sách \"sống\" (live collection) — nếu bạn thêm một phần tử mới vào HTML, danh sách này sẽ tự động cập nhật mà không cần gọi lại hàm.','2026-01-29 02:12:24'),(298,55,'theory',1,'Sức mạnh của CSS Selector trong JavaScript','Nếu các phương thức cũ buộc bạn phải nhớ từng hàm riêng biệt, thì querySelector và querySelectorAll cho phép bạn dùng chung một cú pháp duy nhất: CSS Selector.\n\nBất kỳ cách nào bạn viết để định dạng CSS (như .box #title, ul > li:first-child, input[type=\"text\"]), bạn đều có thể dùng nó để nhắm mục tiêu trong JavaScript. Đây là phương thức linh hoạt nhất, cho phép bạn truy cập sâu vào các cấu trúc lồng nhau phức tạp mà các phương thức cổ điển rất khó thực hiện.',NULL,NULL,'2026-01-29 02:12:37'),(299,55,'code',1,'','// 1. querySelector: Lấy phần tử ĐẦU TIÊN thỏa mãn\nconst firstBtn = document.querySelector(\'.container .btn-primary\');\n\n// 2. querySelectorAll: Lấy TẤT CẢ các phần tử thỏa mãn\n// Trả về một NodeList\nconst allCheckboxes = document.querySelectorAll(\'input[type=\"checkbox\"]\');\n\n// Thực hành duyệt qua NodeList (NodeList hỗ trợ forEach)\nallCheckboxes.forEach(checkbox => {\n    console.log(checkbox.value);\n});','javascript','querySelector cực kỳ hữu ích khi bạn chỉ cần tương tác với một phần tử duy nhất (như nút Submit hoặc ô Search). querySelectorAll trả về một NodeList. Khác với HTMLCollection, NodeList là một danh sách \"tĩnh\" (static collection) — nó không tự cập nhật nếu HTML thay đổi, nhưng nó lại rất tiện lợi vì hỗ trợ sẵn phương thức .forEach(), giúp bạn duyệt qua danh sách cực kỳ nhanh chóng.','2026-01-29 02:12:50'),(300,55,'theory',1,'So sánh HTMLCollection và NodeList','Đây là điểm dễ gây nhầm lẫn nhất cho người mới bắt đầu. Cả hai đều trông giống mảng (đều có thuộc tính .length và có thể truy cập bằng [index]), nhưng chúng không phải là mảng thực thụ:\n- HTMLCollection: Chỉ chứa các Element Node. Không thể dùng forEach, map, filter. Muốn dùng phải chuyển đổi qua mảng bằng Array.from().\n- NodeList: Có thể chứa cả Text Node, Comment Node. Hỗ trợ phương thức forEach (trong hầu hết trình duyệt hiện đại).\n\n**Kinh nghiệm thực tế**: Luôn ưu tiên dùng querySelector và querySelectorAll cho các logic phức tạp vì sự linh hoạt và tính nhất quán với CSS. Chỉ dùng getElementById khi bạn thực sự cần tối ưu hiệu suất tối đa cho một phần tử duy nhất.',NULL,NULL,'2026-01-29 02:13:11'),(301,55,'theory',1,'Tổng kết và Tư duy lựa chọn','- Chỉ cần lấy 1 phần tử theo ID? -> getElementById.\n- Muốn dùng CSS Selector linh hoạt? -> querySelector.\n- Muốn lấy danh sách và dùng forEach ngay? -> querySelectorAll.\n- Muốn lấy danh sách \"sống\" tự cập nhật? -> getElementsByClassName. Làm chủ được các phương thức này là bạn đã hoàn thành 50% công việc của một lập trình viên Front-end khi tương tác với giao diện.',NULL,NULL,'2026-01-29 02:13:48'),(302,56,'theory',1,'Bản chất của Sự kiện (Events)','Hãy tưởng tượng trang web của bạn là một cơ thể người. Các phần tử HTML là cơ bắp, nhưng nếu không có hệ thần kinh để nhận diện cảm giác, cơ thể đó sẽ hoàn toàn tê liệt. DOM Events chính là hệ thần kinh đó.\n\nMỗi khi người dùng thực hiện một hành động (Click chuột, cuộn trang, gõ phím), trình duyệt sẽ phát ra một \"tín hiệu\" sự kiện. Nhiệm vụ của lập trình viên là thiết lập các \"trạm thu phát\" để bắt lấy những tín hiệu này và đưa ra phản hồi tương ứng. Hiểu về sự kiện không chỉ là biết cách viết code cho cái nút chạy, mà là hiểu cách trình duyệt quản lý sự tương tác giữa người dùng và tài liệu HTML.',NULL,NULL,'2026-01-29 06:48:11'),(303,56,'code',1,'Tương tác với Click và Input','// 1. Lấy ra các phần tử cần tương tác\nconst inputE = document.querySelector(\'input[type=\"text\"]\');\nconst btnE = document.querySelector(\'.btn-submit\');\n\n// 2. Lắng nghe sự kiện thay đổi dữ liệu (oninput)\ninputE.oninput = function(e) {\n    console.log(\'Dữ liệu đang nhập:\', e.target.value);\n};\n\n// 3. Lắng nghe sự kiện click\nbtnE.onclick = function(e) {\n    console.log(\'Người dùng đã nhấn nút gửi!\');\n    console.log(\'Tọa độ click:\', e.clientX, e.clientY);\n};','javascript','Trong ví dụ này, tham số e (thường gọi là Event Object) chứa toàn bộ \"hồ sơ\" của sự kiện đó. e.target chính là phần tử phát ra tín hiệu, giúp bạn lấy được dữ liệu chính xác mà không cần truy xuất lại DOM. Đây là cách làm việc trực tiếp và nhanh chóng cho các tương tác đơn giản.','2026-01-29 06:49:01'),(304,56,'theory',1,'Cơ chế \"Nổi bọt\" sự kiện (Event Bubbling)','Một đặc điểm cực kỳ quan trọng nhưng hay bị lãng quên: Sự kiện trong DOM có tính chất \"nổi bọt\". Khi bạn click vào một chiếc nút nằm trong một thẻ div, không chỉ chiếc nút đó nhận được sự kiện click, mà cả thẻ div cha, rồi đến thẻ body, và cuối cùng là đối tượng window cũng sẽ cảm nhận được cú click đó.\n\nSự kiện sẽ đi từ dưới lên trên giống như những bọt khí trong nước. Điều này rất hữu ích khi bạn muốn quản lý hàng nghìn phần tử con chỉ bằng một hàm xử lý ở thẻ cha (Event Delegation). Tuy nhiên, đôi khi nó lại gây ra phiền toái khi các hành động chồng chéo lên nhau. Để ngăn chặn sự lan tỏa này, chúng ta sử dụng phương thức e.stopPropagation().',NULL,NULL,'2026-01-29 06:49:15'),(305,56,'code',1,'Kiểm soát hành vi mặc định (PreventDefault)','const linkE = document.querySelector(\'a\');\n\nlinkE.onclick = function(e) {\n    // Ngăn chặn hành vi mặc định của thẻ <a> (không cho chuyển trang)\n    e.preventDefault();\n\n    if (confirm(\'Bạn có chắc muốn rời khỏi trang này?\')) {\n        window.location.href = e.target.href;\n    }\n};','javascript','Trình duyệt có những hành vi \"mặc định\" đã được lập trình sẵn: Thẻ <a> thì phải chuyển trang, thẻ <form> thì phải tải lại trang khi submit. e.preventDefault() là công cụ mạnh mẽ cho phép bạn \"tạm dừng\" các quy tắc đó để thực hiện logic riêng của mình (như kiểm tra dữ liệu đầu vào trước khi thực sự gửi đi). Đây chính là bí quyết để tạo ra các ứng dụng Single Page Application (SPA) mượt mà.','2026-01-29 06:49:32'),(306,56,'code',1,'Event Listener - Phong cách lập trình chuyên nghiệp','const btn = document.querySelector(\'#action-btn\');\n\nfunction work1() { console.log(\'Việc 1\'); }\nfunction work2() { console.log(\'Việc 2\'); }\n\n// 1. Có thể gán nhiều hành động cùng lúc cho 1 sự kiện\nbtn.addEventListener(\'click\', work1);\nbtn.addEventListener(\'click\', work2);\n\n// 2. Có thể gỡ bỏ hành động bất cứ lúc nào\nsetTimeout(() => {\n    btn.removeEventListener(\'click\', work1);\n    console.log(\'Đã gỡ bỏ Việc 1 sau 3 giây\');\n}, 3000);','javascript','So với cách viết onclick truyền thống, addEventListener mang lại hai quyền năng thượng đẳng:\n- Đa nhiệm: Bạn có thể gán vô số hàm xử lý cho cùng một sự kiện mà không sợ bị ghi đè.\n- Kiểm soát vòng đời: Bạn có thể gỡ bỏ (remove) sự kiện khi nó không còn cần thiết, giúp giải phóng bộ nhớ và tránh các lỗi logic tiềm ẩn khi ứng dụng chạy lâu dài.','2026-01-29 06:50:06'),(307,56,'theory',1,'Tổng kết bài học','- Event Object: Luôn tận dụng tham số e để lấy dữ liệu mục tiêu.\n- Bubbling: Nhớ rằng sự kiện luôn nổi bọt lên cha, dùng stopPropagation nếu cần ngắt mạch.\n- PreventDefault: Sử dụng để kiểm soát các hành vi mặc định của form và link.\n- EventListener: Luôn ưu tiên dùng addEventListener trong các dự án thực tế để đảm bảo tính mở rộng và dễ bảo trì. Làm chủ được chương này, bạn đã chính thức bước chân vào hàng ngũ những lập trình viên Front-end thực thụ, những người có khả năng điều khiển mọi tương tác trên trang web.',NULL,NULL,'2026-01-29 06:50:28'),(308,57,'theory',1,'JSON là gì?','JSON (JavaScript Object Notation) là một định dạng dữ liệu dựa trên văn bản. Mặc dù xuất thân từ JavaScript, nhưng hiện nay JSON đã trở thành tiêu chuẩn vàng để trao đổi dữ liệu giữa các ngôn ngữ lập trình khác nhau (như từ Server viết bằng PHP, C# gửi về Client viết bằng Javascript).\n\nHãy coi JSON là một \"bản dịch\" tối giản của đối tượng JavaScript. Nó chỉ chứa dữ liệu dưới dạng các cặp key: value. Trong JSON, tất cả các key và giá trị kiểu chuỗi bắt buộc phải nằm trong dấu ngoặc kép đôi \"\". JSON không chứa các hàm (method) hay logic phức tạp, nó chỉ đơn thuần là dữ liệu thô để vận chuyển qua môi trường internet.',NULL,NULL,'2026-01-29 06:54:10'),(309,57,'code',1,'Hai phương thức đóng gói và giải mã JSON','// 1. Giả sử ta có một Object JavaScript (Dữ liệu sống)\nconst user = {\n    name: \"Hoàng\",\n    age: 25\n};\n\n// 2. Chuyển thành chuỗi JSON để gửi đi (Đóng gói)\nconst jsonString = JSON.stringify(user);\nconsole.log(typeof jsonString); // \"string\"\nconsole.log(jsonString); // \'{\"name\":\"Hoàng\",\"age\":25}\'\n\n// 3. Nhận chuỗi JSON từ Server và chuyển lại thành Object (Giải mã)\nconst objectData = JSON.parse(jsonString);\nconsole.log(objectData.name); // \"Hoàng\"','javascript','JSON.stringify() giúp bạn biến các biến số phức tạp thành một chuỗi văn bản đơn giản để máy tính có thể \"ném\" đi qua dây cáp mạng. Ngược lại, JSON.parse() giúp bạn biến chuỗi văn bản nhận được thành một đối tượng JavaScript thực thụ để bạn có thể truy cập thuộc tính như object.name.','2026-01-29 06:54:42'),(310,57,'theory',1,'Đồng bộ (Sync) vs Bất đồng bộ (Async)','Đồng bộ (Synchronous): Code chạy từ trên xuống dưới, việc trước xong mới đến việc sau. Giống như bạn xếp hàng mua vé: người trước chưa mua xong, bạn không được tiến lên. Nếu một việc tốn 10 giây (như tải ảnh), toàn bộ trang web sẽ \"đứng hình\" trong 10 giây đó.\n\nBất đồng bộ (Asynchronous): Cho phép các việc tốn thời gian chạy ở \"nền\". JavaScript sẽ ra lệnh cho trình duyệt: \"Hãy tải bức ảnh này đi, khi nào xong thì báo tôi, tôi đi làm việc khác đây\". Nhờ vậy, người dùng vẫn có thể cuộn trang, nhấn nút trong khi ảnh đang được tải. Đây là tư duy cốt lõi để tạo ra các ứng dụng mượt mà.\n\nKhi các hành động bất đồng bộ lồng nhau - Nỗi đau mang tên Callback Hell',NULL,NULL,'2026-01-29 06:54:54'),(311,57,'code',1,'','// Giả lập việc lấy dữ liệu lồng nhau (Địa ngục Callback)\ngetStudent(id, (student) => {\n    getCourse(student.courseId, (course) => {\n        getLesson(course.lessonId, (lesson) => {\n            console.log(lesson.name);\n            // Cấu trúc phân cấp hình tam giác này cực kỳ khó đọc và debug\n        });\n    });\n});','javascript','Khi một hành động bất đồng bộ phụ thuộc vào kết quả của hành động trước đó, chúng ta thường lồng các Callback vào nhau. Nếu lồng quá sâu, bạn sẽ tạo ra một \"kim tự tháp\" code (Pyramid of Doom), khiến việc quản lý lỗi trở nên cực kỳ khủng khiếp. Đây chính là lý do tại sao chúng ta cần đến Promise - chủ đề của bài học tiếp theo.','2026-01-29 06:55:40'),(312,57,'theory',1,'Tại sao bài học này lại quan trọng?','Hiểu về JSON và Async là bạn đã nắm được \"giao thức\" và \"cách vận hành\" của internet hiện đại. Bạn không còn viết code cho một chiếc máy tính đơn lẻ, mà đang viết code để máy tính đó giao tiếp với toàn thế giới. Việc làm chủ tư duy bất đồng bộ sẽ giúp bạn giải quyết các bài toán về hiệu suất và trải nghiệm người dùng — những kỹ năng giúp bạn tách biệt hoàn toàn với những lập trình viên nghiệp dư.',NULL,NULL,'2026-01-29 06:55:56'),(313,58,'theory',1,'Lời hứa (Promise) là gì?','Trong cuộc sống, một lời hứa đại diện cho một kết quả sẽ xảy ra trong tương lai. Khi ai đó hứa với bạn một điều gì đó, tại thời điểm hứa, kết quả vẫn chưa có. Bạn phải đợi.\n\nTrong JavaScript, Promise là một đối tượng đại diện cho kết quả cuối cùng của một tác vụ bất đồng bộ. Thay vì bắt bạn lồng các hàm vào nhau (callback), Promise cho bạn một \"phiếu hẹn\". Bạn có thể cầm phiếu hẹn này và đi làm việc khác, khi nào tác vụ xong, phiếu hẹn sẽ tự động kích hoạt các hành động tiếp theo mà bạn đã đăng ký.',NULL,NULL,'2026-01-29 06:56:46'),(314,58,'theory',1,'Ba trạng thái sinh tử của một Promise','Một Promise tại bất kỳ thời điểm nào cũng chỉ có thể nằm trong một trong ba trạng thái sau:\n- Pending (Đang chờ): Trạng thái ban đầu khi tác vụ đang chạy, chưa có kết quả (thành công hay thất bại).\n- Fulfilled (Thành công): Tác vụ đã hoàn thành xuất sắc. Lúc này Promise sẽ trả về một giá trị (Data).\n- Rejected (Thất bại): Có lỗi xảy ra trong quá trình thực hiện. Promise sẽ trả về một lý do lỗi (Error).\n\nMột khi Promise đã chuyển sang trạng thái Fulfilled hoặc Rejected, nó sẽ đứng yên tại đó mãi mãi (Settled), không bao giờ thay đổi kết quả lần thứ hai.',NULL,NULL,'2026-01-29 06:57:11'),(315,58,'code',1,'','const myPromise = new Promise((resolve, reject) => {\n    // Giả lập một tác vụ tốn 2 giây (ví dụ: lấy dữ liệu)\n    const success = true;\n\n    setTimeout(() => {\n        if (success) {\n            resolve(\'Dữ liệu đã tải xong!\'); // Gọi khi thành công\n        } else {\n            reject(\'Lỗi: Không thể kết nối Server.\'); // Gọi khi thất bại\n        }\n    }, 2000);\n});\n\n// Cách sử dụng\nmyPromise\n    .then((data) => {\n        console.log(data); // Chạy khi resolve được gọi\n    })\n    .catch((error) => {\n        console.warn(error); // Chạy khi reject được gọi\n    })\n    .finally(() => {\n        console.log(\'Kết thúc tác vụ.\'); // Luôn chạy dù thành công hay bại\n    });','javascript','Hàm thực thi (executor) nhận vào hai tham số: resolve (hàm để báo thành công) và reject (hàm để báo lỗi). Chúng ta sử dụng .then() để nhận kết quả thành công và .catch() để \"bắt\" các lỗi xảy ra. Điều này tách biệt hoàn toàn luồng xử lý dữ liệu và luồng xử lý lỗi, giúp code cực kỳ minh bạch.','2026-01-29 06:57:35'),(316,58,'code',1,'Promise Chain - Tiêu diệt Callback Hell','// Thay vì lồng nhau, ta viết nối tiếp nhau (Chain)\ngetStudent(1)\n    .then(student => {\n        return getCourse(student.courseId); // Trả về một Promise tiếp theo\n    })\n    .then(course => {\n        return getLesson(course.lessonId);\n    })\n    .then(lesson => {\n        console.log(\'Bài học cuối cùng:\', lesson.name);\n    })\n    .catch(error => {\n        console.error(\'Lỗi ở bất kỳ bước nào:\', error);\n    });','javascript','Đây chính là sức mạnh khủng khiếp nhất của Promise. Bằng cách trả về một Promise mới trong hàm .then(), bạn có thể nối dài các hành động bất đồng bộ theo một đường thẳng. Toàn bộ các bước này chỉ cần duy nhất một hàm .catch() ở cuối cùng để quản lý lỗi cho tất cả các khâu trước đó.','2026-01-29 06:58:05'),(317,58,'theory',1,'Promise.all() - Đa nhiệm tối ưu','Đôi khi bạn cần tải dữ liệu từ 3 nguồn khác nhau cùng một lúc (ví dụ: Thông tin người dùng, Danh sách bài tập, Bình luận). Nếu dùng chuỗi nối tiếp, bạn sẽ mất rất nhiều thời gian chờ đợi.\n\nPromise.all() cho phép bạn thực hiện tất cả các lời hứa đó cùng một lúc. Nó sẽ đợi cho đến khi tất cả đều thành công rồi mới trả về một mảng kết quả duy nhất. Nếu chỉ cần 1 lời hứa thất bại, toàn bộ nhóm đó sẽ bị coi là thất bại. Đây là kỹ thuật tối thượng để tối ưu tốc độ tải trang cho ứng dụng của bạn.',NULL,NULL,'2026-01-29 06:58:20'),(318,58,'theory',1,'Tổng kết','- Promise sinh ra để thay thế Callback trong các tác vụ bất đồng bộ phức tạp.\n- Luôn có 3 trạng thái: Pending, Fulfilled, Rejected.\n- Dùng .then() cho thành công, .catch() cho lỗi và .finally() cho kết thúc.\n- Promise Chain giúp code thẳng hàng, dễ đọc (Flat code).\n- Làm chủ Promise là bước đệm bắt buộc để bạn học về Async/Await — cú pháp \"thượng thừa\" nhất của JavaScript hiện nay.',NULL,NULL,'2026-01-29 06:58:49'),(319,59,'theory',1,'Fetch là gì?','Trong quá khứ, để lấy dữ liệu từ Server mà không tải lại trang, lập trình viên phải sử dụng một đối tượng rất phức tạp là XMLHttpRequest. May mắn thay, JavaScript hiện đại đã mang đến Fetch API.\n\nFetch là một giao diện lập trình (API) mạnh mẽ và đơn giản, giúp bạn gửi các yêu cầu mạng (Network Request) lên Server. Điểm quan trọng nhất cần nhớ: Fetch luôn trả về một Promise. Điều này cho phép bạn sử dụng toàn bộ sức mạnh của chuỗi .then() và .catch() mà chúng ta đã học ở bài trước để xử lý dữ liệu trả về một cách mượt mà.',NULL,NULL,'2026-01-29 06:59:25'),(320,59,'theory',1,'Quy trình 2 bước khi lấy dữ liệu','Một lỗi phổ biến của người mới bắt đầu là nghĩ rằng fetch() sẽ trả về dữ liệu ngay lập tức. Thực tế, quy trình diễn ra qua 2 giai đoạn:\n- Giai đoạn 1: Gửi yêu cầu và nhận về một đối tượng Response. Lúc này, dữ liệu vẫn đang ở dạng luồng (Stream) - giống như nước đang chảy qua vòi, bạn chưa thể sử dụng ngay được.\n- Giai đoạn 2: Sử dụng phương thức .json(). Phương thức này cũng trả về một Promise. Nhiệm vụ của nó là đợi cho toàn bộ dữ liệu được tải về hết và \"đóng gói\" chúng lại thành một đối tượng JavaScript mà bạn có thể đọc được.\n\n**Gọi dữ liệu từ API thực tế**',NULL,NULL,'2026-01-29 06:59:44'),(321,59,'code',1,'','// Sử dụng API giả lập từ JSONPlaceholder\nconst apiURL = \'https://jsonplaceholder.typicode.com/posts/1\';\n\nfetch(apiURL)\n    .then((response) => {\n        // Bước 1: Trình duyệt nhận được phản hồi thô\n        return response.json(); // Chuyển đổi sang JSON\n    })\n    .then((data) => {\n        // Bước 2: Dữ liệu đã sẵn sàng để sử dụng\n        console.log(\'Tiêu đề bài viết:\', data.title);\n    })\n    .catch((error) => {\n        console.error(\'Lỗi khi gọi API:\', error);\n    });','javascript','Ở bước đầu tiên, biến response chứa các thông tin như mã trạng thái (status code), header... nhưng chưa có nội dung bài viết. Chúng ta phải gọi response.json() để \"hứa\" rằng sẽ chuyển đổi nội dung đó. Khi nội dung đã sẵn sàng, hàm .then() thứ hai mới được kích hoạt với tham số data chính là dữ liệu thực sự.','2026-01-29 07:00:23'),(322,59,'theory',1,'Tại sao lỗi 404 không nhảy vào .catch()?','Đây là một đặc điểm cực kỳ quan trọng: Fetch chỉ nhảy vào .catch() khi có lỗi mạng thực sự (ví dụ: đứt cáp, mất wifi, Server sập hoàn toàn).\n\nNếu Server vẫn phản hồi nhưng báo lỗi 404 (Không tìm thấy trang) hoặc 500 (Lỗi Server nội bộ), Fetch vẫn coi đó là một lần giao tiếp thành công và nhảy vào .then(). Để xử lý chuyên nghiệp, bạn cần kiểm tra thuộc tính response.ok (trả về true nếu mã trạng thái từ 200-299) trước khi thực hiện các bước tiếp theo.',NULL,NULL,'2026-01-29 07:00:46'),(323,59,'code',1,'','const postList = document.querySelector(\'#posts\');\n\nfetch(\'https://jsonplaceholder.typicode.com/posts?_limit=5\')\n    .then(res => res.json())\n    .then(posts => {\n        const htmls = posts.map(post => {\n            return `<li>\n                <h3>${post.title}</h3>\n                <p>${post.body}</p>\n            </li>`;\n        });\n        postList.innerHTML = htmls.join(\'\');\n    });','javascript','Đây là một ví dụ kinh điển kết hợp giữa Fetch, phương thức mảng map() và HTML DOM. Chúng ta lấy danh sách bài viết từ server, biến đổi chúng thành các chuỗi HTML và dùng innerHTML để đưa thẳng lên màn hình cho người dùng xem. Đây chính là cách các website tin tức và mạng xã hội hoạt động.','2026-01-29 07:01:14'),(324,59,'theory',1,'Tổng kết bài học','- fetch() trả về một Promise.\n- Cần 2 lần .then(): một để giải mã JSON, một để xử lý dữ liệu.\n- Luôn kiểm tra response.ok để đảm bảo API trả về kết quả đúng.\n- Dùng .catch() để đề phòng các lỗi kết nối mạng. Làm chủ được Fetch, bạn đã có khả năng kết nối ứng dụng của mình với bất kỳ kho dữ liệu khổng lồ nào trên thế giới.',NULL,NULL,'2026-01-29 07:01:32'),(325,60,'theory',1,'Sự trỗi dậy của Arrow Functions','Trước ES6, từ khóa function là cách duy nhất để khai báo hàm. Tuy nhiên, nó thường gây rắc rối với từ khóa this vì this sẽ thay đổi theo ngữ cảnh gọi hàm.\n\nArrow Functions (Hàm mũi tên) giải quyết triệt để hai vấn đề:\n- Cú pháp cực ngắn: Loại bỏ các từ khóa rườm rà, giúp mã nguồn trông thanh thoát và hiện đại hơn.\n- Cố định từ khóa this: Arrow function không tự tạo ngữ cảnh this riêng mà nó \"mượn\" trực tiếp từ ngữ cảnh cha bên ngoài. Điều này giúp bạn tránh được những lỗi logic kinh điển khi làm việc với các hàm xử lý mảng nâng cao hay các sự kiện trong DOM.',NULL,NULL,'2026-01-29 07:06:32'),(326,60,'code',1,'','// 1. Cú pháp truyền thống (Old)\nconst sumOld = function(a, b) {\n    return a + b;\n};\n\n// 2. Cú pháp Arrow Function đầy đủ (ES6)\nconst sumNew = (a, b) => {\n    return a + b;\n};\n\n// 3. Cú pháp tối giản (Implicit Return)\n// Nếu chỉ có một dòng lệnh trả về, ta có thể bỏ ngoặc nhọn và từ khóa return\nconst sumShort = (a, b) => a + b;\n\n// 4. Nếu chỉ có duy nhất 1 tham số, có thể bỏ cả ngoặc tròn\nconst logMsg = msg => console.log(msg);','javascript','Việc lược bỏ ngoặc nhọn {} và từ khóa return được gọi là trả về ngầm định. Đây là phong cách viết code phổ biến nhất hiện nay khi xử lý dữ liệu với map(), filter() vì nó giúp tập trung vào logic tính toán thay vì cú pháp khai báo.','2026-01-29 07:06:50'),(327,60,'theory',1,'Enhanced Object Literals - Định nghĩa đối tượng thông minh','rong lập trình thực tế, việc tạo ra các đối tượng (Object) từ các biến có sẵn diễn ra rất thường xuyên. ES6 cung cấp các lối tắt giúp bạn định nghĩa thuộc tính và phương thức bên trong Object nhanh hơn, giúp code trở nên thông minh và dễ bảo trì hơn. \n\nBa cải tiến chính bao gồm:\n- Property shorthand: Khi tên thuộc tính và tên biến chứa giá trị trùng nhau, bạn chỉ cần viết một lần.\n- Method shorthand: Loại bỏ từ khóa function khi định nghĩa phương thức trong Object.\n- Computed property names: Cho phép bạn sử dụng một biến số hoặc biểu thức để làm tên thuộc tính (Key) cho Object.',NULL,NULL,'2026-01-29 07:07:19'),(328,60,'code',1,'','const courseName = \'Javascript Pro\';\nconst price = 1000;\n\nconst course = {\n    // 1. Property shorthand (Thay vì courseName: courseName)\n    courseName, \n    price,\n\n    // 2. Method shorthand (Bỏ qua : function)\n    getName() {\n        return this.courseName;\n    },\n\n    // 3. Computed property names (Key linh hoạt)\n    [\'lesson_\' + 1]: \'Arrow Functions\'\n};\n\nconsole.log(course.getName()); // \"Javascript Pro\"\nconsole.log(course.lesson_1);  // \"Arrow Functions\"','javascript','Cách viết này không chỉ giúp giảm bớt số lượng ký tự phải gõ mà còn làm cho cấu trúc dữ liệu của bạn trở nên linh hoạt hơn, đặc biệt là khi bạn cần tạo ra các Object dựa trên dữ liệu động từ API trả về.','2026-01-29 07:07:34'),(329,60,'theory',1,'Nền tảng của các Framework hiện đại','Những cú pháp bạn vừa học là \"xương sống\" của các thư viện như React hay Vue. Việc làm chủ Arrow Functions giúp bạn xử lý các component gọn gàng hơn, và Enhanced Object Literals giúp bạn quản lý trạng thái (state) của ứng dụng một cách chuyên nghiệp. Đây chính là bước chuyển mình từ một người biết code sang một người viết code \"sạch\" (Clean Code).',NULL,NULL,'2026-01-29 07:07:49'),(330,61,'theory',1,'Tại sao cần Destructuring?','Trong lập trình thực tế, chúng ta thường xuyên làm việc với các đối tượng (Object) và mảng (Array) phức tạp trả về từ API. Trước đây, để lấy dữ liệu ra, bạn phải truy cập thủ công từng lớp như user.profile.name. Điều này khiến code bị lặp lại và rườm rà.\n\nDestructuring (Phân rã) là một cú pháp cho phép bạn \"chiết xuất\" các giá trị từ mảng hoặc thuộc tính từ đối tượng và gán chúng vào các biến riêng biệt một cách cực kỳ gọn gàng. Nó giống như việc bạn nhận một kiện hàng lớn và bạn chỉ lấy đúng những món đồ mình cần ra khỏi hộp ngay lập tức thay vì phải bới tung cả kiện hàng nhiều lần.',NULL,NULL,'2026-01-29 07:08:39'),(331,61,'code',1,'','// 1. Destructuring với Array (Dựa trên thứ tự)\nconst colors = [\'Red\', \'Green\', \'Blue\'];\nconst [firstColor, secondColor] = colors;\nconsole.log(firstColor, secondColor); // \"Red\", \"Green\"\n\n// 2. Destructuring với Object (Dựa trên tên thuộc tính)\nconst course = {\n    name: \'Javascript Pro\',\n    price: 1000,\n    author: \'CodePulse\'\n};\n\n// Lấy thuộc tính name và price ra thành biến riêng\n// Có thể đặt giá trị mặc định nếu thuộc tính không tồn tại\nconst { name, price, description = \'Chưa có mô tả\' } = course;\n\nconsole.log(name, price, description);','javascript','Với mảng, việc phân rã dựa trên thứ tự phần tử. Với đối tượng, việc phân rã dựa trên tên thuộc tính (Key). Việc cho phép đặt giá trị mặc định (như description) giúp ứng dụng của bạn không bị lỗi undefined khi dữ liệu từ Server trả về không đầy đủ.','2026-01-29 07:08:54'),(332,61,'theory',1,'Spread và Rest - Phép màu của dấu ba chấm (...)','Cùng sử dụng ký hiệu ..., nhưng ý nghĩa của chúng hoàn toàn trái ngược nhau tùy vào vị trí xuất hiện:\n- Spread (Trải rộng): Dùng khi bạn muốn \"phá vỡ\" một mảng hoặc đối tượng để trải các phần tử của nó ra một vị trí mới. Thường dùng để sao chép dữ liệu hoặc nối các mảng lại với nhau mà không làm ảnh hưởng mảng gốc\n- Rest (Phần còn lại): Dùng khi bạn muốn \"gom\" các phần tử còn dư thừa vào một tập hợp duy nhất. Thường dùng trong tham số hàm (khi không biết trước số lượng đối số) hoặc khi phân rã dữ liệu để lấy những phần còn lại sau khi đã lấy các phần tử chính.',NULL,NULL,'2026-01-29 07:09:24'),(333,61,'code',1,'','// 1. Spread: Sao chép và nối mảng nhanh chóng\nconst list1 = [1, 2, 3];\nconst list2 = [...list1, 4, 5]; // [1, 2, 3, 4, 5]\n\nconst user = { name: \'An\', age: 20 };\nconst updatedUser = { ...user, job: \'Dev\' }; // Sao chép và thêm thuộc tính mới\n\n// 2. Rest: Gom các tham số còn lại trong hàm\nfunction logger(title, ...content) {\n    console.log(title);\n    console.log(content); // content sẽ là một mảng chứa [\'An\', \'Bình\', \'Chi\']\n}\nlogger(\'Danh sách học viên:\', \'An\', \'Bình\', \'Chi\');\n\n// 3. Kết hợp Destructuring và Rest\nconst { name: studentName, ...otherInfo } = updatedUser;\nconsole.log(otherInfo); // { age: 20, job: \'Dev\' }','javascript','Toán tử Spread giúp bạn đảm bảo tính Bất biến (Immutability) – tạo ra dữ liệu mới mà không làm hỏng bản gốc. Toán tử Rest trong tham số hàm cho phép bạn nhận vào một số lượng đối số không giới hạn dưới dạng một mảng, giúp hàm trở nên linh hoạt tuyệt đối trong mọi tình huống.','2026-01-29 07:09:38'),(334,61,'theory',1,'Tại sao bộ ba này lại thay đổi cách viết code?','Destructuring, Rest và Spread không chỉ là \"cú pháp làm đẹp\". Chúng thay đổi hoàn toàn cách bạn tương tác với dữ liệu:\n- Tường minh: Code chỉ lấy đúng những gì cần thiết, giúp người đọc hiểu ngay mục đích của đoạn mã.\n- An toàn: Tránh được việc vô tình thay đổi dữ liệu gốc thông qua việc sao chép thông minh.\n- Gọn gàng: Loại bỏ các vòng lặp thủ công và các câu lệnh gán biến rườm rà. Đây là bộ công cụ nền tảng để bạn làm việc hiệu quả với các cấu trúc dữ liệu lớn, đặc biệt là khi truyền nhận dữ liệu qua các Component trong React hay quản lý State trong ứng dụng phức tạp.',NULL,NULL,'2026-01-29 07:09:59'),(335,62,'theory',1,'Giới thiệu về ngôn ngữ lập trình C++','C++ là một ngôn ngữ lập trình bậc trung, được phát triển bởi Bjarne Stroustrup năm 1979 tại Bell Labs. Từ thập niên 1990, C++ đã trở thành một trong những ngôn ngữ lập trình phổ biến nhất trên thế giới.\n\nMột số ưu điểm của ngôn ngữ lập trình C++\n- Đa nền tảng: chương trình được viết bằng C++ có thể chạy được trên nhiều nền tảng khác nhau như Windows, Mac OS, Linux, ...\n- Cộng đồng lập trình lớn: C++ là một trong những ngôn ngữ phổ biến nhất thế giới nên có cộng đồng lập trình viên lớn, bạn có thể dễ dàng tìm kiếm các tài liệu, các lỗi gặp phải khi lập trình trên mạng.\n- Bộ thư viện hỗ trợ mạnh mẽ: C++ có bộ thư viện chuẩn và bộ thư viện của bên thứ 3 với nhiều cấu trúc dữ liệu, thuật toán, ... để giúp bạn dễ dàng phát triển chương trình một cách nhanh chóng (bạn sẽ được học và hiểu về thư viện trong các bài tiếp theo).\n- Đa năng: C++ có thể được dùng để lập trình nhúng, lập trình hệ thống, lập trình ứng dụng,  lập trình game, ...\n- Hiệu năng cao: chương trình được viết bằng C++ sẽ cho tốc độ thực thi nhanh hơn các chương trình được viết bởi các ngôn ngữ lập trình khác như Java, C#, Python, ... Vì thế với các ứng dụng nặng, cần có tốc độ xử lý nhanh hay các game 3D thường được viết bằng C++.\n- Hỗ trợ lập trình hướng đối tượng: C++ cho phép bạn lập trình theo phương pháp hướng đối tượng, giúp cho chương trình dễ phát triển và bảo trì hơn (bạn sẽ được học và hiểu về lập trình hướng đối tượng trong khóa học này ở các chương sau).',NULL,NULL,'2026-01-29 07:18:58'),(336,62,'theory',1,'Ứng dụng của ngôn ngữ lập trình C++','- Hệ điều hành: C++ được dùng trong việc phát triển các hệ điều hành mà bạn đang dùng như Windows, Mac OS, ...\n- Lập trình game: hầu hết các game nổi tiếng hiện nay đều được viết bằng C++ hoặc các Game engine dựa trên C++. Ví dụ như các game Counter Strike, Warcraft III, Doom III, ... đều sử dụng C++\n- Lập trình ứng dụng: đây là một trong những mảng mạnh nhất của C++. Có rất nhiều ứng dụng lớn được tạo ra bởi C++ mà chúng ta đang sử dụng như Word, Excel, Powerpoint, Google Chrome, Firefox, Adobe Photoshop & Illustrator, ...\n- Lập trình nhúng: C++ cũng được sử dụng nhiều trong các thiết bị như đồng hồ thông minh, thiết bị y tế, ...\n- Ngoài ra C++ còn được dùng để tạo ra các tình biên dịch, các hệ quản trị cơ sở dữ liệu, ...\n\nCó thể thấy C++ được sử dụng rất rộng rãi trong ngành công nghệ thông tin, ngay cả hệ điều hành mà bạn đang sử dụng hay các thiết bị thông minh đều có thể đang sử dụng C++. Trong giới hạn của khóa học này, bạn sẽ học và hiểu được các khái niệm cơ bản trong C++, sau đó tiếp tục tìm hiểu các khái niệm nâng cao như con trỏ, lập trình hướng đối tượng, các thư viện chuẩn, ...',NULL,NULL,'2026-01-29 07:20:17'),(337,64,'theory',1,'Tổng quan về Dev-C++','Dev-C++ là một IDE (Integrated Development Environment - Môi trường phát triển tích hợp) tự do, mã nguồn mở, hỗ trợ ngôn ngữ lập trình C và C++.\n\nThành phần cốt lõi: Nó sử dụng bộ trình biên dịch MinGW (một bản phân phối của GCC - GNU Compiler Collection).\n\nƯu điểm:\n- Dung lượng nhẹ, giao diện đơn giản, phù hợp cho người mới bắt đầu.\n- Hỗ trợ đầy đủ các tính năng cơ bản: soạn thảo code, biên dịch, chạy và gỡ lỗi (debug).\n- Hoàn toàn miễn phí.',NULL,NULL,'2026-01-29 07:24:01'),(338,64,'theory',1,'Quy trình cài đặt chi tiết','Để cài đặt Dev-C++, bạn thực hiện theo các bước sau:\n- Tải bộ cài đặt: Truy cập vào trang web chính thức (thường là SourceForge) để tải phiên bản mới nhất (thường là bản của Orwell hoặc Embarcadero).\n- Chọn ngôn ngữ cài đặt: Chạy file .exe, chọn ngôn ngữ là English (hoặc Tiếng Việt) rồi nhấn OK.\n- Chấp nhận điều khoản: Nhấn I Agree để đồng ý với các quy định sử dụng phần mềm.\n- Lựa chọn thành phần (Components): Để mặc định là Full (đảm bảo đã tích chọn MinGW và Shortcut) và nhấn Next.\n- Chọn thư mục lưu trữ: Chọn đường dẫn cài đặt (mặc định thường là C:\\Program Files (x86)\\Dev-Cpp) và nhấn Install.\n- Hoàn tất: Sau khi thanh tiến trình chạy xong, nhấn Finish.',NULL,NULL,'2026-01-29 07:24:33'),(339,64,'theory',1,'Hướng dẫn sử dụng cơ bản','Sau khi cài đặt thành công, bạn cần nắm vững các thao tác sau để bắt đầu lập trình:\n1. Tạo file mã nguồn mới\n- Cách 1: Vào File -> New -> Source File.\n- Cách 2: Sử dụng tổ hợp phím Ctrl + N.\n2. Lưu file (Cực kỳ quan trọng)\n- Vào File -> Save (hoặc nhấn Ctrl + S).\n- Lưu ý: File C++ bắt buộc phải có phần mở rộng (đuôi file) là .cpp. Tránh đặt tên file có dấu tiếng Việt hoặc khoảng trắng để hạn chế lỗi khi biên dịch.\n3. Quy trình thực thi chương trìnhQuá trình từ khi viết code đến khi chạy chương trình gồm 3 bước:\n- Compile (Biên dịch - F9): IDE sẽ kiểm tra lỗi cú pháp. Nếu có lỗi, nó sẽ hiển thị ở cửa sổ Compile Log phía dưới.\n- Run (Chạy - F10): Thực thi file đã biên dịch thành công.\n- Compile & Run (Biên dịch và Chạy - F11): Đây là phím tắt phổ biến nhất, giúp thực hiện cả 2 bước trên cùng lúc.\n\n**Ghi chú**: Nếu sau khi cài đặt mà bạn nhấn F11 nhưng chương trình không hiện cửa sổ kết quả, hãy vào Tools -> Compiler Options -> Tab Settings -> Mục Linker và chuyển dòng Generate debugging information thành Yes.',NULL,NULL,'2026-01-29 07:26:15'),(340,64,'code',1,'Chương trình đầu tiên - Hello World','#include <iostream>\nusing namespace std;\n\nint main() {\n    // In dòng chữ ra màn hình\n    cout << \"Chao mung ban den voi CodePulse C++!\" << endl;\n    \n    return 0;\n}','javascript','- #include <iostream>: Khai báo thư viện để sử dụng các lệnh nhập/xuất.\n- int main(): Là \"trái tim\" của chương trình, nơi mọi thứ bắt đầu chạy.\n- cout: Lệnh dùng để in dữ liệu ra màn hình.\n- Thao tác: Nhấn phím F11 trên bàn phím để vừa biên dịch vừa chạy chương trình. Nếu màn hình đen hiện lên dòng chữ mong muốn, bạn đã cài đặt thành công!','2026-01-29 07:27:59'),(341,64,'theory',1,'Tổng kết','- Đã cài đặt thành công Dev-C++ phiên bản mới nhất.\n- Hiểu được vai trò của IDE trong lập trình.\n- Biết cách tạo một file mới (Ctrl + N) và lưu file với đuôi .cpp.\n- Biết cách dùng phím F11 để thực thi chương trình. Bây giờ, \"xưởng vẽ\" đã sẵn sàng, chúng ta sẽ bắt đầu học những nét vẽ đầu tiên về ngôn ngữ C++ ở bài sau.',NULL,NULL,'2026-01-29 07:28:37'),(342,65,'theory',1,'1.1. Biến là gì?','Hãy tưởng tượng bộ nhớ máy tính (RAM) giống như một nhà kho khổng lồ chứa hàng tỷ ngăn tủ nhỏ. Để làm việc với dữ liệu, chúng ta cần một cách để gọi tên và truy cập vào các ngăn tủ này. Biến (Variable) chính là tên gọi mà lập trình viên đặt cho một vùng nhớ cụ thể.\n\nTrong C++, biến không chỉ đơn thuần là cái tên, nó còn đi kèm với một Kiểu dữ liệu cố định. Điều này giống như việc bạn dán nhãn lên ngăn tủ: \"Ngăn này chỉ được đựng sách\" hoặc \"Ngăn này chỉ được đựng tiền\". Việc định nghĩa rõ ràng giúp máy tính quản lý tài nguyên cực kỳ hiệu quả và tránh những nhầm lẫn tai hại khi tính toán.\n\nCơ chế lưu trữ: Khi chương trình thực thi, CPU cần dữ liệu để xử lý. Dữ liệu này được lưu tại RAM. Thay vì phải nhớ những dãy số Hexadecimal phức tạp như 0x7fff5fbff618, lập trình viên đặt một cái tên gợi nhớ (biến) để đại diện cho địa chỉ đó.\n\nQuá trình khởi tạo: Một biến đầy đủ bao gồm 4 yếu tố: Tên biến, Kiểu dữ liệu, Giá trị và Địa chỉ ô nhớ.\n',NULL,NULL,'2026-01-29 07:37:19'),(343,65,'theory',1,'1.2. Kiểu dữ liệu cơ bản (Data Types)','Trong C++, kiểu dữ liệu quyết định \"hình dạng\" và \"kích cỡ\" của vùng nhớ mà biến chiếm giữ.\n\nKiểu số nguyên (Integer):\n\nĐại diện bởi từ khóa int. Thường chiếm 4 bytes bộ nhớ.\n\nDùng cho các đại lượng đếm được như số người, tuổi tác, số lượng hàng hóa.\n\nKiểu ký tự (Character):\n- Đại diện bởi từ khóa char. Chiếm 1 byte.\n- Nó lưu trữ các ký tự dựa trên bảng mã ASCII. Ví dụ, khi bạn lưu \'A\', thực chất máy tính đang lưu số 65.\n\nKiểu số thực (Floating-point):\n- float: Dùng cho số thập phân có độ chính xác thấp (7 chữ số sau dấu phẩy).\n- double: Dùng cho số thập phân có độ chính xác cao (15-17 chữ số). Đây là kiểu mặc định thường dùng trong tính toán khoa học.\n\nKiểu Logic (Boolean):\n- Đại diện bởi từ khóa bool. Chỉ nhận hai giá trị là true (1) hoặc false (0).\n- Rất quan trọng trong việc kiểm tra điều kiện và điều hướng chương trình.\n\nKiểu chuỗi văn bản (String):\n- Mặc dù không phải kiểu dữ liệu nguyên thủy (primitive), nhưng std::string cực kỳ phổ biến để lưu trữ văn bản như tên gọi, địa chỉ.',NULL,NULL,'2026-01-29 07:38:07'),(347,65,'theory',1,'Quy tắc khai báo và Đặt tên biến','Để tạo ra một biến, bạn bắt buộc phải tuân theo cú pháp: kiểu_dữ_liệu tên_biến = giá_trị;. Nếu bạn chỉ khai báo mà không gán giá trị, biến đó sẽ chứa một \"giá trị rác\" (dữ liệu cũ còn sót lại trong RAM), điều này có thể dẫn đến những lỗi khó lường.\n\nĐể mã nguồn sạch đẹp và dễ bảo trì, hãy tuân thủ các quy tắc đặt tên sau:\n- Không bắt đầu bằng chữ số (ví dụ: 1st_name là không hợp lệ).\n- Không chứa khoảng trắng hoặc các ký tự đặc biệt như @, #, !.\n- Phân biệt chữ hoa và chữ thường: age và Age là hai ngăn tủ hoàn toàn khác nhau.\n- Nên sử dụng phong cách camelCase (ví dụ: yourBirthYear) để tăng khả năng đọc hiểu.',NULL,NULL,'2026-01-29 11:53:54'),(348,65,'code',1,'Xuất dữ liệu với cout (Output)','#include <iostream>\nusing namespace std;\n\nint main() {\n    int score = 95;\n    string name = \"Hoang\";\n\n    // Sử dụng cout để in dữ liệu ra màn hình\n    cout << \"Chuc mung \" << name << \"!\" << endl;\n    cout << \"Diem thi cua ban la: \" << score << \"/100\";\n\n    return 0;\n}','css','Đối tượng cout (viết tắt của Console Out) kết hợp với toán tử << đóng vai trò như một dòng chảy dữ liệu từ chương trình ra ngoài màn hình. Lệnh endl không chỉ đơn giản là xuống dòng, mà nó còn giúp \"đẩy\" toàn bộ dữ liệu đang chờ trong bộ đệm ra màn hình ngay lập tức, đảm bảo người dùng nhìn thấy thông tin kịp thời.','2026-01-29 11:54:14'),(349,65,'theory',1,'Nhập dữ liệu với cin (Input)','Một chương trình mạnh mẽ là chương trình biết lắng nghe người dùng. C++ cung cấp đối tượng cin (Console In) để thực hiện nhiệm vụ này.\n\nKhi dòng lệnh cin >> tên_biến; được thực thi, máy tính sẽ tạm dừng mọi hoạt động và \"nín thở\" đợi bạn nhập dữ liệu từ bàn phím. Ngay khi bạn nhấn Enter, giá trị đó sẽ được trích xuất và lưu chặt vào ngăn chứa của biến mà bạn đã khai báo. Lưu ý: Mũi tên của cin hướng sang phải (>>), ngược lại với cout hướng sang trái (<<).',NULL,NULL,'2026-01-29 11:54:33'),(350,65,'code',1,'Nhập - Xử lý - Xuất','#include <iostream>\nusing namespace std;\n\nint main() {\n    int age;\n    int currentYear = 2026;\n\n    cout << \"Ban bao nhieu tuoi? \";\n    // Lấy tuổi từ người dùng nhập vào\n    cin >> age;\n\n    // Logic tính toán đơn giản\n    int birthYear = currentYear - age;\n\n    cout << \"Co le ban sinh nam: \" << birthYear << endl;\n    cout << \"Cam on ban da su dung CodePulse!\";\n\n    return 0;\n}','css','Đây là một quy trình khép kín hoàn chỉnh. Đầu tiên, chúng ta dùng cout để đưa ra câu hỏi. Sau đó dùng cin để hứng câu trả lời của người dùng vào biến age. Cuối cùng, máy tính thực hiện phép trừ để tìm ra birthYear và hiển thị lại kết quả cho người dùng.','2026-01-29 11:55:04'),(351,65,'theory',1,'Tổng kết và Lưu ý','- Thư viện: Luôn phải có #include <iostream> để sử dụng được cin và cout.\n- Hướng mũi tên: cout << (đẩy ra ngoài) và cin >> (hứng vào trong)\n- Biến: Phải được khai báo kiểu dữ liệu rõ ràng trước khi dùng cin để chứa giá trị.\n- Lưu ý: cin sẽ mặc định dừng lại khi gặp khoảng trắng. Để nhập một chuỗi có khoảng trắng (như họ tên), chúng ta sẽ cần đến kỹ thuật nâng cao hơn ở các bài sau.',NULL,NULL,'2026-01-29 11:55:30'),(352,66,'theory',1,'Tại sao C++ lại phân chia kiểu dữ liệu?','Trong C++, mỗi kiểu dữ liệu đóng vai trò như một chiếc khuôn đúc. Khi bạn khai báo một biến, máy tính cần biết chính xác hai điều: Thứ nhất, biến đó sẽ chiếm bao nhiêu không gian trong RAM; thứ hai, dữ liệu đó sẽ được diễn giải như thế nào (là số hay là chữ).\n\nKhác với một số ngôn ngữ như Python hay JavaScript, C++ là ngôn ngữ định kiểu tĩnh (Statically Typed). Điều này có nghĩa là bạn phải xác định kiểu dữ liệu ngay khi khai báo và không thể thay đổi nó sau đó. Sự khắt khe này giúp C++ đạt được hiệu suất cực cao vì máy tính không mất thời gian để \"đoán\" xem bạn đang chứa cái gì trong ngăn tủ của mình.',NULL,NULL,'2026-01-29 11:55:58'),(353,66,'theory',1,'Nhóm kiểu số nguyên (Integer)','Nhóm số nguyên được sử dụng cho các giá trị đếm được hoặc các ID định danh.\n- Kiểu int: Đây là kiểu dữ liệu phổ biến nhất, thường chiếm 4 byte trong bộ nhớ. Nó có thể chứa các số từ khoảng âm 2 tỷ đến dương 2 tỷ.\n- Kiểu short: Dùng khi bạn chắc chắn con số của mình rất nhỏ (dưới 32,767) để tiết kiệm bộ nhớ (chiếm 2 byte).\n- Kiểu long long: \"Gã khổng lồ\" trong nhóm số nguyên, chiếm 8 byte. Bạn sẽ cần đến nó khi làm việc với các con số cực lớn như khoảng cách giữa các vì sao hoặc ID của hàng tỷ người dùng trên mạng xã hội.\n- Kiểu unsigned: Khi thêm từ khóa này trước các kiểu số nguyên, biến của bạn sẽ chỉ chứa các số không âm, giúp mở rộng phạm vi số dương lên gấp đôi.',NULL,NULL,'2026-01-29 11:56:28'),(354,66,'theory',1,'Nhóm kiểu số thực (Floating-Point)','Khi cần lưu trữ chiều cao, cân nặng, hoặc điểm số trung bình, chúng ta cần đến số thực.\n- Kiểu float: Được gọi là số thực độ chính xác đơn, chiếm 4 byte. Nó phù hợp cho các phép tính đơn giản, không yêu cầu độ chính xác quá cao sau dấu phẩy.\n- Kiểu double: Số thực độ chính xác kép, chiếm 8 byte. Đây là kiểu mặc định mà các lập trình viên C++ thường dùng vì nó có độ chính xác cao hơn và ít gây ra sai số trong các phép tính toán học phức tạp.\n\nLưu ý: Trong lập trình, việc so sánh hai số thực bằng dấu bằng == thường không được khuyến khích vì sự sai lệch cực nhỏ trong cách máy tính lưu trữ các bit thập phân.',NULL,NULL,'2026-01-29 11:56:49'),(355,66,'theory',1,'Kiểu ký tự và Kiểu logic (Char & Bool)','- Kiểu char: Viết tắt của Character, chiếm 1 byte. Nó dùng để lưu trữ một ký tự duy nhất (như \'A\', \'b\', \'5\', \'$\'). Bản chất bên dưới, máy tính lưu trữ mã ASCII của ký tự đó dưới dạng một con số. Lưu ý: Ký tự phải đặt trong dấu nháy đơn \' \'.\n- Kiểu bool: Viết tắt của Boolean, chiếm 1 byte. Đây là kiểu dữ liệu đơn giản nhất nhưng quan trọng nhất trong lập trình logic. Nó chỉ có hai giá trị: true (đúng) hoặc false (sai). Trong C++, true tương ứng với số 1 và false tương ứng với số 0.\n',NULL,NULL,'2026-01-29 11:57:05'),(356,66,'code',1,'Kiểm tra kích thước kiểu dữ liệu thực tế','#include <iostream>\nusing namespace std;\n\nint main() {\n    cout << \"Kich thuoc cua int: \" << sizeof(int) << \" bytes\" << endl;\n    cout << \"Kich thuoc cua long long: \" << sizeof(long long) << \" bytes\" << endl;\n    cout << \"Kich thuoc cua float: \" << sizeof(float) << \" bytes\" << endl;\n    cout << \"Kich thuoc cua double: \" << sizeof(double) << \" bytes\" << endl;\n    cout << \"Kich thuoc cua char: \" << sizeof(char) << \" byte\" << endl;\n    cout << \"Kich thuoc cua bool: \" << sizeof(bool) << \" byte\" << endl;\n\n    return 0;\n}','css','Toán tử sizeof() là một công cụ đặc biệt giúp bạn biết chính xác một kiểu dữ liệu hoặc một biến chiếm bao nhiêu byte trên hệ điều hành của bạn. Kết quả có thể thay đổi tùy theo kiến trúc máy tính (32-bit hay 64-bit), nhưng tỷ lệ giữa các kiểu dữ liệu thường được giữ nguyên.','2026-01-29 11:57:29'),(357,66,'theory',1,'Tổng kết bài học','- Sử dụng int cho số nguyên thông thường.\n- Sử dụng long long cho các số nguyên rất lớn.\n- Ưu tiên sử dụng double cho các số thập phân để đảm bảo độ chính xác.\n- Sử dụng char cho các ký tự đơn lẻ.\n- Sử dụng bool cho các trạng thái Bật/Tắt, Đúng/Sai.\n- Luôn chọn kiểu dữ liệu nhỏ nhất có thể đáp ứng được nhu cầu để tối ưu hóa bộ nhớ cho ứng dụng.',NULL,NULL,'2026-01-29 11:57:55'),(358,67,'theory',1,'Hằng số là gì?','Trong lập trình, có những giá trị mà chúng ta muốn đảm bảo rằng chúng sẽ không bao giờ bị ghi đè hay thay đổi một cách vô ý (như số Pi = 3.14, vận tốc ánh sáng, hoặc số ngày trong một tuần).\n\nHằng số (Constant) chính là một vùng nhớ đặc biệt. Một khi bạn đã gán giá trị cho nó, trình biên dịch sẽ \"khóa\" ngăn tủ đó lại. Mọi nỗ lực cố tình thay đổi giá trị của hằng số sau khi khởi tạo sẽ dẫn đến lỗi biên dịch ngay lập tức. Điều này giúp mã nguồn của bạn trở nên an toàn hơn và tránh được những lỗi logic cực kỳ khó tìm trong các dự án lớn.',NULL,NULL,'2026-01-29 13:18:49'),(359,67,'theory',2,'Khai báo hằng số với từ khóa const','Đây là cách phổ biến và an toàn nhất để định nghĩa hằng số trong C++. Bạn chỉ cần thêm từ khóa const vào trước việc khai báo biến thông thường.\n- Quy tắc vàng: Bạn bắt buộc phải khởi tạo giá trị cho hằng số ngay tại thời điểm khai báo.\n- Quy ước đặt tên: Để phân biệt với biến thông thường, các lập trình viên thường đặt tên hằng số bằng chữ HOA TOÀN BỘ và dùng dấu gạch dưới để phân tách các từ (ví dụ: MAX_SCORE, PI_NUMBER).',NULL,NULL,'2026-01-29 13:19:20'),(360,67,'theory',4,'Tiền xử lý #define (Macro)','Ngoài const, C++ còn thừa hưởng từ ngôn ngữ C một cách định nghĩa hằng số khác bằng chỉ thị tiền xử lý #define.\n\nCách này không chiếm bộ nhớ thực sự. Khi bạn nhấn biên dịch, trình xử lý sẽ tự động đi tìm tất cả các từ khóa bạn định nghĩa và \"thay thế\" bằng giá trị tương ứng trước khi code thực sự được chạy.\n\nTuy nhiên, #define không có kiểu dữ liệu rõ ràng, vì vậy trong C++ hiện đại, chúng ta luôn ưu tiên sử dụng const để mã nguồn được kiểm soát chặt chẽ hơn.',NULL,NULL,'2026-01-29 13:19:44'),(361,67,'code',5,'Phân biệt const và biến thông thường','#include <iostream>\nusing namespace std;\n\n// Cách 1: Dùng #define (Thường đặt ở ngoài hàm main)\n#define PI 3.14159\n\nint main() {\n    // Cách 2: Dùng từ khóa const (Được ưu tiên)\n    const int MAX_USERS = 100;\n    const double TAX_RATE = 0.08;\n\n    // Ví dụ về sự bảo vệ của hằng số:\n    // MAX_USERS = 200; // Dòng này sẽ gây lỗi: assignment of read-only variable\n\n    int currentUsers = 50;\n    cout << \"So nguoi dung tối đa: \" << MAX_USERS << endl;\n    cout << \"Ti le thue hien tai: \" << TAX_RATE << endl;\n    cout << \"Gia tri Pi: \" << PI << endl;\n\n    return 0;\n}','css','Trong ví dụ trên, MAX_USERS và TAX_RATE được bảo vệ bởi từ khóa const. Nếu bạn vô tình viết lệnh thay đổi giá trị của chúng ở giữa chương trình, Dev-C++ sẽ báo đỏ ngay lập tức, giúp bảo vệ logic của hệ thống.','2026-01-29 13:20:09'),(362,67,'theory',6,'Tổng kết bài học','- Hằng số: Là giá trị không thể thay đổi sau khi đã khởi tạo.\n- An toàn: Giúp ngăn chặn việc thay đổi dữ liệu quan trọng một cách vô ý.\n- Khởi tạo: Phải gán giá trị ngay khi khai báo hằng số.\n- Phong cách: Đặt tên bằng chữ IN HOA để mã nguồn chuyên nghiệp hơn. Việc làm chủ hằng số là một bước tiến quan trọng trong tư duy lập trình hệ thống, giúp bạn xây dựng các ứng dụng bền vững và ít lỗi hơn.',NULL,NULL,'2026-01-29 13:23:55'),(363,68,'theory',1,'Toán tử gán (=)','Trong toán học, dấu = dùng để chỉ sự bằng nhau giữa hai vế. Nhưng trong lập trình C++, dấu = là một toán tử gán. Nó có nhiệm vụ lấy giá trị từ vế phải và \"đổ\" vào ngăn chứa của biến ở vế trái.\n\nHãy luôn nhớ quy tắc \"Từ phải sang trái\". Mọi biểu thức phức tạp ở bên phải sẽ được máy tính tính toán ra một kết quả duy nhất trước khi được gán vào tên biến bên trái. Nếu bạn viết 10 = x;, trình biên dịch sẽ báo lỗi ngay lập tức vì số 10 không phải là một ngăn chứa (biến) để có thể nhận dữ liệu.',NULL,NULL,'2026-01-29 13:24:52'),(364,68,'theory',1,'Các toán tử số học cơ bản','C++ hỗ trợ đầy đủ các phép tính toán học mà bạn đã học ở trường, bao gồm:\n- Phép cộng (+) và Phép trừ (-): Hoạt động hoàn toàn giống toán học thông thường.\n- Phép nhân (*): Sử dụng ký hiệu dấu sao thay cho dấu nhân.\n- Phép chia (/): Lưu ý quan trọng — nếu bạn chia hai số nguyên (int), kết quả sẽ bị mất phần thập phân (ví dụ: 5 / 2 = 2). Để lấy được 2.5, ít nhất một trong hai số phải là kiểu số thực (float hoặc double).\n- Phép chia lấy dư (%): Chỉ áp dụng cho số nguyên. Nó trả về phần dư của phép chia. Ví dụ: 7 % 3 = 1. Đây là \"vũ khí\" bí mật để kiểm tra số chẵn lẻ hoặc các bài toán xoay vòng.',NULL,NULL,'2026-01-29 13:26:23'),(365,68,'theory',1,'Toán tử gán phức hợp (Compound Assignment)','Trong lập trình, chúng ta thường gặp tình huống muốn tăng giá trị của một biến lên chính nó (ví dụ: x = x + 5). \nC++ cung cấp các toán tử viết tắt để làm mã nguồn trông sạch sẽ hơn:\n- x += 5 tương đương với x = x + 5.\n- x -= 2 tương đương với x = x - 2.\n- x *= 3 tương đương với x = x . 3.\n- x /= 4 tương đương với x = x / 4.\n- x %= 2 tương đương với x = x % 2.\n\nSử dụng các toán tử này không chỉ giúp bạn gõ code nhanh hơn mà còn giúp trình biên dịch tối ưu hóa hiệu suất thực thi tốt hơn.',NULL,NULL,'2026-01-29 13:27:51'),(366,68,'code',1,'','#include <iostream>\nusing namespace std;\n\nint main() {\n    int a = 10, b = 3;\n    \n    // Phép chia nguyên\n    int thuong_nguyen = a / b;\n    int du = a % b;\n    \n    // Phép chia lấy phần thập phân\n    double thuong_thuc = (double)a / b;\n\n    cout << \"10 chia 3 duoc \" << thuong_nguyen << \" du \" << du << endl;\n    cout << \"Ket qua chinh xac: \" << thuong_thuc << endl;\n\n    // Sử dụng toán tử gán phức hợp\n    a += 5; // a luc nay la 15\n    cout << \"Gia tri moi cua a: \" << a << endl;\n\n    return 0;\n}','css','Trong ví dụ này, chúng ta thấy sự khác biệt rõ rệt giữa chia nguyên (/) và chia lấy dư (%). Ngoài ra, kỹ thuật ép kiểu (double)a được sử dụng để ép máy tính phải thực hiện phép chia số thực, giúp chúng ta có được kết quả chính xác đến từng chữ số thập phân.','2026-01-29 13:28:21'),(367,68,'theory',1,'Độ ưu tiên của toán tử','Giống như trong toán học, C++ tuân thủ nghiêm ngặt thứ tự thực hiện các phép tính. Các toán tử nhân, chia, lấy dư (*, /, %) có độ ưu tiên cao hơn cộng và trừ (+, -).\n\nNếu bạn muốn thay đổi thứ tự này, hãy sử dụng dấu ngoặc đơn (). Mọi thứ bên trong ngoặc luôn được tính toán trước. Một lời khuyên chuyên nghiệp: Ngay cả khi bạn nhớ rõ độ ưu tiên, việc sử dụng dấu ngoặc vẫn giúp mã nguồn của bạn trở nên rõ ràng và dễ đọc hơn cho người khác.',NULL,NULL,'2026-01-29 13:28:38'),(368,68,'theory',1,'Tổng kết bài học','- Toán tử = dùng để gán giá trị từ phải sang trái.\n- Chia hai số nguyên trong C++ sẽ luôn trả về một số nguyên.\n- Phép % cực kỳ hữu ích để xử lý các bài toán logic về chia hết.\n- Các toán tử như +=, -= giúp mã nguồn gọn gàng và chuyên nghiệp.\n- Luôn chú ý dấu ngoặc () để đảm bảo kết quả tính toán đúng như mong đợi.',NULL,NULL,'2026-01-29 13:29:01'),(369,69,'theory',1,'Toán tử quan hệ - Bản chất của việc so sánh trong C++','Trong lập trình, toán tử quan hệ được sử dụng để so sánh hai giá trị với nhau. Kết quả của một phép so sánh không phải là một con số, mà là một giá trị Boolean (true hoặc false).\n\nHãy tưởng tượng bạn đang viết một chương trình kiểm tra độ tuổi: age >= 18. Nếu đúng, cánh cửa sẽ mở (true), nếu sai, cánh cửa sẽ đóng (false). Các toán tử quan hệ bao gồm:\n- ==: So sánh bằng (Lưu ý: dùng 2 dấu bằng, 1 dấu bằng là phép gán!).\n- !=: So sánh không bằng (khác).\n- >, <: So sánh lớn hơn, nhỏ hơn.\n- >=, <=: So sánh lớn hơn hoặc bằng, nhỏ hơn hoặc bằng.',NULL,NULL,'2026-01-29 13:31:22'),(370,69,'theory',1,'Toán tử logic - Kết hợp các điều kiện','Đôi khi, một điều kiện đơn lẻ là không đủ. Ví dụ: Để được đi nghĩa vụ quân sự, bạn phải \"Đủ 18 tuổi\" VÀ \"Có sức khỏe tốt\". Lúc này, chúng ta cần đến các toán tử logic:\n- && (Logical AND): Trả về true khi tất cả các điều kiện đều đúng.\n- || (Logical OR): Trả về true khi ít nhất một điều kiện đúng.\n- ! (Logical NOT): Đảo ngược trạng thái của điều kiện (đúng thành sai, sai thành đúng).\n\nViệc kết hợp các toán tử này cho phép bạn xây dựng những bộ lọc dữ liệu cực kỳ phức tạp và chính xác.',NULL,NULL,'2026-01-29 13:32:05'),(371,69,'theory',1,'Bảng chân trị (Truth Table)','Để không bị nhầm lẫn khi viết code, bạn cần ghi nhớ bảng quy tắc sau:\n- Với && (VÀ): Chỉ cần một vế sai, kết quả sẽ là false. Nó cực kỳ nghiêm khắc.\n- Với || (HOẶC): Chỉ cần một vế đúng, kết quả sẽ là true. Nó rất dễ tính.\n- Với ! (PHỦ ĐỊNH): Chỉ đơn giản là nói ngược lại.\n\n**Kiểm tra điều kiện phức hợp**',NULL,NULL,'2026-01-29 13:32:48'),(372,69,'code',1,'','#include <iostream>\nusing namespace std;\n\nint main() {\n    int age = 20;\n    bool hasLicense = true;\n    bool isDrunk = false;\n\n    // Điều kiện: Đủ tuổi VÀ có bằng lái VÀ KHÔNG say xỉn\n    bool canDrive = (age >= 18) && hasLicense && !isDrunk;\n\n    cout << boolalpha; // Để in ra true/false thay vì 1/0\n    cout << \"Du dieu kien lai xe: \" << canDrive << endl;\n\n    // Ví dụ về toán tử Hoặc\n    bool isWeekend = true;\n    bool isHoliday = false;\n    bool canRest = isWeekend || isHoliday;\n    \n    cout << \"Co duoc nghi khong: \" << canRest << endl;\n\n    return 0;\n}','css','Trong mã nguồn này, chúng ta sử dụng boolalpha để màn hình in ra chữ true/false giúp dễ đọc hơn. Biến canDrive là kết quả của việc kết hợp 3 điều kiện bằng toán tử && và !. Chỉ cần bạn thay đổi isDrunk = true, kết quả canDrive sẽ ngay lập tức trở thành false.','2026-01-29 13:33:31'),(373,69,'theory',1,'Cơ chế Ngắt sớm (Short-circuiting)','Một bí mật nhỏ giúp C++ chạy nhanh:\n- Trong phép &&, nếu điều kiện đầu tiên đã false, C++ sẽ dừng lại ngay và kết luận là false mà không thèm nhìn các điều kiện phía sau.\n- Trong phép ||, nếu điều kiện đầu tiên đã true, C++ cũng sẽ dừng lại ngay và kết luận là true.\n\nHiểu được cơ chế này giúp bạn sắp xếp các điều kiện quan trọng hoặc nhẹ nhàng lên trước để tối ưu hóa chương trình.',NULL,NULL,'2026-01-29 13:33:57'),(374,69,'theory',1,'Tổng kết bài học','- So sánh: Luôn trả về giá trị kiểu bool.\n- Cẩn thận: Đừng nhầm lẫn giữa = (gán) và == (so sánh bằng).\n- Kết hợp: Dùng && khi muốn tất cả cùng đúng, || khi chỉ cần một cái đúng.\n- Đọc code: Luôn sử dụng dấu ngoặc đơn () khi kết hợp nhiều toán tử để code rõ ràng và tránh sai sót về độ ưu tiên.',NULL,NULL,'2026-01-29 13:34:20'),(375,70,'theory',1,'Ép kiểu dữ liệu là gì? (Data Casting)','Trong quá trình lập trình, không phải lúc nào các biến cũng có cùng kiểu dữ liệu khi thực hiện tính toán. Ép kiểu (Casting) là quá trình chuyển đổi một giá trị từ kiểu dữ liệu này sang kiểu dữ liệu khác.\n\nHãy tưởng tượng bạn đang có một chiếc hộp đựng nước (số thực) và muốn đổ nó vào một chiếc hộp đựng cát (số nguyên). Bạn cần một \"phép thuật\" để thực hiện việc này một cách an toàn mà không làm mất mát dữ liệu quá nhiều hoặc gây lỗi chương trình. C++ cung cấp hai cách để thực hiện việc này: Ngầm định (tự động) và Tường minh (chủ động).',NULL,NULL,'2026-01-29 13:35:25'),(376,70,'theory',1,'Ép kiểu ngầm định (Implicit Casting)','Đây là quá trình C++ tự động chuyển đổi kiểu dữ liệu nhỏ hơn sang kiểu dữ liệu lớn hơn để tránh mất dữ liệu. Quy tắc chung là \"thấp lên cao\":\n- char -> int -> float -> double.\nVí dụ: Khi bạn thực hiện phép cộng giữa một số int và một số double, máy tính sẽ tự động coi số int đó là double để kết quả đạt độ chính xác cao nhất. Đây là quá trình an toàn vì không làm mất đi giá trị của dữ liệu.',NULL,NULL,'2026-01-29 13:36:11'),(377,70,'theory',1,'Ép kiểu tường minh (Explicit Casting)','Khi bạn muốn chuyển từ một kiểu lớn về kiểu nhỏ (ví dụ: từ double về int), bạn phải thực hiện ép kiểu tường minh. \nLưu ý: Việc này có thể gây mất dữ liệu (phần thập phân sẽ bị cắt bỏ).\n- C-style cast: (int)3.14 -> kết quả là 3.\n- C++ static_cast: static_cast<int>(3.14) -> Đây là cách hiện đại, an toàn và được khuyến khích sử dụng trong C++ vì giúp trình biên dịch kiểm tra lỗi tốt hơn.',NULL,NULL,'2026-01-29 13:37:01'),(378,70,'theory',1,'Bảng mã ASCII - Khi ký tự là con số','Máy tính thực chất không hiểu chữ \'A\' hay \'B\', nó chỉ hiểu những con số. ASCII (American Standard Code for Information Interchange) là một bảng mã quy định mỗi ký tự sẽ tương ứng với một số nguyên cụ thể từ 0 đến 127.\n- Ký tự \'A\' có mã là 65.\n- Ký tự \'a\' có mã là 97.\n- Ký tự \'0\' có mã là 48.\n\nNhờ có ASCII, chúng ta có thể thực hiện các phép toán trên ký tự như: \'A\' + 1 sẽ cho ra kết quả là 66 (tương ứng với chữ \'B\'). Đây là nền tảng để xử lý chuỗi văn bản và mã hóa dữ liệu.\n\n**Kết hợp ép kiểu để giải mã ký tự**',NULL,NULL,'2026-01-29 13:37:37'),(379,70,'code',1,'','#include <iostream>\nusing namespace std;\n\nint main() {\n    // 1. Ép kiểu để chia lấy số thập phân\n    int a = 5, b = 2;\n    double ketQua = static_cast<double>(a) / b;\n    cout << \"5 chia 2 bang: \" << ketQua << endl;\n\n    // 2. Chuyển đổi ký tự sang mã ASCII và ngược lại\n    char ch = \'A\';\n    int maAscii = (int)ch;\n    \n    cout << \"Ky tu: \" << ch << \" co ma ASCII la: \" << maAscii << endl;\n    cout << \"Ky tu tiep theo la: \" << (char)(maAscii + 1) << endl;\n\n    // 3. Ví dụ về mất dữ liệu khi ép kiểu ngược\n    double pi = 3.99;\n    int piNguyen = (int)pi;\n    cout << \"Gia tri 3.99 sau khi ep kieu int: \" << piNguyen << endl;\n\n    return 0;\n}','css','Trong ví dụ này, static_cast<double>(a) giúp phép chia trả về 2.5 thay vì 2. Chúng ta cũng thấy cách \"ép\" một char sang int để xem mã ASCII và ngược lại. Lưu ý ở ví dụ cuối: ép kiểu int sẽ cắt bỏ hoàn toàn phần thập phân chứ không phải làm tròn (3.99 vẫn thành 3).','2026-01-29 13:38:16'),(380,70,'theory',1,'Tổng kết bài học','- Ép kiểu: Là chuyển đổi kiểu dữ liệu để phục vụ tính toán.\n- An toàn: Luôn ưu tiên dùng static_cast<kieu_du_lieu>(bien) trong C++.\n- Cẩn thận: Ép từ kiểu thực sang kiểu nguyên sẽ làm mất phần thập phân.\n- ASCII: Mỗi ký tự luôn đi kèm với một mã số nguyên, giúp thực hiện toán tử trên chữ cái.\n- Ứng dụng: Thường dùng để tính toán chính xác số thập phân hoặc xử lý các bài toán về chuỗi ký tự.',NULL,NULL,'2026-01-29 13:38:52'),(381,71,'theory',1,'Tại sao cần cấu trúc điều kiện?','Hãy tưởng tượng bạn đang lái xe và gặp một ngã ba đường. Nếu đèn xanh, bạn đi tiếp; nếu đèn đỏ, bạn dừng lại. Trong lập trình cũng vậy, không phải lúc nào chúng ta cũng muốn mọi dòng code đều được thực thi.\n\nCấu trúc điều kiện (Conditional Structures) cho phép chương trình kiểm tra một mệnh đề logic (đúng hoặc sai). Tùy vào kết quả đó, máy tính sẽ chọn đi theo con đường A hoặc con đường B. Đây chính là nền tảng để tạo ra các tính năng như: đăng nhập thành công hay thất bại, kiểm tra số dư tài khoản, hoặc phân loại học lực sinh viên.',NULL,NULL,'2026-01-29 13:40:53'),(382,71,'theory',2,'Cấu trúc if đơn giản','Đây là dạng cơ bản nhất. Máy tính sẽ kiểm tra điều kiện bên trong ngoặc đơn (). Nếu điều kiện đó là đúng (true), các dòng code bên trong khối lệnh {} sẽ được chạy. Nếu điều kiện sai (false), máy tính sẽ bỏ qua toàn bộ khối lệnh đó như chưa từng thấy chúng.\n\n**Lưu ý**: Nếu sau if chỉ có duy nhất một dòng lệnh, bạn có thể bỏ qua cặp ngoặc nhọn {}. Tuy nhiên, để code chuyên nghiệp và tránh lỗi \"ngớ ngẩn\" khi nâng cấp sau này, bạn nên luôn sử dụng cặp ngoặc nhọn.',NULL,NULL,'2026-01-29 13:41:07'),(383,71,'theory',4,'Cấu trúc if - else','Trong thực tế, chúng ta thường có phương án dự phòng: \"Nếu đúng thì làm việc A, ngược lại thì làm việc B\". Từ khóa else ra đời để đảm bảo rằng dù điều kiện đúng hay sai, chương trình vẫn thực hiện một hành động nào đó.\n\nKhối lệnh else không bao giờ đi kèm điều kiện riêng. Nó đóng vai trò là \"chiếc lưới hái\" tất cả các trường hợp mà if đã bỏ sót. Một khi đã có else, chắc chắn sẽ có một trong hai khối lệnh được thực thi.',NULL,NULL,'2026-01-29 13:41:19'),(384,71,'theory',6,'Cấu trúc else if và lồng nhau','Để xử lý các bài toán phân loại phức tạp (như xếp loại học lực: Xuất sắc, Giỏi, Khá, Trung bình), chúng ta sử dụng chuỗi if - else if - else.\n\nMáy tính sẽ kiểm tra từ trên xuống dưới. Ngay khi gặp một điều kiện đúng, nó sẽ thực thi khối lệnh tương ứng và thoát ngay lập tức khỏi toàn bộ cấu trúc điều kiện đó, bỏ qua tất cả các else if phía sau. Điều này giúp chương trình chạy cực kỳ tối ưu vì không phải kiểm tra những thứ không cần thiết.',NULL,NULL,'2026-01-29 13:41:31'),(385,71,'code',7,'','#include <iostream>\nusing namespace std;\n\nint main() {\n    double score;\n    cout << \"Nhap diem cua ban (0 - 10): \";\n    cin >> score;\n\n    if (score >= 8.0) {\n        cout << \"Xep loai: Gioi\" << endl;\n    } \n    else if (score >= 5.0) {\n        cout << \"Xep loai: Trung binh/Kha\" << endl;\n    } \n    else {\n        cout << \"Xep loai: Yeu (Can co gang hon)\" << endl;\n    }\n\n    return 0;\n}','css','Ở ví dụ này, nếu bạn nhập 8.5, máy tính kiểm tra score >= 8.0 thấy đúng, nó in \"Gioi\" và kết thúc. Nếu bạn nhập 6.5, nó thấy score >= 8.0 sai, nó mới chuyển xuống kiểm tra score >= 5.0. Việc sắp xếp thứ tự các điều kiện từ cao xuống thấp (hoặc ngược lại) là cực kỳ quan trọng trong logic lập trình.','2026-01-29 13:41:54'),(386,71,'theory',8,'Tổng kết bài học','- Điều kiện: Phải trả về giá trị bool (true hoặc false).\n- Cẩn thận: Đừng nhầm lẫn giữa = (gán) và == (so sánh bằng) bên trong if.\n- Thứ tự: Luôn đặt các điều kiện quan trọng hoặc bao quát lên trước.\n- Tối ưu: Sử dụng else if để tránh việc máy tính phải kiểm tra lại những điều kiện đã biết chắc là sai.\n- Thẩm mỹ: Luôn sử dụng ngoặc nhọn {} và lùi đầu dòng (indentation) để code dễ đọc, dễ bảo trì.',NULL,NULL,'2026-01-29 13:42:16'),(387,72,'theory',1,'Khi nào nên dùng Switch - Case?','Hãy tưởng tượng bạn đang đứng trong một thang máy. Thay vì phải hỏi: \"Nếu tôi muốn lên tầng 1? Nếu không thì lên tầng 2? Nếu không thì lên tầng 3?...\", bạn chỉ cần nhấn một nút số cụ thể.\n\nSwitch - Case hoạt động giống như bảng nút bấm đó. Nó được dùng khi bạn có một biến duy nhất và muốn so sánh biến đó với rất nhiều giá trị cụ thể (các hằng số). So với việc dùng quá nhiều if - else if lồng nhau, switch - case giúp mã nguồn của bạn sáng tỏ hơn, dễ đọc hơn và trong nhiều trường hợp, nó còn giúp máy tính thực thi nhanh hơn nhờ cơ chế \"nhảy thẳng\" đến kết quả đúng.',NULL,NULL,'2026-01-29 13:43:03'),(388,72,'theory',1,'Cú pháp và các từ khóa cốt lõi','Một khối switch được cấu thành từ 4 thành phần chính:\n- switch(biến): Nơi bạn đưa biến cần kiểm tra vào (phải là kiểu số nguyên hoặc ký tự).\n- case giá_trị:: Các tình huống có thể xảy ra. Nếu biến bằng giá trị này, code bên dưới sẽ chạy.\n- break;: Lệnh \"thoát hiểm\". Sau khi thực hiện xong một case, ta phải dùng break để thoát khỏi khối switch.\n- default:: Trường hợp mặc định. Nếu biến không khớp với bất kỳ case nào phía trên, code trong default sẽ được thực thi (tương tự như else cuối cùng).\n\n**Chuyển đổi con số thành văn bản**',NULL,NULL,'2026-01-29 13:43:28'),(389,72,'code',1,'','#include <iostream>\nusing namespace std;\n\nint main() {\n    int day;\n    cout << \"Nhap mot so (2-7): \";\n    cin >> day;\n\n    switch(day) {\n        case 2:\n            cout << \"Thu Hai\" << endl;\n            break;\n        case 3:\n            cout << \"Thu Ba\" << endl;\n            break;\n        case 4:\n            cout << \"Thu Tu\" << endl;\n            break;\n        case 5:\n            cout << \"Thu Nam\" << endl;\n            break;\n        default:\n            cout << \"Khong phai dau tuan!\" << endl;\n            break;\n    }\n\n    return 0;\n}','css','Chương trình lấy con số người dùng nhập và \"so khớp\" với các case. Nếu nhập số 3, máy tính nhảy thẳng đến case 3, in ra \"Thu Ba\" và gặp lệnh break để kết thúc. Nếu nhập số 9, không có case nào khớp, nó sẽ thực hiện lệnh trong default.','2026-01-29 13:44:03'),(390,72,'theory',1,'Tầm quan trọng của lệnh Break','Một trong những lỗi kinh điển của người mới học là quên lệnh break.\n\nTrong C++, nếu một case khớp nhưng không có break, máy tính sẽ không dừng lại mà tiếp tục thực hiện tất cả các lệnh ở các case bên dưới cho đến khi gặp break hoặc hết khối switch. Hiện tượng này gọi là \"trôi tự do\".\n\nTuy nhiên, đôi khi lập trình viên cố tình lợi dụng điều này để gộp nhiều case lại với nhau (ví dụ: case 2, 3, 4, 5, 6 đều in ra \"Ngày đi làm\"). Hãy luôn cẩn trọng với break để kiểm soát chính xác luồng chạy của chương trình.',NULL,NULL,'2026-01-29 13:44:19'),(391,72,'theory',1,'So sánh Switch - Case và If - Else','- Dùng Switch - Case khi: Bạn so sánh một biến duy nhất với các giá trị rời rạc, cụ thể (số nguyên, char, enum). Code sẽ rất sạch sẽ.\n\n- Dùng If - Else khi: Bạn cần so sánh các khoảng giá trị (ví dụ: score > 5 && score < 8), hoặc so sánh nhiều biến khác nhau, hoặc các biểu thức logic phức tạp.\n\nTrong lập trình chuyên nghiệp, việc chọn đúng cấu trúc điều khiển không chỉ thể hiện trình độ của bạn mà còn giúp việc bảo trì code sau này trở nên dễ dàng hơn rất nhiều.',NULL,NULL,'2026-01-29 13:44:36'),(392,72,'theory',1,'Tổng kết bài học','- Switch: Chỉ hoạt động với kiểu số nguyên (int, char, long...). Không dùng được với số thực (float, double).\n- Break: Luôn kiểm tra xem đã có break ở cuối mỗi case chưa nếu bạn không muốn code bị \"trôi\".\n- Default: Luôn nên có một case default để xử lý các tình huống ngoại lệ hoặc dữ liệu sai.\n- Gọn gàng: Tận dụng switch để thay thế cho các chuỗi if-else quá dài khi so sánh giá trị cụ thể.',NULL,NULL,'2026-01-29 13:45:00'),(393,73,'theory',1,'Toán tử 3 ngôi là gì?','Tại sao lại gọi là \"3 ngôi\"? Trong lập trình, hầu hết các toán tử chỉ có 1 ngôi (như ++x) hoặc 2 ngôi (như a + b). Toán tử 3 ngôi là toán tử duy nhất trong C++ nhận vào 3 thành phần (biểu thức) để xử lý.\n\nVề bản chất, nó là một dạng viết tắt của cấu trúc if - else đơn giản. Nó thường được sử dụng khi bạn muốn gán một giá trị cho biến dựa trên một điều kiện nào đó. Thay vì tốn 4-5 dòng code để viết if-else, bạn có thể giải quyết gọn gàng ngay trên một dòng.',NULL,NULL,'2026-01-29 13:46:06'),(394,73,'theory',2,'Cú pháp và Cách vận hành','Cú pháp của toán tử 3 ngôi như sau: biến = (điều_kiện) ? giá_trị_nếu_đúng : giá_trị_nếu_sai;\n\nCách máy tính tư duy:\n- Đầu tiên, nó kiểm tra (điều_kiện).\n- Nếu điều kiện Đúng, nó lấy giá trị sau dấu hỏi ?.\n- Nếu điều kiện Sai, nó lấy giá trị sau dấu hai chấm :.\n- Cuối cùng, kết quả chọn được sẽ được gán vào biến.',NULL,NULL,'2026-01-29 13:46:30'),(395,73,'code',3,'Từ If-Else sang Toán tử 3 ngôi','#include <iostream>\nusing namespace std;\n\nint main() {\n    int a = 10, b = 25;\n    \n    // Cách viết truyền thống với If-Else\n    int max_val;\n    if (a > b) {\n        max_val = a;\n    } else {\n        max_val = b;\n    }\n\n    // Cách viết hiện đại với Toán tử 3 ngôi\n    int shortcut_max = (a > b) ? a : b;\n\n    cout << \"So lon nhat la: \" << shortcut_max << endl;\n\n    // Ví dụ kiểm tra chẵn lẻ\n    int n = 7;\n    string result = (n % 2 == 0) ? \"So chan\" : \"So le\";\n    cout << n << \" la \" << result << endl;\n\n    return 0;\n}','javascript','Bạn có thể thấy sự khác biệt rõ rệt. shortcut_max được gán giá trị chỉ trong một dòng duy nhất. Mã nguồn không chỉ ngắn hơn mà còn rất dễ theo dõi luồng logic. Biến result cũng minh họa cách toán tử 3 ngôi có thể trả về các kiểu dữ liệu khác nhau như chuỗi (string).','2026-01-29 13:46:55'),(396,73,'theory',5,'Khi nào KHÔNG nên dùng toán tử 3 ngôi?','Mặc dù rất tiện lợi, nhưng bạn cần tỉnh táo khi sử dụng công cụ này.\n- Nên dùng: Khi logic rẽ nhánh cực kỳ đơn giản (gán giá trị, in thông báo ngắn).\n- Không nên dùng: Khi bạn có quá nhiều điều kiện lồng nhau (toán tử 3 ngôi lồng trong toán tử 3 ngôi khác). Việc lạm dụng sẽ biến dòng code của bạn thành một \"mê cung\" ký tự ? và :, khiến đồng nghiệp (hoặc chính bạn sau này) rất khó để đọc hiểu và sửa lỗi.\n\n**Quy tắc vàng**: Nếu bạn mất quá 3 giây để hiểu dòng code đó đang làm gì, hãy quay lại dùng if-else.',NULL,NULL,'2026-01-29 13:47:23'),(397,73,'theory',4,'Tại sao bạn thấy nó ở khắp mọi nơi?','Nếu bạn từng xem qua code JavaScript, React hay PHP, bạn sẽ thấy toán tử 3 ngôi xuất hiện dày đặc. Nó cực kỳ hữu ích trong việc hiển thị giao diện (ví dụ: Nếu isLoggedIn là true thì hiển thị nút \"Đăng xuất\", ngược lại hiển thị nút \"Đăng nhập\").\n\nLàm chủ toán tử này trong C++ sẽ giúp bạn làm quen với phong cách viết code hiện đại, chuẩn bị hành trang tốt cho bất kỳ ngôn ngữ lập trình nào khác mà bạn học sau này.',NULL,NULL,'2026-01-29 13:47:42'),(398,73,'theory',6,'Tổng kết bài học','- Cấu trúc: (Điều kiện) ? Đúng : Sai;\n- Vị trí: Thường nằm ở vế phải của một phép gán hoặc bên trong lệnh cout.\n- Kiểu dữ liệu: Hai giá trị trả về (sau dấu ? và :) nên cùng kiểu dữ liệu để tránh lỗi xung đột.\n- Tiêu chuẩn: Chỉ dùng cho các logic đơn giản để giữ cho code luôn sạch đẹp và dễ đọc.',NULL,NULL,'2026-01-29 13:48:02'),(399,74,'theory',1,'Tại sao chúng ta cần vòng lặp?','Hãy tưởng tượng bạn được yêu cầu chép phạt dòng chữ \"Tôi sẽ không đi học muộn\" 1000 lần. Nếu là con người, bạn sẽ mất hàng giờ và cực kỳ mệt mỏi. Nhưng với máy tính, bạn chỉ cần ra lệnh: \"Lặp lại việc in dòng chữ này 1000 lần\".\n\nVòng lặp (Loops) cho phép chúng ta thực thi một khối lệnh nhiều lần dựa trên một điều kiện nhất định. Đây là chìa khóa để xử lý các danh sách dữ liệu khổng lồ, tạo ra các chuyển động trong trò chơi, hoặc đơn giản là yêu cầu người dùng nhập lại cho đến khi đúng mật khẩu.',NULL,NULL,'2026-01-29 13:49:08'),(400,74,'theory',2,'Vòng lặp For - Biết trước số lần lặp','Vòng lặp for thường được sử dụng khi bạn biết chính xác mình muốn lặp lại bao nhiêu lần. Nó gói gọn cả 3 bước quản lý vòng lặp vào trong một dòng:\n- Khởi tạo: Tạo biến đếm (ví dụ: int i = 0).\n- Điều kiện: Kiểm tra xem có tiếp tục lặp không (ví dụ: i < 10).\n- Bước nhảy: Cập nhật biến đếm sau mỗi lần lặp (ví dụ: i++).\n\n**Cú pháp**: for (khởi_tạo; điều_kiện; bước_nhảy) { // khối lệnh }',NULL,NULL,'2026-01-29 13:49:37'),(401,74,'code',3,'','#include <iostream>\nusing namespace std;\n\nint main() {\n    cout << \"Bang cuu chuong 5:\" << endl;\n\n    for (int i = 1; i <= 10; i++) {\n        cout << \"5 x \" << i << \" = \" << 5 * i << endl;\n    }\n\n    return 0;\n}','css','Ở đây, i bắt đầu từ 1. Sau mỗi lần in ra kết quả, i tăng thêm 1 đơn vị. Vòng lặp sẽ tiếp diễn cho đến khi i bằng 11 (điều kiện i <= 10 sai), lúc đó máy tính sẽ dừng lại.','2026-01-29 13:49:55'),(402,74,'theory',4,'Vòng lặp While - Lặp khi còn đúng','Khác với for, vòng lặp While thường được dùng khi bạn không biết trước mình sẽ phải lặp bao nhiêu lần. Nó chỉ quan tâm đến một điều duy nhất: \"Chừng nào điều kiện còn ĐÚNG, tôi còn làm\".\n\nVí dụ điển hình là việc yêu cầu người dùng nhập mật khẩu: Bạn không biết họ sẽ nhập sai bao nhiêu lần, nhưng bạn biết chắc chắn rằng chừng nào họ nhập sai, bạn còn bắt họ nhập lại.\n\n**Cảnh báo:** Nếu điều kiện của while luôn luôn đúng, bạn sẽ rơi vào \"Vòng lặp vô tận\" (Infinite Loop), khiến chương trình bị treo.',NULL,NULL,'2026-01-29 13:50:12'),(403,74,'code',9,'','#include <iostream>\nusing namespace std;\n\nint main() {\n    int choice;\n\n    // Vong lap Do-While luon chay it nhat 1 lan\n    do {\n        cout << \"--- MENU ---\" << endl;\n        cout << \"1. Chon mon an\" << endl;\n        cout << \"0. Thoat\" << endl;\n        cout << \"Nhap lua chon: \";\n        cin >> choice;\n    } while (choice != 0);\n\n    cout << \"Tam biet!\";\n    return 0;\n}','css','Với while, nếu điều kiện sai ngay từ đầu, khối lệnh sẽ không bao giờ chạy. Nhưng với do-while, máy tính sẽ thực hiện khối lệnh trước, sau đó mới kiểm tra điều kiện. Điều này cực kỳ hữu ích cho việc hiển thị các Menu chức năng, nơi bạn muốn người dùng nhìn thấy menu ít nhất một lần trước khi họ chọn thoát.','2026-01-29 13:50:35'),(404,74,'theory',10,'Tổng kết bài học','- Dùng For: Khi biết rõ số lần lặp (ví dụ: lặp từ 1 đến 100).\n- Dùng While: Khi số lần lặp phụ thuộc vào một sự kiện hoặc dữ liệu đầu vào (ví dụ: đợi người dùng nhấn nút \'Q\').\n- Dùng Do-While: Khi bạn muốn khối lệnh chắc chắn được chạy ít nhất một lần đầu tiên.\n\n**Ghi nhớ**: Luôn đảm bảo có một \"lối thoát\" cho vòng lặp bằng cách cập nhật điều kiện hoặc sử dụng lệnh break.',NULL,NULL,'2026-01-29 13:51:11'),(405,75,'theory',1,'Lệnh break - Lối thoát hiểm tức thì','Lệnh break là một \"cú phanh gấp\" cho chương trình. Khi máy tính gặp lệnh này bên trong một vòng lặp (for, while, do-while) hoặc khối switch, nó sẽ ngay lập tức thoát khỏi khối lệnh đó và nhảy đến dòng code tiếp theo bên ngoài vòng lặp.\n\nHãy tưởng tượng bạn đang tìm kiếm một quân bài trong một bộ bài 52 lá. Ngay khi tìm thấy quân bài mình cần ở lá thứ 10, bạn sẽ không cần phải kiểm tra 42 lá còn lại nữa. Lúc này, break giúp bạn tiết kiệm thời gian và tài nguyên máy tính một cách đáng kể.\n\n**Hiện thực hóa mã nguồn với break**',NULL,NULL,'2026-01-29 13:52:09'),(406,75,'code',1,'','#include <iostream>\nusing namespace std;\n\nint main() {\n    cout << \"Cac so dau tien trong khoang 1-100 dung lai khi gap so chia het cho 7:\" << endl;\n\n    for (int i = 1; i <= 100; i++) {\n        if (i % 7 == 0) {\n            cout << \"Da tim thay so: \" << i << \". Thoat vong lap!\" << endl;\n            break; // Thoat ngay lap tuc\n        }\n        cout << \"Kiem tra so: \" << i << endl;\n    }\n\n    return 0;\n}','css','Vòng lặp được thiết lập để chạy đến 100. Tuy nhiên, nhờ lệnh break, ngay khi i đạt giá trị 7 (thỏa mãn điều kiện chia hết), chương trình sẽ in thông báo và dừng lại. Các số từ 8 đến 100 sẽ không bao giờ được kiểm tra.','2026-01-29 13:52:39'),(407,75,'theory',1,'Lệnh continue - Bước nhảy vọt qua rào cản','Khác với break (dừng hẳn), lệnh continue chỉ là một lệnh \"bỏ qua\". Khi gặp continue, máy tính sẽ bỏ qua tất cả các dòng code còn lại phía dưới nó trong lượt lặp hiện tại và lập tức quay trở lại đầu vòng lặp để bắt đầu một lượt mới.\n\nVí dụ: Bạn đang lọc danh sách học sinh để tặng quà, nhưng chỉ tặng cho những bạn không bị điểm kém. Khi gặp một bạn điểm kém, bạn \"bỏ qua\" (continue) bạn đó và chuyển sang xét bạn tiếp theo trong danh sách.\n\n**Hiện thực hóa mã nguồn với continue**',NULL,NULL,'2026-01-29 13:53:09'),(408,75,'code',1,'','#include <iostream>\nusing namespace std;\n\nint main() {\n    for (int i = 1; i <= 10; i++) {\n        if (i == 5) {\n            continue; // Nhay qua so 5, khong in ra\n        }\n        cout << i << \" \";\n    }\n    // Ket qua in ra: 1 2 3 4 6 7 8 9 10\n    return 0;\n}','css','Khi i bằng 5, lệnh continue được thực thi. Do đó, dòng lệnh cout << i ở phía dưới bị bỏ qua. Chương trình ngay lập tức quay lại đầu vòng lặp, tăng i lên 6 và tiếp tục công việc.','2026-01-29 13:53:29'),(409,75,'theory',1,'Lệnh goto - Cỗ máy thời gian đầy rủi ro','Lệnh goto cho phép bạn nhảy đến một nhãn (label) bất kỳ trong cùng một hàm. Nhãn được định nghĩa bằng một cái tên đi kèm dấu hai chấm (ví dụ: LU_LUONG_VUI_VE:).\n\n**Cảnh báo quan trọng**: Trong lập trình hiện đại, lệnh goto cực kỳ bị hạn chế sử dụng. Nó phá vỡ cấu trúc logic của chương trình và dễ tạo ra \"Code mì tôm\" (Spaghetti Code) — loại code đan xen chằng chịt, cực kỳ khó đọc và bảo trì. Lần duy nhất nó được coi là chấp nhận được là khi bạn cần thoát ra khỏi nhiều vòng lặp lồng nhau cùng một lúc. Ngoài trường hợp đó ra, hãy luôn tìm cách dùng break hoặc continue để thay thế.',NULL,NULL,'2026-01-29 13:53:48'),(410,75,'theory',1,'Tổng kết và Lời khuyên','- Sử dụng break: Khi bạn đã đạt được mục đích (tìm thấy dữ liệu) hoặc gặp lỗi nghiêm trọng cần dừng vòng lặp.\n\n- Sử dụng continue: Khi bạn muốn lọc bỏ các trường hợp không mong muốn mà không muốn dừng toàn bộ công việc.\n\n- Tránh xa goto: Đừng sử dụng nó trừ khi bạn thực sự hiểu rõ mình đang làm gì. Code sạch là code có luồng chạy rõ ràng, mạch lạc. Làm chủ được các lệnh này sẽ giúp bạn viết được những vòng lặp thông minh, hiệu quả và xử lý được các tình huống phức tạp trong thực tế.',NULL,NULL,'2026-01-29 13:54:12'),(411,76,'theory',1,'Mảng là gì?','Hãy tưởng tượng bạn là một quản lý thư viện. Thay vì để sách rải rác khắp nơi, bạn xếp chúng vào một dãy kệ sách được đánh số thứ tự từ 0. Mảng (Array) trong C++ chính là một dãy các ô nhớ liên tiếp nhau trong bộ nhớ RAM, dùng để lưu trữ các giá trị có cùng kiểu dữ liệu.\n\nĐặc điểm \"liên tiếp\" này cực kỳ quan trọng: Nó giúp máy tính truy cập dữ liệu cực nhanh vì chỉ cần biết vị trí ô đầu tiên là có thể tính toán được vị trí của bất kỳ ô nào khác trong dãy.',NULL,NULL,'2026-01-29 13:55:57'),(412,76,'theory',1,'Khai báo và Khởi tạo mảng','Để khai báo một mảng, bạn cần cung cấp 3 thông tin: Kiểu dữ liệu, Tên mảng, và Số lượng phần tử (kích thước mảng).\n- Cú pháp: kiểu_dữ_liệu tên_mảng[số_phần_tử];\n- Lưu ý: Số phần tử phải là một con số cụ thể (hằng số) vì máy tính cần biết chính xác cần bao nhiêu đất để \"xây nhà\" cho mảng ngay khi chương trình bắt đầu.\n- Khởi tạo: Bạn có thể gán giá trị ngay lúc khai báo bằng cặp ngoặc nhọn {}. Nếu bạn khai báo int a[10] = {0};, tất cả 10 phần tử sẽ được đặt về số 0.',NULL,NULL,'2026-01-29 13:56:18'),(413,76,'theory',1,'Chỉ số mảng (Index) - Quy tắc bắt đầu từ số 0','Trong C++, mảng luôn bắt đầu đánh số từ 0 chứ không phải từ 1.\n- Nếu mảng có n phần tử, thì phần tử cuối cùng sẽ có chỉ số là n-1.\n- Việc truy cập vào một chỉ số không tồn tại (ví dụ mảng có 5 phần tử nhưng bạn gọi a[5]) được gọi là Lỗi tràn mảng (Buffer Overflow). Đây là một trong những lỗi nguy hiểm nhất vì nó có thể làm chương trình bị treo hoặc làm sai lệch dữ liệu của các biến khác.',NULL,NULL,'2026-01-29 13:56:58'),(414,76,'code',1,'Sử dụng vòng lặp For để quản lý mảng','#include <iostream>\nusing namespace std;\n\nint main() {\n    int n;\n    cout << \"Nhap so luong phan tu: \";\n    cin >> n;\n\n    int arr[n]; // Lưu ý: C++ hiện đại hỗ trợ, nhưng tốt nhất nên dùng hằng số\n\n    // 1. Nhập dữ liệu cho mảng\n    for (int i = 0; i < n; i++) {\n        cout << \"Nhap phan tu thu \" << i << \": \";\n        cin >> arr[i];\n    }\n\n    // 2. Xuất dữ liệu mảng\n    cout << \"Day so ban vua nhap la: \";\n    for (int i = 0; i < n; i++) {\n        cout << arr[i] << \" \";\n    }\n\n    return 0;\n}','css','Vòng lặp for là người bạn thân thiết nhất của mảng. Chúng ta dùng biến đếm i chạy từ 0 đến n-1 để đại diện cho chỉ số của mảng. Mỗi lượt lặp, arr[i] sẽ truy cập vào đúng ô nhớ tương ứng để ghi hoặc đọc dữ liệu.','2026-01-29 13:57:26'),(415,76,'theory',1,'Tổng kết bài học','- Kiểu dữ liệu: Các phần tử trong mảng phải cùng kiểu (không thể trộn int với string).\n- Chỉ số: Luôn nhớ 0 là bắt đầu, n-1 là kết thúc.\n- Vòng lặp: Luôn dùng for để duyệt mảng.\n- Bộ nhớ: Mảng có kích thước cố định, hãy khai báo dư một chút nếu bạn không chắc chắn về số lượng dữ liệu sẽ nhận.',NULL,NULL,'2026-01-29 13:58:04'),(416,77,'theory',1,'Khái niệm mảng hai chiều','Hãy tưởng tượng một bảng tính Excel hoặc một bàn cờ vua. Thay vì chỉ có một hàng dài, chúng ta có nhiều hàng xếp chồng lên nhau. Trong C++, Mảng hai chiều thực chất là \"mảng của các mảng\".\n\nMỗi phần tử trong mảng hai chiều được xác định bởi hai chỉ số: Chỉ số hàng (Row index) và Chỉ số cột (Column index). Đây là cách tuyệt vời để lưu trữ các dữ liệu có tính chất tọa độ hoặc bảng biểu, nơi mỗi giá trị phụ thuộc vào hai yếu tố định danh cùng lúc.',NULL,NULL,'2026-01-29 13:59:35'),(417,77,'theory',1,'Khai báo và Khởi tạo','Để khai báo mảng hai chiều, bạn cần xác định số hàng và số cột tối đa.\n\n- Cú pháp: kiểu_dữ_liệu tên_mảng[số_hàng][số_cột];\n\n- Khởi tạo: Bạn có thể gán giá trị theo từng hàng để code trông rõ ràng hơn.',NULL,NULL,'2026-01-29 14:00:03'),(418,77,'code',1,'','int matrix[2][3] = {\n    {1, 2, 3}, // Hàng 0\n    {4, 5, 6}  // Hàng 1\n};','css','','2026-01-29 14:00:15'),(419,77,'theory',1,'','Nếu bạn không khởi tạo tất cả, các phần tử còn lại sẽ được mặc định là 0 (nếu mảng toàn cục hoặc được khởi tạo một phần).',NULL,NULL,'2026-01-29 14:00:23'),(420,77,'theory',1,'Truy cập phần tử và Chỉ số','Luôn ghi nhớ quy tắc vàng: array[row][column].\n- Chỉ số hàng chạy từ 0 đến số_hàng - 1.\n- Chỉ số cột chạy từ 0 đến số_cột - 1.\n- Ví dụ: matrix[0][2] sẽ truy cập vào phần tử ở hàng đầu tiên và cột thứ ba.\n\nViệc nhầm lẫn giữa hàng và cột là lỗi phổ biến nhất khiến chương trình truy cập sai vùng nhớ hoặc bị treo. Hãy luôn hình tượng hóa nó như việc bạn tìm phòng khách sạn: \"Tầng mấy (hàng), phòng số mấy (cột)?\".',NULL,NULL,'2026-01-29 14:00:45'),(421,77,'code',1,'','#include <iostream>\nusing namespace std;\n\nint main() {\n    int rows, cols;\n    cout << \"Nhap so hang va so cot: \";\n    cin >> rows >> cols;\n\n    int a[100][100]; // Khai bao mang du tru\n\n    // 1. Nhap mang 2 chieu\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            cout << \"Nhap a[\" << i << \"][\" << j << \"]: \";\n            cin >> a[i][j];\n        }\n    }\n\n    // 2. Xuat mang 2 chieu duoi dang bang\n    cout << \"\\nMa tran ban vua nhap la:\\n\";\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            cout << a[i][j] << \"\\t\"; // Dung \\t de cac cot thang hang\n        }\n        cout << endl; // Het mot hang thi xuong dong\n    }\n\n    return 0;\n}','css','Để xử lý mảng hai chiều, chúng ta dùng hai vòng lặp for lồng nhau. Vòng lặp bên ngoài (i) duyệt qua từng hàng, và vòng lặp bên trong (j) duyệt qua từng phần tử trong hàng đó (tức là duyệt cột). Đây là cấu trúc kinh điển mà bạn sẽ gặp lại rất nhiều trong xử lý ảnh hoặc lập trình game.','2026-01-29 14:01:05'),(422,77,'theory',1,'Tổng kết bài học','- Cú pháp: Luôn nhớ [hàng][cột].\n- Duyệt mảng: Luôn sử dụng ít nhất 2 vòng lặp lồng nhau.\n- Bộ nhớ: Mảng 2 chiều tiêu tốn bộ nhớ rất nhanh (ví dụ: int a[1000][1000] chiếm khoảng 4MB RAM). Hãy khai báo kích thước vừa đủ dùng.\n- Trình bày: Sử dụng \\t và endl khi xuất mảng để dữ liệu hiển thị đúng định dạng bảng, giúp bạn dễ dàng kiểm tra lỗi.',NULL,NULL,'2026-01-29 14:01:32'),(423,78,'theory',1,'Bản chất của chuỗi trong C++','Hãy coi chuỗi ký tự là một \"chuỗi hạt\", trong đó mỗi hạt là một ký tự (char). Trong C++, có hai cách để tạo ra chuỗi này:\n- C-style String: Bản chất là một mảng các ký tự (ví dụ: char name[50]). Đây là cách cũ, khá phức tạp vì bạn phải tự quản lý kích thước và bộ nhớ.\n- std::string: Là một \"kiểu dữ liệu thông minh\" từ thư viện chuẩn của C++. Nó giống như một sợi dây thun co giãn, tự động phình to hoặc thu nhỏ tùy theo độ dài văn bản bạn đưa vào.\n\nTrong khóa học này, chúng ta sẽ tập trung vào std::string vì tính tiện dụng, an toàn và chuyên nghiệp của nó trong phát triển phần mềm hiện đại.',NULL,NULL,'2026-01-29 14:03:42'),(424,78,'theory',1,'Khai báo và nhập xuất chuỗi','Để sử dụng string, bạn cần khai báo thư viện #include <string>.\n- Lệnh cin >>: Chỉ lấy được một từ duy nhất. Nó sẽ ngừng đọc ngay khi gặp khoảng trắng hoặc dấu cách.\n- Lệnh getline(cin, biến_chuỗi): Đây là \"vũ khí\" để lấy toàn bộ dòng chữ bao gồm cả khoảng trắng (ví dụ khi nhập họ và tên).\n\nMột lưu ý nhỏ: Nếu bạn vừa dùng cin >> cho một con số, sau đó dùng ngay getline, chương trình sẽ bị \"trôi lệnh\" do ký tự xuống dòng còn sót lại. Hãy dùng cin.ignore() để dọn dẹp bộ đệm trước khi gọi getline.',NULL,NULL,'2026-01-29 14:04:14'),(425,78,'code',1,'Các phép toán cơ bản trên Chuỗi','#include <iostream>\n#include <string> // Bat buoc phai co\nusing namespace std;\n\nint main() {\n    string firstName = \"Hoang\";\n    string lastName = \"Nguyen\";\n\n    // 1. Phep noi chuoi (Concatenation)\n    string fullName = firstName + \" \" + lastName;\n    cout << \"Ho ten: \" << fullName << endl;\n\n    // 2. Lay do dai chuoi\n    cout << \"So ky tu: \" << fullName.length() << endl;\n\n    // 3. Truy cap tung ky tu (Giong het Mang)\n    cout << \"Ky tu dau tien: \" << fullName[0] << endl;\n\n    return 0;\n}','css','Trong C++, việc nối hai đoạn văn bản đơn giản như một phép cộng +. Để biết chuỗi có bao nhiêu ký tự, chúng ta dùng hàm .length() hoặc .size(). Lưu ý rằng chuỗi cũng bắt đầu đánh số chỉ số từ 0 giống như mảng đã học ở Chương 4.','2026-01-29 14:04:34'),(426,78,'theory',1,'So sánh và Tìm kiếm chuỗi','So sánh (==, !=): C++ cho phép bạn so sánh hai chuỗi trực tiếp. Phép so sánh dựa trên thứ tự bảng chữ cái (mã ASCII). Ví dụ: \"Apple\" sẽ đứng trước \"Banana\".\n\nTìm kiếm (.find()): Giúp bạn tìm một từ có nằm trong đoạn văn hay không. Nếu không tìm thấy, nó sẽ trả về một giá trị đặc biệt gọi là string::npos.\n\nCắt chuỗi (.substr(vị_trí, độ_dài)): Trích xuất một phần của chuỗi ban đầu để tạo ra chuỗi mới.',NULL,NULL,'2026-01-29 14:04:53'),(427,78,'code',1,'','#include <iostream>\n#include <string>\nusing namespace std;\n\nint main() {\n    string msg = \"hello codepulse\";\n\n    // Bien ky tu dau tien thanh chu hoa\n    if (!msg.empty()) {\n        msg[0] = toupper(msg[0]);\n    }\n\n    // Tim va thay the mot tu\n    size_t pos = msg.find(\"hello\");\n    if (pos != string::npos) {\n        msg.replace(pos, 5, \"Welcome to\");\n    }\n\n    cout << \"Ket qua: \" << msg << endl;\n\n    return 0;\n}','css','Đoạn code minh họa cách chúng ta có thể can thiệp vào từng ký tự trong chuỗi thông qua chỉ số []. Hàm toupper() dùng để in hoa ký tự, và hàm .replace() giúp chúng ta thay thế một cụm từ này bằng một cụm từ khác một cách nhanh chóng.','2026-01-29 14:05:16'),(428,78,'theory',1,'Tổng kết bài học','- Luôn dùng #include <string> và kiểu dữ liệu string.\n- Dùng getline() thay cho cin nếu cần nhập chuỗi có dấu cách.\n- Nhớ rằng chuỗi là mảng ký tự, bắt đầu từ chỉ số 0.\n- Tận dụng các hàm có sẵn như .length(), .find(), .substr() để tiết kiệm thời gian viết code.\n- Luôn kiểm tra chuỗi có rỗng hay không bằng .empty() trước khi truy cập vào các phần tử của nó để tránh lỗi treo chương trình.',NULL,NULL,'2026-01-29 14:05:36'),(429,79,'theory',1,'Chuyển đổi giữa Số và Chuỗi (Conversion)','Trong thực tế, dữ liệu nhập từ người dùng hoặc từ file luôn ở dạng chuỗi. Để tính toán, bạn cần chuyển chúng về dạng số. Ngược lại, để hiển thị kết quả lên giao diện đẹp mắt, bạn cần chuyển số thành chuỗi. C++ cung cấp các hàm cực kỳ tiện lợi:\nTừ Số sang Chuỗi: Sử dụng to_string(value). Hàm này chấp nhận hầu hết các kiểu số (int, double, float...).\n\nTừ Chuỗi sang Số:\n- stoi(s): String to Integer.\n- stod(s): String to Double.\n- stoll(s): String to Long Long.\n\nLưu ý: Nếu chuỗi không chứa số hợp lệ, chương trình sẽ báo lỗi (exception). Luôn đảm bảo dữ liệu đầu vào \"sạch\" trước khi chuyển đổi.',NULL,NULL,'2026-01-29 14:07:04'),(430,79,'theory',1,'Cắt, Xóa và Chèn (Substr, Erase, Insert)','Để xử lý các chuỗi phức tạp, bạn cần khả năng \"phẫu thuật\" chúng:\n- s.substr(pos, len): Trích xuất một chuỗi con bắt đầu từ vị trí pos với độ dài len. Nếu bỏ qua len, nó sẽ lấy đến hết chuỗi.\n- s.erase(pos, len): Xóa bỏ một đoạn ký tự. Rất hữu ích khi bạn muốn loại bỏ các ký tự thừa hoặc nhạy cảm.\n- s.insert(pos, str): Chèn một chuỗi khác vào vị trí bất kỳ mà không làm mất dữ liệu cũ.\n- s.clear(): Xóa sạch toàn bộ nội dung chuỗi, đưa chuỗi về trạng thái rỗng (độ dài bằng 0).',NULL,NULL,'2026-01-29 14:07:32'),(431,79,'code',1,'Tìm kiếm nâng cao với find và rfind','#include <iostream>\n#include <string>\nusing namespace std;\n\nint main() {\n    string path = \"C:/Users/CodePulse/Documents/cpp_lesson.mp4\";\n\n    // Tìm vị trí dấu chấm cuối cùng để lấy đuôi file\n    size_t lastDot = path.rfind(\'.\');\n    \n    if (lastDot != string::npos) {\n        string extension = path.substr(lastDot);\n        cout << \"Dinh dang file: \" << extension << endl;\n    }\n\n    // Tìm kiếm sự xuất hiện của từ khóa\n    if (path.find(\"CodePulse\") != string::npos) {\n        cout << \"Day la file cua he thong CodePulse.\" << endl;\n    }\n\n    return 0;\n}','css','Hàm rfind() (Reverse Find) bắt đầu tìm kiếm từ cuối chuỗi ngược lên đầu. Đây là kỹ thuật kinh điển để xử lý đường dẫn file hoặc trích xuất tên miền từ email. Kết quả trả về là size_t (một kiểu số nguyên không âm), nếu không thấy sẽ trả về hằng số string::npos','2026-01-29 14:07:54'),(432,79,'theory',1,'Sức mạnh của stringstream - Tách chuỗi chuyên nghiệp','Đây là kỹ thuật \"thượng thừa\" để xử lý các chuỗi dài (như một câu văn). Thư viện <sstream> cung cấp đối tượng stringstream, cho phép bạn coi một chuỗi giống như một luồng dữ liệu (giống như cin).\n\nKhi bạn đẩy một chuỗi vào stringstream, bạn có thể dùng toán tử >> để trích xuất từng từ ra một cách cực kỳ dễ dàng. Máy tính sẽ tự động lấy khoảng trắng làm dấu hiệu để phân tách. Đây là cách nhanh nhất để đếm số từ trong một câu hoặc chuẩn hóa họ tên (viết hoa chữ cái đầu của từng từ).',NULL,NULL,'2026-01-29 14:08:09'),(433,79,'code',1,'','#include <iostream>\n#include <string>\n#include <sstream> // Thu vien quan trong\nusing namespace std;\n\nint main() {\n    string sentence = \"Hoc lap trinh tai CodePulse that de\";\n    stringstream ss(sentence);\n    string word;\n    int count = 0;\n\n    cout << \"Cac tu co trong cau la:\" << endl;\n    while (ss >> word) { // Tach tung tu cho den het chuoi\n        count++;\n        cout << \"Tu thu \" << count << \": \" << word << endl;\n    }\n\n    cout << \"Tong cong co: \" << count << \" tu.\";\n\n    return 0;\n}','css','Vòng lặp while (ss >> word) sẽ liên tục trích xuất các từ cho đến khi không còn gì trong luồng dữ liệu. Cách làm này cực kỳ mạnh mẽ vì nó tự động xử lý mọi loại khoảng trắng (dấu cách, tab, xuống dòng) giữa các từ cho bạn.','2026-01-29 14:08:23'),(434,79,'theory',1,'Tổng kết bài học','- Luôn dùng stoi, stod, to_string để chuyển đổi dữ liệu linh hoạt.\n- Sử dụng substr() khi cần trích xuất thông tin cụ thể (ví dụ: lấy mã số sinh viên từ một chuỗi dài).\n- Sử dụng rfind() khi cần tìm kiếm các dấu hiệu từ phía cuối chuỗi.\n- Tư duy cốt lõi: Nếu bài toán yêu cầu xử lý từng từ trong một câu, hãy nghĩ ngay đến stringstream.\n- Kiểm tra kỹ các tham số vị trí (pos) để tránh lỗi truy cập ngoài phạm vi chuỗi (out of range).',NULL,NULL,'2026-01-29 14:08:48'),(435,80,'theory',1,'Hàm là gì? Tại sao phải chia để trị?','Hãy tưởng tượng bạn đang xây dựng một ngôi nhà. Bạn không tự mình làm tất cả mọi việc; bạn sẽ thuê thợ điện, thợ ống nước và thợ nề. Mỗi người thợ đảm nhận một nhiệm vụ chuyên biệt. Hàm (Function) trong lập trình chính là những \"người thợ\" đó.\n\nHàm là một khối mã được đặt tên và thực hiện một nhiệm vụ cụ thể. Thay vì viết đi viết lại một đoạn code tính toán 10 lần, bạn chỉ cần viết nó 1 lần vào trong một hàm và gọi nó bất cứ khi nào cần.\n\nLợi ích của hàm:\n- Tái sử dụng (Reusability): Viết một lần, dùng mãi mãi.\n- Dễ bảo trì: Nếu có lỗi, bạn chỉ cần sửa ở một nơi duy nhất.\n- Sạch sẽ: Giúp hàm main() của bạn ngắn gọn và dễ đọc hơn.',NULL,NULL,'2026-01-29 14:11:27'),(436,80,'theory',1,'Cấu trúc của một Hàm chuẩn','Để khai báo một hàm trong C++, bạn cần xác định rõ bộ khung sau:\n- Kiểu trả về (Return Type): Kiểu dữ liệu mà hàm sẽ trả về sau khi làm xong việc (ví dụ: int, double, string). Nếu hàm không trả về gì, ta dùng kiểu void.\n- Tên hàm (Function Name): Thường bắt đầu bằng một động từ (ví dụ: calculateSum, printReport).\n- Tham số (Parameters): Các dữ liệu đầu vào mà hàm cần để xử lý (nằm trong ngoặc đơn).\n- Thân hàm (Body): Khối lệnh xử lý logic nằm trong cặp ngoặc nhọn { }.',NULL,NULL,'2026-01-29 14:12:25'),(437,80,'code',1,'Hàm không trả về giá trị (Void Functions)','#include <iostream>\nusing namespace std;\n\n// Khai bao ham (Function Prototype)\nvoid sayHello(string name) {\n    cout << \"Chao mung \" << name << \" den voi CodePulse!\" << endl;\n}\n\nint main() {\n    // Goi ham\n    sayHello(\"Hoang\");\n    sayHello(\"An\");\n    \n    return 0;\n}','css','Hàm sayHello có kiểu trả về là void vì nó chỉ thực hiện việc in ra màn hình mà không tính toán ra một giá trị nào để trả lại cho chương trình. Tham số name giúp hàm trở nên linh hoạt hơn khi có thể chào hỏi bất kỳ ai.','2026-01-29 14:12:45'),(438,80,'code',1,'Hàm có trả về giá trị (Return Functions)','#include <iostream>\nusing namespace std;\n\n// Ham tinh dien tich hinh chu nhat\ndouble tinhDienTich(double dai, double rong) {\n    double ketQua = dai * rong;\n    return ketQua; // Tra ket qua ve cho noi goi ham\n}\n\nint main() {\n    double d = 5.5, r = 3.0;\n    \n    // Luu ket qua cua ham vao mot bien\n    double s = tinhDienTich(d, r);\n    \n    cout << \"Dien tich la: \" << s << endl;\n    \n    return 0;\n}','css','Từ khóa return cực kỳ quan trọng. Nó đánh dấu điểm kết thúc của hàm và \"ném\" giá trị kết quả ra ngoài để hàm main() hoặc các hàm khác có thể sử dụng. Sau khi gặp lệnh return, mọi dòng code phía dưới nó trong hàm đó sẽ không được thực thi.','2026-01-29 14:13:04'),(439,80,'theory',1,'Biến cục bộ và Biến toàn cục (Scope)','- Biến cục bộ (Local Variables): Là những biến được khai báo bên trong một hàm. Chúng chỉ \"sống\" bên trong hàm đó và sẽ biến mất khi hàm kết thúc. Hàm main() không thể nhìn thấy biến của hàm tinhDienTich().\n- Biến toàn cục (Global Variables): Được khai báo bên ngoài tất cả các hàm. Mọi hàm trong chương trình đều có thể truy cập và thay đổi giá trị của nó.\n\n**Lời khuyên**: Nên hạn chế dùng biến toàn cục vì nó khiến chương trình khó kiểm soát lỗi. Hãy ưu tiên dùng tham số để truyền dữ liệu vào hàm.',NULL,NULL,'2026-01-29 14:13:29'),(440,80,'theory',1,'Tổng kết bài học','- Xác định rõ mục tiêu của hàm trước khi viết.\n- Chọn kiểu trả về phù hợp (void nếu chỉ in/làm việc, int/double... nếu cần kết quả).\n- Đặt tên hàm rõ ràng, mang tính hành động.\n- Luôn khai báo hàm trước khi gọi nó trong main() hoặc sử dụng bản khai báo mẫu (Prototype) ở trên đầu file.\n- Kiểm tra kỹ các tham số truyền vào để đảm bảo tính đúng đắn của dữ liệu.',NULL,NULL,'2026-01-29 14:13:51'),(441,81,'theory',1,'Phân biệt Tham số và Đối số','Trong lập trình, chúng ta thường dùng lẫn lộn hai khái niệm này, nhưng để chuyên nghiệp, bạn cần phân biệt rõ:\n- Tham số (Parameter): Là những biến được khai báo trong phần định nghĩa hàm (nằm trong ngoặc đơn). Hãy coi chúng là những \"biến hình thức\" hoặc cái khuôn chờ sẵn dữ liệu.\n- Đối số (Argument): Là giá trị thực tế mà bạn truyền vào khi gọi hàm. Đây là dữ liệu thật sẽ được đổ vào cái khuôn đã chuẩn bị.\n\nVí dụ: Trong hàm void tinhTong(int a, int b), thì a và b là tham số. Khi bạn gọi tinhTong(5, 10), thì 5 và 10 chính là đối số.',NULL,NULL,'2026-01-29 14:14:54'),(442,81,'theory',1,'Truyền tham trị (Pass by Value)','Đây là kiểu truyền mặc định trong C++. Khi bạn truyền một đối số vào hàm theo cách này, máy tính sẽ tạo ra một bản sao của dữ liệu đó và đưa bản sao vào hàm.\n- Đặc điểm: Mọi thay đổi đối với tham số bên trong hàm chỉ tác động lên bản sao.\n- Kết quả: Biến gốc ở bên ngoài hàm hoàn toàn không bị ảnh hưởng.\n- Nhược điểm: Nếu dữ liệu rất lớn (như một mảng chứa hàng triệu phần tử), việc photocopy sẽ làm tốn bộ nhớ và giảm tốc độ chương trình.',NULL,NULL,'2026-01-29 14:15:11'),(443,81,'theory',1,'Truyền tham chiếu (Pass by Reference)','Để truyền tham chiếu, chúng ta thêm dấu & vào trước tên tham số trong định nghĩa hàm. Lúc này, hàm không tạo bản sao nữa mà sẽ sử dụng trực tiếp địa chỉ của biến gốc.\n- Đặc điểm: Tham số trong hàm lúc này đóng vai trò như một \"biệt danh\" (alias) của biến gốc.\n- Kết quả: Mọi thay đổi bên trong hàm sẽ tác động trực tiếp và làm thay đổi giá trị của biến gốc ở bên ngoài.\n- Ưu điểm: Cực kỳ nhanh vì không tốn công sao chép dữ liệu, thường dùng khi muốn hàm trả về nhiều hơn một giá trị hoặc xử lý dữ liệu lớn.',NULL,NULL,'2026-01-29 14:15:33'),(444,81,'code',1,'Phép thử \"Hoán đổi\" (Swap)','#include <iostream>\nusing namespace std;\n\n// Truyen tham tri: Khong thay doi duoc goc\nvoid swapValue(int a, int b) {\n    int temp = a;\n    a = b;\n    b = temp;\n}\n\n// Truyen tham chieu: Thay doi truc tiep bien goc\nvoid swapReference(int &a, int &b) {\n    int temp = a;\n    a = b;\n    b = temp;\n}\n\nint main() {\n    int x = 5, y = 10;\n\n    swapValue(x, y);\n    cout << \"Sau swapValue: x = \" << x << \", y = \" << y << endl; // Van la 5, 10\n\n    swapReference(x, y);\n    cout << \"Sau swapReference: x = \" << x << \", y = \" << y << endl; // Da thanh 10, 5\n\n    return 0;\n}','css','Bạn có thể thấy swapValue thất bại vì nó chỉ tráo đổi hai \"bản sao\" của x và y. Trong khi đó, swapReference thành công rực rỡ vì nhờ dấu &, nó đã thò tay ra ngoài hàm main để tráo đổi trực tiếp giá trị của hai ngăn tủ x và y.','2026-01-29 14:16:01'),(445,81,'code',1,'Tham số mặc định (Default Parameters)','#include <iostream>\nusing namespace std;\n\n// Tham so \'msg\' co gia tri mac dinh neu nguoi dung khong truyen vao\nvoid displayInfo(string name, string msg = \"Chao mung ban!\") {\n    cout << name << \": \" << msg << endl;\n}\n\nint main() {\n    displayInfo(\"Hoang\"); // Dung gia tri mac dinh\n    displayInfo(\"An\", \"Chuc mung sinh nhat!\"); // Ghi de gia tri mac dinh\n    \n    return 0;\n}','javascript','Tham số mặc định giúp hàm linh hoạt hơn. Quy tắc quan trọng là các tham số mặc định phải luôn được đặt ở cuối cùng trong danh sách tham số. Nếu bạn không truyền đối số tương ứng, C++ sẽ tự động sử dụng giá trị bạn đã thiết lập sẵn.','2026-01-29 14:16:21'),(446,81,'theory',1,'Tổng kết bài học','- Tham trị (Value): Dùng cho các kiểu dữ liệu nhỏ (int, char, bool) và khi bạn KHÔNG muốn hàm làm thay đổi dữ liệu gốc.\n- Tham chiếu (Reference): Dùng khi bạn muốn hàm thay đổi biến gốc hoặc khi truyền các dữ liệu lớn (string, array, struct) để tiết kiệm bộ nhớ.\n- Const Reference: Dùng const string &s nếu muốn truyền dữ liệu lớn để chạy nhanh nhưng vẫn muốn bảo vệ dữ liệu không bị hàm thay đổi nhầm.\n- Mặc định: Tận dụng tham số mặc định để giảm bớt số lần phải truyền các giá trị lặp đi lặp lại',NULL,NULL,'2026-01-29 14:16:43'),(447,82,'theory',1,'Khái niệm đối số mặc định','Đối số mặc định là giá trị được trình biên dịch tự động gán vào tham số của hàm nếu người gọi hàm không truyền giá trị cho tham số đó.\n\nHãy tưởng tượng bạn đang viết một hàm để in lời chào. Phần lớn người dùng sử dụng tiếng Anh, nên bạn đặt mặc định ngôn ngữ là \"English\". Nếu người dùng không nói gì, máy tính sẽ tự hiểu là tiếng Anh. Nếu họ muốn tiếng Việt, họ chỉ cần truyền thêm giá trị \"Vietnamese\" để ghi đè lên giá trị mặc định đó.',NULL,NULL,'2026-01-29 14:18:59'),(448,82,'theory',1,'Quy tắc Từ phải sang trái','C++ rất khắt khe trong việc đặt đối số mặc định. Bạn không thể đặt một đối số mặc định đứng trước một đối số bắt buộc.\n\n**Quy tắc**: Các đối số mặc định phải luôn nằm ở cuối cùng (bên phải nhất) trong danh sách tham số.\n\n**Giải thích**: Khi bạn gọi hàm và thiếu đối số, máy tính sẽ khớp các giá trị bạn truyền vào cho các tham số từ trái sang trước. Những vị trí trống còn lại ở bên phải sẽ được lấp đầy bằng giá trị mặc định.',NULL,NULL,'2026-01-29 14:19:24'),(449,82,'code',1,'','#include <iostream>\nusing namespace std;\n\n// Thue (tax) mac dinh la 10% (0.1), giam gia (discount) mac dinh la 0\ndouble tinhTongTien(double giaTri, double thue = 0.1, double giamGia = 0.0) {\n    double sauThue = giaTri + (giaTri * thue);\n    return sauThue - giamGia;\n}\n\nint main() {\n    double sp1 = 100.0;\n\n    // Truong hop 1: Dung tat ca mac dinh\n    cout << \"Tong tien (mac dinh): \" << tinhTongTien(sp1) << endl;\n\n    // Truong hop 2: Thay doi thue, dung giam gia mac dinh\n    cout << \"Tong tien (thue 5%): \" << tinhTongTien(sp1, 0.05) << endl;\n\n    // Truong hop 3: Thay doi tat ca\n    cout << \"Tong tien (thue 8%, giam 10$): \" << tinhTongTien(sp1, 0.08, 10.0) << endl;\n\n    return 0;\n}','css','Trong hàm tinhTongTien, chúng ta chỉ bắt buộc phải truyền giaTri. Nếu không truyền thue và giamGia, hàm sẽ tự lấy 0.1 và 0.0. Lưu ý cách gọi ở Trường hợp 2: giá trị 0.05 sẽ được hiểu là của thue vì nó đứng kế tiếp sau giaTri.','2026-01-29 14:19:48'),(450,82,'theory',1,'Prototype hay Definition?','Một quy tắc quan trọng khác: Bạn chỉ nên viết giá trị mặc định ở một nơi duy nhất.\n- Nếu bạn có khai báo mẫu (Function Prototype) ở trên đầu file, hãy đặt giá trị mặc định ở đó.\n- Không nên lặp lại giá trị mặc định ở phần định nghĩa thân hàm bên dưới. Việc viết ở cả hai nơi có thể gây ra lỗi biên dịch hoặc gây nhầm lẫn khi bạn muốn thay đổi giá trị này sau này.',NULL,NULL,'2026-01-29 14:20:08'),(451,82,'theory',1,'Cạm bẫy chồng lấp (Ambiguity)','Hãy cẩn thận khi kết hợp Đối số mặc định với Nạp chồng hàm (Function Overloading). Ví dụ: Bạn có hai hàm:\n- void print(int x);\n- void print(int x, int y = 10);\n\nKhi bạn gọi print(5);, máy tính sẽ không biết nên chạy hàm số 1 hay hàm số 2 (vì hàm số 2 cũng có thể chạy chỉ với 1 tham số). Đây gọi là lỗi mơ hồ (Ambiguous). Hãy luôn giữ cho logic của bạn rõ ràng để tránh làm khó trình biên dịch.',NULL,NULL,'2026-01-29 14:20:33'),(452,82,'theory',1,'Tổng kết bài học','- Lợi ích: Giảm số lượng tham số phải truyền khi gọi hàm, giúp code gọn hơn.\n- Vị trí: Luôn đặt ở các tham số cuối cùng bên phải.\n- Khai báo: Nên đặt ở Function Prototype.\n- Ghi đè: Truyền đối số mới sẽ thay thế hoàn toàn giá trị mặc định.\n- Cảnh báo: Tránh gây mơ hồ khi kết hợp với Overloading.',NULL,NULL,'2026-01-29 14:20:56'),(453,83,'theory',1,'Tại sao cần Hàm nguyên mẫu?','Trình biên dịch C++ hoạt động theo nguyên tắc đọc từ trên xuống dưới (top-to-bottom). Nếu bạn gọi một hàm ở dòng 10 nhưng mãi đến dòng 20 mới định nghĩa hàm đó, trình biên dịch sẽ \"bối rối\" và báo lỗi vì nó chưa biết hàm đó là gì.\n\nHàm nguyên mẫu (Function Prototype) đóng vai trò như một lời thông báo trước với máy tính: \"Này, tôi sẽ dùng một cái hàm có tên là X, nhận vào dữ liệu kiểu Y và trả về kiểu Z. Chi tiết cách làm việc thì tôi sẽ viết ở phía dưới nhé!\". Điều này giúp trình biên dịch yên tâm đi tiếp mà không báo lỗi \"không tìm thấy hàm\".',NULL,NULL,'2026-01-29 14:22:25'),(454,83,'theory',1,'Cú pháp khai báo Prototype','Cú pháp của hàm nguyên mẫu cực kỳ đơn giản. Nó chính là dòng đầu tiên của hàm (Header) nhưng kết thúc bằng dấu chấm phẩy ; thay vì cặp ngoặc nhọn { }.\n\nCấu trúc: kiểu_trả_về tên_hàm(kiểu_tham_số_1, kiểu_tham_số_2, ...);\n\nMột điểm thú vị là trong Prototype, bạn không nhất thiết phải đặt tên cho tham số, chỉ cần liệt kê kiểu dữ liệu là đủ.\n\nVí dụ: int tinhTong(int, int); là hoàn toàn hợp lệ. Tuy nhiên, việc đặt tên (ví dụ: int tinhTong(int a, int b);) vẫn được khuyến khích để mã nguồn dễ hiểu hơn.',NULL,NULL,'2026-01-29 14:22:39'),(455,83,'code',1,'','#include <iostream>\nusing namespace std;\n\n// 1. KHAI BÁO HÀM NGUYÊN MẪU (Prototype)\nvoid hienThiKetQua(int num);\nint tinhBinhPhuong(int x);\n\nint main() {\n    int n = 5;\n    \n    // Gọi hàm một cách bình thường\n    int kq = tinhBinhPhuong(n);\n    hienThiKetQua(kq);\n\n    return 0;\n}\n\n// 2. ĐỊNH NGHĨA CHI TIẾT CÁC HÀM (Definition)\nint tinhBinhPhuong(int x) {\n    return x * x;\n}\n\nvoid hienThiKetQua(int num) {\n    cout << \"Ket qua la: \" << num << endl;\n}','css','Nhờ có các Prototype ở trên đầu, chúng ta có thể đẩy hàm main() lên trên cùng. Đây là cách trình bày mã nguồn tiêu chuẩn trong thực tế, giúp người đọc nắm bắt được luồng chính của chương trình ngay lập tức mà không bị lạc giữa hàng chục hàm phụ khác.','2026-01-29 14:22:59'),(456,83,'theory',1,'Phân biệt Declaration vs Definition','Trong thế giới C++, hai khái niệm này thường bị nhầm lẫn:\n- Khai báo (Declaration): Chỉ cung cấp thông tin về tên hàm, kiểu trả về và tham số (đây chính là Prototype). Nó không chiếm bộ nhớ cho code. Bạn có thể khai báo một hàm nhiều lần.\n- Định nghĩa (Definition): Chứa toàn bộ logic xử lý trong thân hàm { }. Đây là nơi code thực sự được tạo ra và chỉ được phép định nghĩa duy nhất một lần.\n\nNếu bạn khai báo Prototype là int nhưng định nghĩa hàm lại là void, trình biên dịch sẽ báo lỗi \"xung đột kiểu dữ liệu\". Cả hai phải khớp nhau tuyệt đối.',NULL,NULL,'2026-01-29 14:23:32'),(457,83,'theory',1,'Ứng dụng trong dự án lớn','Hàm nguyên mẫu chính là nền tảng để bạn tách code ra nhiều file khác nhau sau này.\n- Các Prototype thường được đưa vào các file .h (Header file).\n- Các Definition thực sự được đưa vào các file .cpp.\n\nKhi một lập trình viên khác muốn dùng code của bạn, họ chỉ cần đọc file Header để biết cách \"gọi\" hàm (nhờ Prototype) mà không cần phải quan tâm bên trong bạn đã xử lý phức tạp như thế nào.',NULL,NULL,'2026-01-29 14:24:17'),(458,83,'theory',1,'Tổng kết bài học','- Vị trí: Luôn đặt Prototype ở phía trên hàm main() hoặc trong file header.\n- Kết thúc: Đừng bao giờ quên dấu chấm phẩy ; ở cuối Prototype.\n- Đồng bộ: Đảm bảo kiểu trả về và tham số ở Prototype và Definition phải giống hệt nhau.\n- Lợi ích: Giúp code sạch sẽ, hỗ trợ thiết kế chương trình từ trên xuống (Top-down design).\n- Thói quen: Hãy tập thói quen dùng Prototype ngay cả trong những bài tập nhỏ để chuyên nghiệp hóa cách viết code.',NULL,NULL,'2026-01-29 14:24:43'),(459,84,'theory',1,'Khái niệm Nạp chồng hàm','Hãy tưởng tượng trong đời sống, từ \"Mở\" có thể dùng cho nhiều ngữ cảnh: \"Mở cửa\", \"Mở hộp\", \"Mở máy tính\". Dù hành động thực tế là khác nhau, nhưng mục tiêu chung là làm cho vật đó ở trạng thái sẵn sàng sử dụng.\n\nTrong C++, Nạp chồng hàm cho phép bạn định nghĩa nhiều hàm có cùng tên nhưng khác nhau về Danh sách tham số (số lượng hoặc kiểu dữ liệu). Trình biên dịch sẽ tự động dựa vào các đối số bạn truyền vào khi gọi hàm để quyết định xem phiên bản nào của hàm sẽ được thực thi.',NULL,NULL,'2026-01-29 14:25:41'),(460,84,'theory',1,'Quy tắc để Nạp chồng thành công','Để máy tính không bị \"nhầm lẫn\" giữa các hàm cùng tên, danh sách tham số của chúng phải khác nhau ở ít nhất một trong ba yếu tố sau:\n- Số lượng tham số: Ví dụ sum(int a, int b) và sum(int a, int b, int c).\n- Kiểu dữ liệu của tham số: Ví dụ print(int x) và print(double x).\n- Thứ tự kiểu dữ liệu: Ví dụ move(int x, double y) và move(double x, int y).\n\n**Lưu ý cực kỳ quan trọng**: Việc chỉ thay đổi Kiểu trả về (ví dụ: int sum() và double sum()) mà giữ nguyên tham số không được coi là nạp chồng và sẽ gây lỗi biên dịch. Trình biên dịch cần sự khác biệt ngay từ lúc \"nhận đầu vào\" để phân loại hàm.\n\n**Xử lý nhiều kiểu dữ liệu với cùng một tên hàm**',NULL,NULL,'2026-01-29 14:26:12'),(461,84,'code',1,'','#include <iostream>\nusing namespace std;\n\n// 1. Tính tổng 2 số nguyên\nint add(int a, int b) {\n    cout << \"(Goi ham int, int): \";\n    return a + b;\n}\n\n// 2. Tính tổng 2 số thực\ndouble add(double a, double b) {\n    cout << \"(Goi ham double, double): \";\n    return a + b;\n}\n\n// 3. Tính tổng 3 số nguyên\nint add(int a, int b, int c) {\n    cout << \"(Goi ham 3 tham so): \";\n    return a + b + c;\n}\n\nint main() {\n    cout << add(5, 10) << endl;         // Gọi hàm số 1\n    cout << add(3.5, 2.1) << endl;      // Gọi hàm số 2\n    cout << add(1, 2, 3) << endl;       // Gọi hàm số 3\n\n    return 0;\n}','css','Bạn có thể thấy chúng ta sử dụng duy nhất một cái tên là add. Trình biên dịch rất thông minh: khi thấy bạn truyền vào hai số nguyên, nó gọi phiên bản số 1; khi thấy số thập phân, nó gọi phiên bản số 2. Điều này giúp mã nguồn cực kỳ tự nhiên và dễ đọc.','2026-01-29 14:26:41'),(462,84,'theory',1,'Tại sao nên sử dụng Overloading?','Lợi ích trong thiết kế phần mềm:\n- Tính nhất quán: Bạn không cần phải đặt những cái tên rườm rà như addInt(), addDouble(), addThreeInts(). Chỉ cần một từ add là đủ diễn đạt ý nghĩa.\n- Dễ sử dụng: Người sử dụng thư viện của bạn chỉ cần nhớ một cái tên hàm duy nhất cho các tác vụ tương tự.\n- Tính linh hoạt: Giúp chương trình thích nghi tốt với nhiều loại dữ liệu đầu vào khác nhau mà không cần thay đổi cấu trúc logic chính.',NULL,NULL,'2026-01-29 14:27:17'),(463,84,'theory',1,'Cạm bẫy Mơ hồ (Ambiguity)','Đôi khi, việc kết hợp Nạp chồng hàm với Ép kiểu tự động có thể gây ra lỗi. Ví dụ: Bạn có void print(int n) và void print(double n). Nếu bạn gọi print(3.14f) (kiểu float), trình biên dịch có thể lúng túng vì float có thể ép kiểu sang cả int lẫn double.\n\nĐể tránh lỗi này, hãy luôn cung cấp các đối số có kiểu dữ liệu rõ ràng hoặc thực hiện ép kiểu tường minh khi gọi hàm để hướng dẫn trình biên dịch đi đúng hướng.',NULL,NULL,'2026-01-29 14:27:33'),(464,84,'theory',1,'Tổng kết bài học','- Tên hàm: Phải giống nhau hoàn toàn.\n- Tham số: Phải khác nhau về số lượng, kiểu dữ liệu hoặc thứ tự.\n- Kiểu trả về: Không được dùng để phân biệt các hàm nạp chồng.\n- Mục tiêu: Chỉ nên nạp chồng các hàm có cùng bản chất công việc. Tránh dùng chung tên cho các hành động hoàn toàn khác nhau (ví dụ dùng add cho cả việc tính tổng và việc xóa dữ liệu là sai về tư duy thiết kế).\n- Thói quen: Sử dụng nạp chồng hàm kết hợp với hàm nguyên mẫu để tạo ra những bộ thư viện code mạnh mẽ và dễ dùng.',NULL,NULL,'2026-01-29 14:28:08'),(465,85,'theory',1,'Đệ quy là gì?','Đệ quy là hiện tượng một hàm tự gọi lại chính nó trong quá trình thực thi. Nghe có vẻ kỳ lạ, nhưng đây là cách tư duy \"chia để trị\" đỉnh cao. Thay vì giải quyết một bài toán lớn ngay lập tức, đệ quy yêu cầu máy tính: \"Hãy giải quyết một phiên bản nhỏ hơn của bài toán này, cho đến khi nó nhỏ tới mức không thể nhỏ hơn được nữa\".\n\nĐệ quy xuất hiện rất nhiều trong tự nhiên và toán học, từ cấu trúc của súp lơ xanh, bông tuyết cho đến dãy số Fibonacci nổi tiếng. Trong lập trình, nó giúp code của bạn trở nên cực kỳ ngắn gọn và mang đậm tính học thuật.',NULL,NULL,'2026-01-29 14:29:05'),(466,85,'theory',1,'Hai thành phần bắt buộc của Đệ quy','Để một hàm đệ quy không rơi vào vòng lặp vô tận và làm treo máy (lỗi Stack Overflow), nó bắt buộc phải có hai phần:\n- Điểm dừng (Base Case): Đây là trường hợp đơn giản nhất mà chúng ta đã biết chắc kết quả. Khi chạm tới đây, hàm sẽ ngừng gọi chính nó và bắt đầu trả kết quả ngược lại.\n- Bước đệ quy (Recursive Case): Phần thân hàm chứa lời gọi lại chính nó, nhưng với một tham số nhỏ hơn hoặc đơn giản hơn để tiến dần về điểm dừng.\n\nQuy tắc vàng: Nếu thiếu điểm dừng, hàm sẽ gọi nhau mãi mãi cho đến khi bộ nhớ ngăn xếp (Stack) bị tràn.\n\n**Bài toán kinh điển về đệ quy**',NULL,NULL,'2026-01-29 14:29:23'),(467,85,'code',1,'','#include <iostream>\nusing namespace std;\n\n// Hàm đệ quy tính n!\n// Công thức: n! = n * (n-1)!\nlong long giaiThua(int n) {\n    // 1. Điểm dừng\n    if (n == 0 || n == 1) {\n        return 1;\n    }\n    // 2. Bước đệ quy\n    return n * giaiThua(n - 1);\n}\n\nint main() {\n    int n = 5;\n    cout << \"Giai thua cua \" << n << \" la: \" << giaiThua(n) << endl;\n    return 0;\n}','css','Để tính 5!, hàm sẽ gọi 5 * giaiThua(4). Để có giaiThua(4), nó lại gọi 4 * giaiThua(3)... cứ thế cho đến khi chạm tới giaiThua(1). Lúc này, điểm dừng trả về 1, và các kết quả bắt đầu được nhân ngược trở lại: 1 * 2 * 3 * 4 * 5 = 120.','2026-01-29 14:31:13'),(468,85,'theory',1,'Cơ chế hoạt động của Stack (Ngăn xếp)','Mỗi khi một hàm được gọi, máy tính sẽ dành riêng một vùng nhớ trong Stack để lưu trữ các biến cục bộ và địa chỉ trả về của hàm đó.\n- Với đệ quy, các lời gọi hàm sẽ xếp chồng lên nhau.\n- Khi chưa chạm tới điểm dừng, không có hàm nào kết thúc, khiến Stack ngày càng đầy.\n- Khi chạm tới điểm dừng, các hàm lần lượt hoàn thành nhiệm vụ và được \"giải phóng\" khỏi Stack từ trên xuống dưới. Đây là lý do tại sao đệ quy tiêu tốn nhiều bộ nhớ hơn vòng lặp thông thường.',NULL,NULL,'2026-01-29 14:31:34'),(469,85,'theory',1,'Tổng kết bài học','- Luôn bắt đầu bằng Điểm dừng: Hãy viết câu lệnh if để dừng hàm trước khi viết bất kỳ logic nào khác.\n- Tiến về điểm dừng: Đảm bảo tham số trong lời gọi đệ quy phải thay đổi để dần chạm tới điểm dừng.\n- Thử nghiệm với số nhỏ: Hãy vẽ sơ đồ cây gọi hàm với n=3 hoặc n=4 để hiểu cách dữ liệu luân chuyển.\n- Cẩn trọng: Đệ quy rất đẹp nhưng đừng lạm dụng nó cho những bài toán có thể giải quyết dễ dàng bằng vòng lặp để tối ưu hiệu suất ứng dụng.',NULL,NULL,'2026-01-29 14:32:21'),(470,86,'theory',1,'Địa chỉ bộ nhớ là gì?','Hãy tưởng tượng bộ nhớ RAM của máy tính là một con phố dài với hàng tỷ ngôi nhà. Mỗi ngôi nhà (ô nhớ) chứa một giá trị nào đó và quan trọng nhất: mỗi ngôi nhà đều có một Số nhà (Địa chỉ) duy nhất.\n\nKhi bạn khai báo int x = 10;, máy tính sẽ chọn một ngôi nhà trống, đặt tên nhãn là x, bỏ số 10 vào trong và cấp cho nó một địa chỉ (ví dụ: 0x61ff08). Bình thường bạn chỉ gọi tên x, nhưng với con trỏ, bạn sẽ làm việc trực tiếp với cái số nhà 0x61ff08 đó.',NULL,NULL,'2026-01-29 14:33:43'),(471,86,'theory',1,'Khái niệm Con trỏ','Con trỏ (Pointer) đơn giản cũng là một cái biến, nhưng thay vì chứa những giá trị thông thường như số nguyên hay ký tự, nó chỉ chứa một thứ duy nhất: Địa chỉ vùng nhớ của một biến khác.\n\nTại sao cần con trỏ? \n- Giúp quản lý bộ nhớ linh hoạt (cấp phát động).\n- Truyền dữ liệu lớn vào hàm cực nhanh (không cần photocopy).\n- Thao tác trực tiếp với các thiết bị phần cứng.\n\n**Cú pháp**: kiểu_dữ_liệu *tên_biến_con_trỏ;\nVí dụ: int *ptr; (Khai báo một con trỏ có thể trỏ tới một vùng nhớ chứa số nguyên).',NULL,NULL,'2026-01-29 14:34:15'),(472,86,'theory',1,'Toán tử & và toán tử *','Để làm việc với con trỏ, bạn phải nằm lòng hai ký hiệu sau:\n- Toán tử & (Address-of): Dùng để lấy địa chỉ của một biến. (Ví dụ: &x nghĩa là \"Địa chỉ của nhà x\").\n- Toán tử * (Dereference): Dùng để truy cập vào giá trị nằm tại địa chỉ mà con trỏ đang nắm giữ.\n\nVí dụ: *ptr nghĩa là \"Vật nằm bên trong cái địa chỉ mà ptr đang trỏ tới\".\n\nGhi nhớ: Khi khai báo, dấu * dùng để định nghĩa con trỏ. Khi sử dụng, dùng dấu này để lấy giá trị tại địa chỉ đó.',NULL,NULL,'2026-01-29 14:34:37'),(473,86,'code',1,'','#include <iostream>\nusing namespace std;\n\nint main() {\n    int x = 25;\n    int *ptr = &x; // ptr dang giu dia chi cua x\n\n    cout << \"Gia tri cua x: \" << x << endl;\n    cout << \"Dia chi cua x (&x): \" << &x << endl;\n    cout << \"Gia tri ma ptr dang giu: \" << ptr << endl;\n    \n    // Thay doi gia tri x thong qua con tro\n    *ptr = 100; \n\n    cout << \"Gia tri x sau khi thay doi qua ptr: \" << x << endl;\n    cout << \"Gia tri tai vung nho ptr tro toi (*ptr): \" << *ptr << endl;\n\n    return 0;\n}','css','Trong ví dụ này, ptr được gán địa chỉ của x. Khi chúng ta thay đổi *ptr = 100, máy tính sẽ đi đến địa chỉ mà ptr đang giữ và ghi đè số 100 vào đó. Kết quả là giá trị của x cũng bị thay đổi theo. Đây chính là cách con trỏ \"điều khiển\" biến từ xa.','2026-01-29 14:34:56'),(474,86,'theory',1,'Con trỏ NULL - Quy tắc an toàn','Khi bạn khai báo một con trỏ mà chưa biết nó sẽ trỏ vào đâu, tuyệt đối không được để nó \"lơ lửng\". Một con trỏ không được khởi tạo sẽ chứa một địa chỉ rác ngẫu nhiên. Nếu bạn vô tình ghi dữ liệu vào đó, chương trình sẽ bị sập (Crash) ngay lập tức.\n\nGiải pháp: Luôn khởi tạo con trỏ bằng NULL hoặc nullptr (trong C++11 trở lên).\n- int *ptr = nullptr;\n- Điều này báo hiệu cho máy tính rằng: \"Con trỏ này hiện đang trống, đừng có đụng vào vùng nhớ nào cả\". Luôn kiểm tra if (ptr != nullptr) trước khi sử dụng để đảm bảo an toàn.',NULL,NULL,'2026-01-29 14:35:11'),(475,86,'theory',1,'Tổng kết bài học','- Con trỏ: Là biến chứa địa chỉ vùng nhớ.\n- Kiểu dữ liệu: Kiểu của con trỏ phải khớp với kiểu của biến mà nó trỏ tới (int pointer cho int variable).\n- & (Address-of): Lấy địa chỉ.\n- * (Dereference): Lấy giá trị tại địa chỉ.\n- Kích thước: Mọi con trỏ (dù trỏ tới char hay double) đều có cùng kích thước trên một hệ điều hành (thường là 4 byte trên 32-bit và 8 byte trên 64-bit) vì chúng đều chỉ lưu địa chỉ.\n- An toàn: Luôn khởi tạo nullptr cho các con trỏ chưa dùng tới.',NULL,NULL,'2026-01-29 14:35:44'),(476,87,'theory',1,'Tại sao cần cấp phát động?','Trong máy tính, bộ nhớ dành cho chương trình thường được chia làm hai vùng chính:\n- Vùng Stack (Ngăn xếp): Dành cho cấp phát tĩnh (biến thông thường, mảng cố định). Nó có tốc độ rất nhanh nhưng kích thước nhỏ và cố định. Mọi thứ ở đây sẽ bị xóa sạch khi hàm kết thúc.\n- Vùng Heap (Đống): Đây là một \"nhà kho\" khổng lồ. Dữ liệu ở đây không tự mất đi mà sẽ tồn tại cho đến khi bạn ra lệnh xóa hoặc tắt chương trình.\n\nCấp phát động là việc bạn chủ động thuê một ngăn tủ trong Heap để lưu trữ dữ liệu. Điều này giải quyết bài toán: \"Làm sao để tạo một mảng có N phần tử khi N chỉ được biết sau khi người dùng nhập vào?\".',NULL,NULL,'2026-01-29 14:37:06'),(477,87,'theory',1,'Toán tử new - Thuê bộ nhớ','Trong C++, chúng ta sử dụng toán tử new để cấp phát bộ nhớ động. Khi bạn gọi new, hệ thống sẽ đi tìm một vùng trống đủ lớn trong Heap, giữ chỗ cho bạn và trả về địa chỉ của vùng đó.\n- Cấp phát cho biến đơn: int *ptr = new int;\n- Cấp phát cho mảng: int *arr = new int[n];\n\nLúc này, con trỏ ptr hoặc arr đóng vai trò là \"chìa khóa\" duy nhất để bạn truy cập vào vùng đất mới thuê này.',NULL,NULL,'2026-01-29 14:37:21'),(478,87,'theory',1,'Toán tử delete - Trả lại bộ nhớ','\"Có vay có trả\" là quy tắc vàng của cấp phát động. Vì vùng nhớ Heap không tự động giải phóng, nếu bạn cứ dùng new mà không trả lại, bộ nhớ RAM sẽ bị đầy dần (hiện tượng Memory Leak).\n- Xóa biến đơn: delete ptr;\n- Xóa mảng động: delete[] arr; (Lưu ý phải có cặp ngoặc vuông []).\n\nSau khi delete, con trỏ vẫn còn đó nhưng địa chỉ nó giữ không còn hợp lệ nữa. Tốt nhất hãy gán ptr = nullptr; ngay sau khi xóa để đảm bảo an toàn.',NULL,NULL,'2026-01-29 14:37:39'),(479,87,'code',1,'Quản lý mảng động trong thực tế','#include <iostream>\nusing namespace std;\n\nint main() {\n    int n;\n    cout << \"Ban muon tao mang co bao nhieu phan tu? \";\n    cin >> n;\n\n    // 1. Cap phat dong\n    int *arr = new int[n];\n\n    // 2. Su dung nhu mang binh thuong\n    for (int i = 0; i < n; i++) {\n        arr[i] = i * 10;\n    }\n\n    cout << \"Gia tri mang dong: \";\n    for (int i = 0; i < n; i++) {\n        cout << arr[i] << \" \";\n    }\n\n    // 3. Giai phong bo nho (Cuc ky quan trong)\n    delete[] arr;\n    arr = nullptr;\n\n    return 0;\n}','css','Trong ví dụ này, kích thước của mảng arr hoàn toàn phụ thuộc vào biến n mà người dùng nhập vào. Nhờ con trỏ và toán tử new, chúng ta đã tạo ra một cấu trúc dữ liệu linh hoạt hơn nhiều so với mảng tĩnh. Cuối chương trình, delete[] đảm bảo tài nguyên RAM được trả lại cho hệ thống.','2026-01-29 14:37:59'),(480,87,'theory',1,'Cạm bẫy của bộ nhớ Heap','- Memory Leak (Rò rỉ bộ nhớ): Quên dùng delete. Chương trình chạy càng lâu sẽ càng chiếm nhiều RAM và cuối cùng là bị treo.\n- Dangling Pointer (Con trỏ lơ lửng): Truy cập vào con trỏ sau khi đã delete.\n- Double Delete: Xóa một vùng nhớ hai lần. Điều này sẽ làm chương trình bị sập ngay lập tức.\n- Lỗi cấp phát thất bại: Nếu RAM đã hết sạch, new sẽ không thể cấp phát và ném ra một ngoại lệ. Tuy nhiên, trên máy tính hiện đại, lỗi này rất hiếm gặp trừ khi bạn xin hàng tỷ GB RAM.',NULL,NULL,'2026-01-29 14:38:23'),(481,87,'theory',1,'Tổng kết bài học','- Mục đích: Dùng cấp phát động khi không biết trước kích thước dữ liệu.\n- Toán tử: new để mượn, delete để trả.\n- Cú pháp mảng: Luôn dùng delete[] (có ngoặc vuông) cho mảng động.\n- An toàn: Gán nullptr sau khi xóa để tránh lỗi dùng lại vùng nhớ cũ.\n- Tư duy: Mỗi khi gõ chữ new, hãy tự hỏi mình sẽ gõ chữ delete ở đâu.',NULL,NULL,'2026-01-29 14:38:45'),(482,88,'theory',1,'Tại sao mảng tĩnh là chưa đủ?','Khi bạn khai báo int a[100];, máy tính sẽ dành riêng 100 ô nhớ trên Stack ngay khi chương trình bắt đầu. Điều này dẫn đến hai vấn đề:\n- Lãng phí: Nếu bạn chỉ dùng 10 ô, 90 ô còn lại vẫn bị chiếm dụng vô ích.\n- Thiếu hụt: Nếu bạn cần 101 ô, chương trình sẽ bị lỗi hoặc sập.\n\nTrong thực tế, chúng ta thường không biết trước người dùng sẽ nhập bao nhiêu dữ liệu (ví dụ: số lượng sản phẩm trong giỏ hàng, số lượng quân lính trong game). Mảng động ra đời để giải quyết vấn đề này bằng cách xin cấp phát chính xác số lượng bộ nhớ cần thiết tại thời điểm chương trình đang chạy (Runtime) trên vùng nhớ Heap',NULL,NULL,'2026-01-29 14:40:00'),(483,88,'theory',1,'Cú pháp cấp phát mảng với new[]','Để tạo một mảng động, chúng ta kết hợp con trỏ với toán tử new và cặp ngoặc vuông [].\n- Cú pháp: kiểu_dữ_liệu *tên_con_trỏ = new kiểu_dữ_liệu[số_phần_tử];\n- Cơ chế: Máy tính sẽ tìm một dải ô nhớ liên tiếp đủ lớn trên Heap, sau đó trả về địa chỉ của ô nhớ đầu tiên cho con trỏ.\n- Truy cập: Điểm tuyệt vời là bạn có thể sử dụng con trỏ này hoàn toàn giống như một mảng thông thường với chỉ số [i]. Ví dụ: arr[0], arr[1]...',NULL,NULL,'2026-01-29 14:40:20'),(484,88,'theory',1,'Giải phóng mảng động với delete[]','Đây là nơi rất nhiều lập trình viên mới mắc lỗi. Khi giải phóng một biến đơn, ta dùng delete ptr;. Nhưng khi giải phóng một mảng, bạn bắt buộc phải sử dụng thêm cặp ngoặc vuông: delete[] ptr;.\n\nTại sao? Nếu thiếu [], trình biên dịch có thể chỉ giải phóng ô nhớ đầu tiên của mảng và bỏ quên tất cả các ô phía sau, dẫn đến rò rỉ bộ nhớ (Memory Leak) nghiêm trọng.\n\nThói quen tốt: Sau khi delete[], hãy gán con trỏ bằng nullptr để đảm bảo bạn không vô tình truy cập vào vùng nhớ đã trả lại cho hệ thống.',NULL,NULL,'2026-01-29 14:40:45'),(485,88,'code',1,'Quy trình Nhập - Xử lý - Thu hồi mảng động','#include <iostream>\nusing namespace std;\n\nint main() {\n    int n;\n    cout << \"Nhap so luong sinh vien: \";\n    cin >> n;\n\n    // 1. Cấp phát mảng động dựa trên số lượng n nhập vào\n    double *grades = new double[n];\n\n    // 2. Nhập dữ liệu\n    for (int i = 0; i < n; i++) {\n        cout << \"Nhap diem sinh vien thu \" << i + 1 << \": \";\n        cin >> grades[i];\n    }\n\n    // 3. Tính điểm trung bình\n    double sum = 0;\n    for (int i = 0; i < n; i++) {\n        sum += grades[i];\n    }\n\n    if (n > 0) {\n        cout << \"Diem trung binh cua lop: \" << sum / n << endl;\n    }\n\n    // 4. Giải phóng bộ nhớ mảng động\n    delete[] grades;\n    grades = nullptr;\n\n    cout << \"Da thu hoi bo nho thanh cong.\";\n    return 0;\n}','css','Chương trình này minh họa sức mạnh của mảng động: kích thước mảng hoàn toàn linh hoạt theo ý người dùng. Lưu ý toán tử delete[] grades; ở cuối chương trình—đây là bước không thể thiếu để giữ cho ứng dụng của bạn chạy mượt mà và không \"ngốn\" RAM một cách vô ích.','2026-01-29 14:41:05'),(486,88,'theory',1,'Mảng động 2 chiều','Bạn cũng có thể tạo ra các bảng dữ liệu (ma trận) động. Kỹ thuật này phức tạp hơn một chút: bạn sẽ cấp phát một mảng chứa các con trỏ, và mỗi con trỏ đó lại trỏ tới một mảng động một chiều khác.\n- Cấp phát: Cần dùng vòng lặp để new từng hàng.\n- Giải phóng: Cũng phải dùng vòng lặp để delete[] từng hàng trước khi delete[] mảng quản lý chính. Đây là kỹ thuật dùng để xây dựng các cấu trúc dữ liệu cực lớn như bản đồ thế giới trong game hoặc các cơ sở dữ liệu phức tạp.',NULL,NULL,'2026-01-29 14:41:24'),(487,88,'theory',1,'Tổng kết bài học','- Linh hoạt: Chỉ dùng mảng động khi kích thước mảng không cố định tại thời điểm viết code.\n- Cú pháp: Luôn nhớ new Type[size] và delete[] pointer.\n- Kiểm tra: Nếu mảng quá lớn, hãy kiểm tra xem cấp phát có thành công hay không trước khi sử dụng.\n- Trách nhiệm: Bạn là người \"mượn\" bộ nhớ Heap, bạn phải là người \"trả\" nó.\n- Bảo mật: Xóa xong phải gán nullptr để tránh lỗi logic về sau.',NULL,NULL,'2026-01-29 14:41:56'),(488,89,'theory',1,'Struct là gì? Tại sao cần Struct?','Hãy tưởng tượng bạn cần quản lý thông tin của một sinh viên bao gồm: Họ tên (string), Mã số sinh viên (int), và Điểm trung bình (float). Nếu dùng các biến đơn lẻ, bạn sẽ có các biến rời rạc. Nếu dùng mảng, bạn không thể nhét cả chữ lẫn số vào cùng một chỗ.\n\nStruct (Structure) sinh ra để giải quyết vấn đề này. Nó cho phép bạn đóng gói nhiều biến (có thể khác kiểu dữ liệu) vào một \"thư mục\" duy nhất mang tên kiểu dữ liệu mới do bạn tự đặt. Nó giúp chương trình của bạn mô phỏng thế giới thực một cách chính xác hơn: Một chiếc xe, một con người, hay một món hàng đều là tập hợp của nhiều thuộc tính khác nhau.',NULL,NULL,'2026-01-29 14:47:00'),(489,89,'theory',1,'Cú pháp khai báo và Định nghĩa','Để khai báo một Struct, chúng ta sử dụng từ khóa struct. Các biến bên trong được gọi là các thành viên (members) của cấu trúc đó.\n\n**Cú pháp:**',NULL,NULL,'2026-01-29 14:47:24'),(490,89,'code',1,'','struct TenCauTruc {\n    kieu_du_lieu thanh_vien_1;\n    kieu_du_lieu thanh_vien_2;\n}; // Bắt buộc phải có dấu chấm phẩy ở đây!','css','Khai báo struct thường được đặt ở phía trên hàm main() hoặc trong file header để mọi hàm khác trong chương trình đều có thể nhận diện và sử dụng kiểu dữ liệu mới này.','2026-01-29 14:47:42'),(491,89,'theory',1,'Truy cập và Thao tác với các thành viên','Sau khi đã tạo ra một biến kiểu Struct, làm thế nào để chúng ta \"chạm\" vào dữ liệu bên trong? C++ cung cấp toán tử dấu chấm (.) để thực hiện việc này.\n\nCú pháp: ten_bien_struct.ten_thanh_vien;\n\nBạn có thể dùng toán tử này để gán giá trị, nhập dữ liệu từ bàn phím (cin), hoặc in dữ liệu ra màn hình (cout) cho từng thành phần nhỏ bên trong struct như đối với một biến thông thường.',NULL,NULL,'2026-01-29 14:47:56'),(492,89,'code',1,'Khai báo và sử dụng Struct thực tế','#include <iostream>\n#include <string>\nusing namespace std;\n\n// 1. Định nghĩa kiểu dữ liệu SinhVien\nstruct SinhVien {\n    string hoTen;\n    int mssv;\n    float diemTB;\n};\n\nint main() {\n    // 2. Tạo một biến kiểu SinhVien\n    SinhVien sv1;\n\n    // 3. Nhập dữ liệu cho sv1\n    cout << \"Nhap ho ten: \";\n    getline(cin, sv1.hoTen);\n    cout << \"Nhap MSSV: \";\n    cin >> sv1.mssv;\n    cout << \"Nhap diem TB: \";\n    cin >> sv1.diemTB;\n\n    // 4. Xuất dữ liệu\n    cout << \"\\n--- Thong tin sinh vien ---\" << endl;\n    cout << \"Ten: \" << sv1.hoTen << endl;\n    cout << \"Ma so: \" << sv1.mssv << endl;\n    cout << \"Diem: \" << sv1.diemTB << endl;\n\n    return 0;\n}','css','Trong ví dụ này, SinhVien không còn là một biến đơn lẻ mà là một đối tượng chứa đựng 3 thông tin khác nhau. Việc truy cập thông qua sv1.hoTen hay sv1.diemTB giúp code cực kỳ tường minh và dễ quản lý.','2026-01-29 14:48:17'),(493,89,'theory',1,'Mảng các cấu trúc (Array of Structs)','Sức mạnh thực sự của Struct hiện ra khi kết hợp với Mảng. Bạn có thể tạo ra một mảng mà mỗi phần tử là một Struct.\n\nVí dụ: SinhVien danhSach[50]; tạo ra một danh sách chứa được 50 sinh viên.\n\nĐiều này cho phép bạn thực hiện các thao tác quản lý chuyên nghiệp như: Tìm sinh viên có điểm cao nhất, sắp xếp danh sách theo tên, hoặc lọc ra các sinh viên bị cảnh cáo học vụ. Lúc này, mỗi phần tử danhSach[i] sẽ sở hữu đầy đủ các thuộc tính hoTen, mssv, và diemTB.',NULL,NULL,'2026-01-29 14:48:31'),(494,89,'theory',1,'Tổng kết bài học','- Mục đích: Dùng để gom nhóm các dữ liệu có liên quan nhưng khác kiểu.\n- Cú pháp: Luôn nhớ dấu ; sau khi kết thúc khối lệnh struct.\n- Truy cập: Sử dụng toán tử . để làm việc với các thành viên.\n- Tổ chức: Struct giúp code sạch sẽ, dễ bảo trì và mang tính hướng đối tượng.\n- Thói quen: Hãy đặt tên Struct bằng chữ cái Hoa đầu tiên (ví dụ: Product, User) để phân biệt với các biến thông thường.',NULL,NULL,'2026-01-29 14:49:07'),(495,90,'theory',1,'Tại sao cần con trỏ tới Struct?','Một biến Struct có thể rất lớn (chứa hàng chục thành viên như string, array, các struct khác). Nếu bạn truyền một Struct vào hàm theo cách thông thường (tham trị), máy tính sẽ phải \"photocopy\" toàn bộ dữ liệu đó, gây tốn RAM và làm chậm chương trình.\n\nSử dụng Con trỏ tới Struct cho phép bạn chỉ cần truyền một địa chỉ duy nhất (thường chỉ 8 byte) để truy cập vào toàn bộ dữ liệu của Struct đó. Ngoài ra, con trỏ là cách duy nhất để bạn có thể cấp phát động một Struct trên vùng nhớ Heap, giúp quản lý dữ liệu linh hoạt hơn nhiều so với việc khai báo cố định trên Stack',NULL,NULL,'2026-01-29 14:49:58'),(496,90,'theory',1,'Toán tử mũi tên (->) - Chìa khóa truy cập','Khi bạn có một con trỏ trỏ tới một Struct, bạn không thể dùng dấu chấm . để truy cập thành viên một cách trực tiếp.\n- Cách thủ công: (*ptr).thanh_vien (Giải tham chiếu con trỏ trước rồi mới dùng dấu chấm). Tuy nhiên cách này khá rườm rà.\n- Cách hiện đại: Toán tử mũi tên (->). Đây là cách viết tắt của (*ptr)..\n\nQuy tắc:\n- Nếu là Biến Struct: Dùng dấu chấm . (Ví dụ: sv1.name).\n- Nếu là Con trỏ Struct: Dùng dấu mũi tên -> (Ví dụ: ptr->name).\n\n**Sử dụng con trỏ để thay đổi dữ liệu Struct**',NULL,NULL,'2026-01-29 14:50:33'),(497,90,'code',1,'','#include <iostream>\n#include <string>\nusing namespace std;\n\nstruct SanPham {\n    string ten;\n    double gia;\n};\n\nint main() {\n    // 1. Khai báo biến và con trỏ\n    SanPham sp1 = {\"Laptop\", 1500.0};\n    SanPham *ptr = &sp1;\n\n    // 2. Truy cập qua con trỏ sử dụng ->\n    cout << \"Ten san pham: \" << ptr->ten << endl;\n    cout << \"Gia ban dau: \" << ptr->gia << endl;\n\n    // 3. Thay đổi giá trị thông qua con trỏ\n    ptr->gia = 1350.0; \n    \n    cout << \"Gia sau khi giam: \" << sp1.gia << endl;\n\n    return 0;\n}','css','Trong ví dụ này, ptr nắm giữ địa chỉ của sp1. Khi chúng ta dùng ptr->gia, máy tính sẽ đi thẳng tới vùng nhớ của sp1 và cập nhật lại giá trị. Kết quả là biến gốc sp1 bị thay đổi mà không cần thao tác trực tiếp trên nó.','2026-01-29 14:51:05'),(498,90,'theory',1,'Cấp phát động cho Struct','Bạn có thể tạo ra một Struct chỉ khi cần thiết bằng toán tử new. Điều này cực kỳ hữu ích khi bạn không biết trước mình sẽ cần quản lý bao nhiêu đối tượng (ví dụ: số lượng quái vật xuất hiện trong một màn chơi game).\n- Khởi tạo: SanPham *p = new SanPham;\n- Giải phóng: Sau khi dùng xong, bạn bắt buộc phải dùng delete p; để tránh rò rỉ bộ nhớ.\n\nSử dụng cấp phát động kết hợp với Struct là nền tảng cốt lõi để xây dựng các cấu trúc dữ liệu động như Danh sách liên kết đơn, nơi mỗi phần tử là một Struct chứa con trỏ trỏ đến phần tử tiếp theo.',NULL,NULL,'2026-01-29 14:51:25'),(499,90,'code',1,'Truyền địa chỉ Struct vào hàm','#include <iostream>\nusing namespace std;\n\nstruct ToaDo {\n    int x, y;\n};\n\n// Hàm sử dụng con trỏ để tiết kiệm bộ nhớ và thay đổi dữ liệu gốc\nvoid diChuyen(ToaDo *p, int dx, int dy) {\n    p->x += dx;\n    p->y += dy;\n}\n\nint main() {\n    ToaDo *pos = new ToaDo{10, 20};\n\n    cout << \"Vi tri cu: (\" << pos->x << \", \" << pos->y << \")\" << endl;\n\n    diChuyen(pos, 5, -3);\n\n    cout << \"Vi tri moi: (\" << pos->x << \", \" << pos->y << \")\" << endl;\n\n    delete pos; // Thu hồi bộ nhớ\n    return 0;\n}','css','Hàm diChuyen nhận vào một con trỏ. Việc này giúp hàm có thể tác động trực tiếp lên tọa độ gốc mà không cần phải trả về (return) một Struct mới. Đây là cách làm phổ biến trong lập trình hệ thống và phát triển game để tối ưu tốc độ xử lý.','2026-01-29 14:51:50'),(500,90,'theory',1,'Tổng kết bài học','- Hiệu suất: Luôn ưu tiên dùng con trỏ (hoặc tham chiếu) khi truyền Struct vào hàm.\n- Toán tử: Nhớ nằm lòng -> dùng cho con trỏ, . dùng cho biến thường.\n- Cấp phát: Mỗi khi dùng new cho một Struct, hãy chắc chắn có delete tương ứng.\n- An toàn: Kiểm tra if (ptr != nullptr) trước khi dùng toán tử -> để tránh làm sập chương trình.',NULL,NULL,'2026-01-29 14:52:12'),(501,91,'theory',1,'Tại sao cần nạp chồng toán tử?','Hãy tưởng tượng bạn có một Struct PhanSo (Phân số) gồm tuSo và mauSo. Để cộng hai phân số, bình thường bạn phải viết một hàm như congPhanSo(p1, p2). Tuy nhiên, mã nguồn sẽ đẹp và dễ đọc hơn rất nhiều nếu bạn có thể viết đơn giản là p1 + p2.\n\nNạp chồng toán tử giúp bạn định nghĩa lại cách thức hoạt động của các toán tử có sẵn khi chúng đối đầu với kiểu dữ liệu do bạn tự định nghĩa. Điều này không làm thay đổi ý nghĩa của toán tử đối với các kiểu dữ liệu cơ bản (như int hay float), mà chỉ mở rộng khả năng của chúng.',NULL,NULL,'2026-01-29 14:53:28'),(502,91,'theory',1,'Cú pháp định nghĩa toán tử','Để nạp chồng một toán tử, bạn viết một hàm đặc biệt với tên hàm bắt đầu bằng từ khóa operator, theo sau là ký hiệu toán tử bạn muốn nạp chồng.\n\nCấu trúc: Kiểu_trả_về operatorKý_hiệu (Danh_sách_tham_số) { // Logic xử lý }\n\nVí dụ, để nạp chồng toán tử cộng cho phân số: PhanSo operator+ (const PhanSo& a, const PhanSo& b)',NULL,NULL,'2026-01-29 14:53:47'),(503,91,'code',1,'Nạp chồng toán tử số học (+)','#include <iostream>\nusing namespace std;\n\nstruct Point {\n    int x, y;\n\n    // Nạp chồng toán tử + để cộng hai tọa độ\n    Point operator+(const Point& other) {\n        Point result;\n        result.x = this->x + other.x;\n        result.y = this->y + other.y;\n        return result;\n    }\n};\n\nint main() {\n    Point p1 = {10, 20};\n    Point p2 = {5, 5};\n\n    // Sử dụng toán tử + một cách tự nhiên\n    Point p3 = p1 + p2; \n\n    cout << \"Toa do p3: (\" << p3.x << \", \" << p3.y << \")\" << endl;\n\n    return 0;\n}','css','Trong ví dụ này, chúng ta định nghĩa toán tử + ngay bên trong Struct. Khi thực hiện p1 + p2, C++ hiểu rằng bạn đang gọi hàm p1.operator+(p2). Biến this đại diện cho p1, và other đại diện cho p2. Kết quả trả về là một Point mới mang giá trị tổng.','2026-01-29 14:54:09'),(504,91,'theory',1,'Nạp chồng toán tử nhập xuất (<< và >>)','Một trong những ứng dụng tuyệt vời nhất là nạp chồng toán tử dịch chuyển bit << để in trực tiếp Struct bằng cout. Thay vì phải viết cout << sv.name << sv.id, bạn chỉ cần cout << sv.\n\nĐể làm được điều này, chúng ta thường sử dụng hàm friend (hàm bạn) vì toán tử << thuộc về đối tượng ostream (luồng xuất), không phải thành viên của Struct chúng ta. Việc nạp chồng này giúp việc hiển thị thông tin để gỡ lỗi (debug) trở nên cực kỳ nhanh chóng.',NULL,NULL,'2026-01-29 14:54:26'),(505,91,'code',1,'','#include <iostream>\nusing namespace std;\n\nstruct Box {\n    int length, width;\n\n    // Nạp chồng toán tử << \n    // Trả về ostream& để có thể in liên tiếp: cout << b1 << b2;\n    friend ostream& operator<<(ostream& os, const Box& b) {\n        os << \"Hinh Hop [Dai: \" << b.length << \", Rong: \" << b.width << \"]\";\n        return os;\n    }\n};\n\nint main() {\n    Box b1 = {10, 5};\n    Box b2 = {20, 15};\n\n    // In trực tiếp đối tượng\n    cout << b1 << endl << b2 << endl;\n\n    return 0;\n}','css','Bằng cách nạp chồng operator<<, chúng ta đã dạy cho cout cách hiển thị một đối tượng Box. Từ nay về sau, bất cứ khi nào bạn đẩy một biến kiểu Box vào cout, nó sẽ tự động in ra theo định dạng đẹp mắt mà bạn đã thiết kế.','2026-01-29 14:54:45'),(506,91,'theory',1,'Những quy tắc và Giới hạn','- Không tạo toán tử mới: Bạn chỉ có thể nạp chồng các toán tử hiện có trong C++ (không thể tự chế ra toán tử ** chẳng hạn).\n- Không đổi ưu tiên: Thứ tự ưu tiên (nhân chia trước, cộng trừ sau) vẫn được giữ nguyên.\n- Ít nhất một tham số: Phải có ít nhất một đối tượng trong phép toán là kiểu dữ liệu do bạn tự tạo (Struct/Class).\n- Toán tử không thể nạp chồng: Có 4 toán tử \"bất khả xâm phạm\": toán tử phạm vi ::, toán tử chấm ., toán tử kích thước sizeof, và toán tử 3 ngôi ?:.\n- Tính hợp lý: Chỉ nên nạp chồng nếu nó làm cho code dễ hiểu hơn. Đừng nạp chồng toán tử + để thực hiện phép trừ, điều đó sẽ gây thảm họa cho người đọc code của bạn.',NULL,NULL,'2026-01-29 14:55:15'),(507,92,'theory',1,'Khái niệm luồng dữ liệu (File Streams)','Để làm việc với file trong C++, chúng ta sử dụng thư viện <fstream>. Hãy tưởng tượng file là một cái hồ chứa, và các luồng (streams) là những đường ống dẫn nước:\n- ofstream (Output File Stream): Đường ống dẫn dữ liệu từ chương trình ra file (để ghi file).\n- ifstream (Input File Stream): Đường ống dẫn dữ liệu từ file vào chương trình (để đọc file).\n- fstream: Đường ống đa năng, có thể vừa đọc vừa ghi.',NULL,NULL,'2026-01-29 14:56:30'),(508,92,'theory',1,'Quy trình 3 bước xử lý File','ất kể bạn làm gì với file, bạn luôn phải tuân thủ quy trình \"vàng\" sau để tránh làm hỏng dữ liệu hoặc lãng phí tài nguyên:\n- Mở File (Open): Kết nối biến luồng với một file cụ thể trên ổ cứng.\n- Kiểm tra & Xử lý (Process): Luôn kiểm tra xem file có mở thành công không, sau đó tiến hành đọc hoặc ghi dữ liệu.\n- Đóng File (Close): Ngắt kết nối để giải phóng tài nguyên cho hệ điều hành. Nếu bạn quên đóng file, dữ liệu có thể không được lưu hoàn toàn hoặc file bị khóa không cho ứng dụng khác dùng.',NULL,NULL,'2026-01-29 14:56:52'),(509,92,'code',1,'Ghi dữ liệu vào File','#include <iostream>\n#include <fstream> // Thu vien bat buoc\n#include <string>\n\nusing namespace std;\n\nint main() {\n    // 1. Khai bao luong va mo file\n    ofstream outFile(\"codepulse.txt\");\n\n    // 2. Kiem tra file co mo thanh cong khong\n    if (outFile.is_open()) {\n        outFile << \"Chao mung ban den voi CodePulse!\" << endl;\n        outFile << \"Day la du lieu duoc luu tren o cung.\" << endl;\n        outFile << 2026 << endl;\n\n        // 3. Dong file\n        outFile.close();\n        cout << \"Ghi file thanh cong!\" << endl;\n    } else {\n        cout << \"Khong the mo file de ghi!\" << endl;\n    }\n\n    return 0;\n}','css','Việc ghi vào ofstream giống hệt như in ra màn hình với cout. Thay vì dùng cout <<, bạn dùng outFile <<. File codepulse.txt sẽ tự động được tạo trong cùng thư mục với file code của bạn.','2026-01-29 14:57:07'),(510,92,'code',1,'Đọc dữ liệu từ File','#include <iostream>\n#include <fstream>\n#include <string>\n\nusing namespace std;\n\nint main() {\n    ifstream inFile(\"codepulse.txt\");\n    string line;\n\n    if (inFile.is_open()) {\n        // Doc tung dong cho den khi het file\n        while (getline(inFile, line)) {\n            cout << line << endl;\n        }\n        inFile.close();\n    } else {\n        cout << \"Khong tim thay file!\" << endl;\n    }\n\n    return 0;\n}','css','Chúng ta sử dụng hàm getline() kết hợp với vòng lặp while để đọc toàn bộ nội dung file. Vòng lặp sẽ dừng lại khi con trỏ file đi đến cuối tệp (EOF - End Of File).','2026-01-29 14:57:47'),(511,92,'theory',1,'Các chế độ mở File (File Modes)','Mặc định, ofstream sẽ xóa sạch nội dung cũ của file để ghi mới. Nếu bạn muốn giữ lại nội dung cũ và ghi thêm vào cuối, bạn cần dùng chế độ ios::app (Append):\n- ofstream outFile(\"data.txt\", ios::app);\n\nCác chế độ phổ biến:\n- ios::out: Mở để ghi (mặc định cho ofstream).\n- ios::in: Mở để đọc (mặc định cho ifstream).\n- ios::ate: Mở file và nhảy xuống cuối file.\n- ios::binary: Mở file ở dạng nhị phân (dành cho ảnh, video, audio).',NULL,NULL,'2026-01-29 14:58:21'),(512,92,'theory',1,'Tổng kết bài học','- Thư viện: Luôn dùng #include <fstream>.\n- An toàn: Luôn dùng .is_open() để kiểm tra trước khi thao tác.\n- Đóng file: Luôn gọi .close() để bảo vệ dữ liệu.\n- Đường dẫn: Nếu file nằm ở thư mục khác, hãy chú ý dùng dấu xuyệt kép trong đường dẫn (ví dụ: \"C:\\\\data\\\\test.txt\").\n- Cẩn trọng: Ghi file sẽ xóa nội dung cũ trừ khi dùng chế độ ios::app.',NULL,NULL,'2026-01-29 14:59:20'),(513,93,'theory',1,'So sánh Text File và Binary File','Text File: Chuyển đổi mọi thứ thành chuỗi ký tự. Ví dụ: Số 123456 sẽ được lưu thành 6 ký tự \'1\', \'2\', \'3\', \'4\', \'5\', \'6\' (tốn 6 bytes).\n\nBinary File: Lưu trực tiếp giá trị số đó từ bộ nhớ. Số int 123456 sẽ chỉ tốn đúng 4 bytes (kích thước của int).\n\nƯu điểm của File nhị phân:\n- Tốc độ: Máy tính không tốn công chuyển đổi dữ liệu thành văn bản khi ghi và ngược lại khi đọc.\n- Dung lượng: Thường nhỏ hơn nhiều so với file văn bản, đặc biệt khi lưu trữ số lượng lớn số thực và cấu trúc dữ liệu.\n- Bảo mật: Con người không thể mở bằng Notepad để đọc hay sửa đổi dữ liệu một cách trực tiếp.',NULL,NULL,'2026-01-29 15:00:15'),(514,93,'theory',1,'Mở file ở chế độ Nhị phân','Để làm việc với file nhị phân, khi mở file bạn phải thêm cờ hiệu ios::binary vào tham số thứ hai của hàm open() hoặc hàm khởi tạo luồng.\n- Ghi file: ofstream outFile(\"data.bin\", ios::binary);\n- Đọc file: ifstream inFile(\"data.bin\", ios::binary);\n\nNếu bạn quên cờ hiệu này, hệ điều hành có thể thực hiện một số chuyển đổi ký tự đặc biệt (như dấu xuống dòng), làm hỏng dữ liệu nhị phân của bạn.',NULL,NULL,'2026-01-29 15:00:34'),(515,93,'theory',1,'Hàm write() và read()','Khác với Text File dùng toán tử << và >>, Binary File sử dụng hai hàm thành viên chuyên dụng:\n- Ghi: file.write((char*)&variable, sizeof(variable));\n- Đọc: file.read((char*)&variable, sizeof(variable));\n\nGiải thích cú pháp:\n- (char*)&variable: Ép kiểu địa chỉ của biến về con trỏ kiểu char*. Vì hàm write/read coi mọi dữ liệu là một chuỗi các byte (mỗi byte tương ứng với 1 ký tự).\n- sizeof(variable): Cho máy tính biết cần phải ghi/đọc bao nhiêu byte từ địa chỉ đó.\n\n**Ghi và đọc một đối tượng phức tạp**',NULL,NULL,'2026-01-29 15:01:02'),(516,93,'code',1,'','#include <iostream>\n#include <fstream>\nusing namespace std;\n\nstruct Player {\n    int id;\n    char name[30]; // Dùng mảng char cố định cho file nhị phân\n    float score;\n};\n\nint main() {\n    Player p1 = {101, \"CodePulse_User\", 95.5f};\n\n    // 1. Ghi đối tượng vào file nhị phân\n    ofstream outFile(\"player.dat\", ios::binary);\n    if (outFile) {\n        outFile.write((char*)&p1, sizeof(p1));\n        outFile.close();\n        cout << \"Da luu thong tin nguoi choi!\" << endl;\n    }\n\n    // 2. Đọc đối tượng từ file nhị phân\n    Player pRead;\n    ifstream inFile(\"player.dat\", ios::binary);\n    if (inFile) {\n        inFile.read((char*)&pRead, sizeof(pRead));\n        inFile.close();\n        \n        cout << \"--- Thong tin doc duoc ---\" << endl;\n        cout << \"ID: \" << pRead.id << endl;\n        cout << \"Ten: \" << pRead.name << endl;\n        cout << \"Diem: \" << pRead.score << endl;\n    }\n\n    return 0;\n}','css','- Điểm mạnh nhất của file nhị phân là bạn có thể \"nhấc\" nguyên một khối dữ liệu Player từ RAM và đặt xuống file chỉ bằng một dòng lệnh write, sau đó \"bốc\" ngược lại bằng read.\n- Lưu ý: Trong Struct dùng cho file nhị phân, hãy ưu tiên dùng mảng ký tự cố định (char[]) thay vì std::string để đảm bảo kích thước vùng nhớ luôn cố định và dễ quản lý.','2026-01-29 15:01:37'),(517,93,'theory',1,'Những lưu ý về tính tương thích (Portability)','Mặc dù file nhị phân rất mạnh mẽ, nhưng nó có một nhược điểm: Tính phụ thuộc vào phần cứng.\n- Endianness: Một số dòng chip lưu số từ trái sang phải, số khác lại ngược lại.\n- Padding: Các trình biên dịch khác nhau có thể tự chèn thêm các byte \"đệm\" vào trong Struct để tối ưu tốc độ.\n\nNếu bạn ghi file nhị phân trên Windows và mang sang Mac hoặc Linux để đọc, đôi khi dữ liệu sẽ bị sai lệch. Đối với các ứng dụng nhỏ hoặc học tập, đây không phải là vấn đề lớn, nhưng trong các hệ thống lớn, lập trình viên thường phải dùng thêm các định dạng chuẩn như JSON, XML hoặc Protobuf.',NULL,NULL,'2026-01-29 15:01:59'),(518,93,'theory',1,'Tổng kết bài học','- Luôn dùng ios::binary khi mở file.\n- Sử dụng sizeof() để xác định chính xác kích thước vùng nhớ cần thao tác.\n- Nhớ ép kiểu con trỏ về (char*) hoặc reinterpret_cast<char*>.\n- Kiểm tra kỹ việc đóng file .close() để tránh mất dữ liệu.\n- Hạn chế dùng các kiểu dữ liệu có kích thước thay đổi (như std::string) bên trong Struct nếu muốn ghi/đọc nhị phân nguyên khối.',NULL,NULL,'2026-01-29 15:02:23'),(519,94,'theory',1,'Class và Object là gì?','Hãy tưởng tượng bạn là một kiến trúc sư. Bạn vẽ một bản thiết kế ngôi nhà trên giấy. Bản thiết kế đó cho biết ngôi nhà có bao nhiêu cửa sổ, màu sơn gì, và diện tích bao nhiêu.\n- Lớp (Class): Chính là bản thiết kế đó. Nó không phải là một ngôi nhà thật, nó chỉ là \"khuôn mẫu\" quy định các đặc tính.\n- Đối tượng (Object): Là những ngôi nhà thực sự được xây lên từ bản thiết kế đó. Từ một bản thiết kế, bạn có thể xây hàng ngàn ngôi nhà giống nhau hoặc khác màu sắc một chút.\n\nTrong lập trình, Class là kiểu dữ liệu do bạn định nghĩa, còn Object là biến cụ thể của kiểu dữ liệu đó.',NULL,NULL,'2026-01-29 15:04:35'),(520,94,'theory',1,'Thành phần cốt lõi của một Lớp','Một lớp được cấu tạo từ hai thành phần chính giúp mô phỏng mọi vật thể trong thế giới thực:\n- Thuộc tính (Attributes): Là các biến bên trong lớp, đại diện cho đặc điểm của đối tượng (ví dụ: ten, tuoi, mau_sac).\n- Phương thức (Methods): Là các hàm bên trong lớp, đại diện cho hành động mà đối tượng có thể thực hiện (ví dụ: chay(), keu(), hien_thi_thong_tin()).\n\nThay vì viết các hàm rời rạc và truyền biến vào, giờ đây các hàm và biến \"sống chung\" trong một thực thể thống nhất.',NULL,NULL,'2026-01-29 15:04:57'),(521,94,'code',1,'Khai báo và sử dụng Object cơ bản','#include <iostream>\n#include <string>\nusing namespace std;\n\n// 1. Dinh nghia lop (Class)\nclass SinhVien {\npublic: // Pham vi truy cap: Cho phep ben ngoai su dung\n    string hoTen;\n    double diemTB;\n\n    void hienThi() {\n        cout << hoTen << \" - Diem: \" << diemTB << endl;\n    }\n};\n\nint main() {\n    // 2. Khoi tao doi tuong (Object)\n    SinhVien sv1;\n    sv1.hoTen = \"Nguyen Van A\";\n    sv1.diemTB = 8.5;\n\n    SinhVien sv2;\n    sv2.hoTen = \"Tran Thi B\";\n    sv2.diemTB = 9.0;\n\n    // 3. Su dung phuong thuc\n    sv1.hienThi();\n    sv2.hienThi();\n\n    return 0;\n}','css','Ở đây, SinhVien là cái khuôn. sv1 và sv2 là hai thực thể độc lập. Dù dùng chung phương thức hienThi(), nhưng dữ liệu in ra là khác nhau vì mỗi đối tượng sở hữu vùng nhớ riêng cho các thuộc tính của mình.','2026-01-29 15:05:19'),(522,94,'theory',1,'Phạm vi truy cập (Access Modifiers)','Đây là chìa khóa của tính bảo mật trong OOP:\n- public: Các thành viên có thể được truy cập từ bất cứ đâu trong chương trình.\n- private: Các thành viên chỉ có thể được truy cập bởi các phương thức nằm bên trong chính lớp đó.\n\n**Quy tắc vàng**: Luôn để thuộc tính là private để tránh bị sửa đổi lung tung từ bên ngoài, và cung cấp các phương thức public (như Getters/Setters) để thao tác với dữ liệu đó một cách an toàn.',NULL,NULL,'2026-01-29 15:05:42'),(523,94,'code',1,'Tính Đóng gói (Encapsulation) với Getter và Setter','class TaiKhoan {\nprivate:\n    double soDu; // Khong cho phep truy cap truc tiep tu main()\n\npublic:\n    // Setter: Cho phep nap tien co kiem tra\n    void napTien(double tien) {\n        if (tien > 0) soDu += tien;\n    }\n\n    // Getter: Cho phep xem so du ma khong the sua truc tiep\n    double getSoDu() {\n        return soDu;\n    }\n};','css','Nhờ có private, người dùng không thể viết tk.soDu = -1000;. Họ buộc phải đi qua hàm napTien(), nơi chúng ta có thể đặt các điều kiện kiểm tra dữ liệu hợp lệ. Đây chính là sức mạnh của tính Đóng gói.','2026-01-29 15:06:02'),(524,94,'theory',1,'Tổng kết bài học','- Class: Bản thiết kế (kiểu dữ liệu).\n- Object: Thực thể (biến).\n- Public: Công khai; Private: Nội bộ.\n- Dấu chấm (.): Dùng để truy cập các thành viên của đối tượng.\n- Tư duy: Gom dữ liệu và hành động vào một nơi để dễ quản lý và bảo trì.',NULL,NULL,'2026-01-29 15:06:28'),(525,95,'theory',1,'Tính đóng gói là gì?','Hãy tưởng tượng bạn đang sử dụng một chiếc điều khiển TV. Bạn chỉ cần nhấn nút \"Tăng âm lượng\" hoặc \"Chuyển kênh\". Bạn không cần biết (và cũng không được phép chạm vào) các bảng mạch, chip hay dây điện bên trong.\n\nTính đóng gói trong lập trình có hai ý nghĩa chính:\n- Gom nhóm: Kết hợp dữ liệu (biến) và các thao tác trên dữ liệu đó (hàm) thành một khối duy nhất (Class).\n- Che giấu thông tin: Ngăn chặn việc truy cập trực tiếp vào các thành phần bên trong của đối tượng, chỉ cho phép tương tác thông qua các \"cổng\" được cấp phép.',NULL,NULL,'2026-01-29 15:07:19'),(526,95,'theory',1,'Các phạm vi truy cập (Access Modifiers)','Để thực hiện đóng gói, C++ cung cấp 3 \"tấm khiên\" bảo vệ:\n- public: Mọi người đều có thể thấy và sử dụng. Thường dùng cho các hàm giao tiếp.\n- private: Chỉ \"người trong nhà\" (các hàm bên trong lớp) mới thấy. Thường dùng cho các biến chứa dữ liệu quan trọng.\n- protected: Chỉ bản thân lớp đó và các \"con cháu\" (lớp kế thừa) mới thấy. (Chúng ta sẽ học kỹ hơn ở bài Kế thừa).\n\n**Quy tắc vàng**: Luôn giữ thuộc tính ở trạng thái private cho đến khi bạn có lý do cực kỳ chính đáng để để chúng là public.',NULL,NULL,'2026-01-29 15:07:40'),(527,95,'theory',1,'Getter và Setter - Những người gác cổng','Khi dữ liệu đã bị khóa trong private, làm sao để lấy ra hoặc sửa đổi? Chúng ta sử dụng:\n- Getter: Hàm trả về giá trị của thuộc tính (đọc dữ liệu).\n- Setter: Hàm gán giá trị mới cho thuộc tính (ghi dữ liệu), kèm theo các điều kiện kiểm tra tính hợp lệ.\n\nVí dụ: Bạn không thể để tuoi = -5;. Hàm Setter sẽ kiểm tra: \"Nếu tuổi > 0 thì mới gán, ngược lại thì báo lỗi\". Điều này giúp đối tượng luôn ở trạng thái \"khỏe mạnh\" và dữ liệu không bị sai lệch.',NULL,NULL,'2026-01-29 15:07:57'),(528,95,'code',1,'','#include <iostream>\n#include <string>\nusing namespace std;\n\nclass BankAccount {\nprivate:\n    // Dữ liệu nhạy cảm được giấu kín\n    double balance; \n\npublic:\n    // Hàm khởi tạo (Constructor) để đặt số dư ban đầu\n    BankAccount(double initialBalance) {\n        if (initialBalance >= 0) balance = initialBalance;\n        else balance = 0;\n    }\n\n    // Getter: Cho phép xem số dư nhưng không thể sửa trực tiếp\n    double getBalance() {\n        return balance;\n    }\n\n    // Setter: Cho phép nạp tiền kèm kiểm tra logic\n    void deposit(double amount) {\n        if (amount > 0) {\n            balance += amount;\n            cout << \"Nap thanh cong: \" << amount << endl;\n        } else {\n            cout << \"So tien khong hop le!\" << endl;\n        }\n    }\n};\n\nint main() {\n    BankAccount myAcc(1000.0);\n\n    // myAcc.balance = 999999; // LỖI! Không thể truy cập private\n    \n    myAcc.deposit(500); // Cách duy nhất để tăng tiền\n    cout << \"So du hien tai: \" << myAcc.getBalance() << endl;\n\n    return 0;\n}','css','rong ví dụ này, thuộc tính balance được bảo vệ tuyệt đối. Người dùng chỉ có thể tương tác thông qua deposit() (để nạp tiền có kiểm soát) và getBalance() (để xem). Nếu sau này bạn muốn thay đổi logic tính phí khi nạp tiền, bạn chỉ cần sửa code bên trong hàm deposit, hàm main vẫn chạy bình thường mà không cần sửa đổi gì.','2026-01-29 15:08:16'),(529,95,'theory',1,'Tại sao lập trình viên chuyên nghiệp luôn dùng tính đóng gói?','- Bảo mật dữ liệu: Tránh các thay đổi vô tình hoặc cố ý làm sai lệch dữ liệu gốc.\n- Tính linh hoạt: Bạn có thể thay đổi cách triển khai bên trong lớp (ví dụ đổi kiểu dữ liệu từ int sang double) mà không làm ảnh hưởng đến những nơi khác đang sử dụng lớp đó.\n- Dễ kiểm soát lỗi: Nếu dữ liệu bị sai, bạn biết chắc lỗi nằm ở các hàm Setter bên trong lớp, thay vì phải đi tìm khắp hàng ngàn dòng code trong dự án.',NULL,NULL,'2026-01-29 15:08:46'),(530,95,'theory',1,'Tổng kết bài học','- Luôn khai báo biến là private.\n- Cung cấp public Getter/Setter khi cần thiết.\n- Thực hiện kiểm tra dữ liệu đầu vào (validation) ngay trong các hàm Setter.\n- Chỉ công khai (public) những gì thực sự cần thiết cho người dùng sử dụng.\n- Tư duy: Đừng để người dùng \"chạm tay\" vào máy móc bên trong, hãy đưa cho họ những \"nút bấm\" an toàn.',NULL,NULL,'2026-01-29 15:09:12'),(531,96,'theory',1,'Tính kế thừa là gì?','Hãy tưởng tượng bạn đang thiết kế một trò chơi. Bạn có lớp NhanVat với các thuộc tính như ten, mau, và phương thức diChuyen(). Thay vì phải viết lại toàn bộ những thứ đó cho ChienSi, PhuThuy hay CungThu, bạn chỉ cần cho chúng kế thừa từ lớp NhanVa\n- Lớp Cha (Base Class/Parent Class): Lớp chứa những đặc điểm chung nhất.\n- Lớp Con (Derived Class/Child Class): Lớp kế thừa các đặc điểm từ lớp cha và có thêm những đặc điểm riêng biệt của mình.',NULL,NULL,'2026-01-29 15:10:27'),(532,96,'theory',1,'Cách thiết lập mối quan hệ kế thừa','Để một lớp kế thừa từ lớp khác, chúng ta sử dụng dấu hai chấm (:) theo sau là phạm vi kế thừa (thường là public).',NULL,NULL,'2026-01-29 15:10:42'),(533,96,'code',1,'','class LopCon : public LopCha {\n    // Code riêng của lớp con\n};','css','Khi kế thừa public, tất cả các thành phần public và protected của lớp Cha sẽ trở thành của lớp Con. Lớp Con có thể sử dụng chúng như thể chính nó định nghĩa ra vậy.','2026-01-29 15:11:00'),(534,96,'theory',1,'Phạm vi truy cập protected','Ở bài trước, bạn đã biết private là không ai được đụng vào. Tuy nhiên, nếu bạn muốn lớp Con có thể sử dụng thuộc tính của lớp Cha, nhưng bên ngoài (hàm main) vẫn không được phép chạm vào, bạn sẽ dùng protected.',NULL,NULL,'2026-01-29 15:11:27'),(535,96,'code',1,'Tái sử dụng mã nguồn với lớp Cha và Con','#include <iostream>\n#include <string>\nusing namespace std;\n\n// Lớp Cha\nclass Animal {\nprotected:\n    string name;\npublic:\n    void eat() {\n        cout << name << \" dang an...\" << endl;\n    }\n};\n\n// Lớp Con kế thừa từ Animal\nclass Dog : public Animal {\npublic:\n    Dog(string n) {\n        name = n; // Có thể truy cập vì name là protected\n    }\n    void bark() {\n        cout << name << \" dang sua: Gâu Gâu!\" << endl;\n    }\n};\n\nint main() {\n    Dog myDog(\"Lu\");\n    \n    // Gọi phương thức từ lớp Cha\n    myDog.eat(); \n    \n    // Gọi phương thức của riêng lớp Con\n    myDog.bark();\n\n    return 0;\n}','css','Bạn thấy đấy, trong lớp Dog chúng ta không hề định nghĩa hàm eat(), nhưng myDog vẫn có thể ăn được vì nó đã thừa hưởng khả năng đó từ Animal. Điều này giúp code cực kỳ gọn gàng và logic.','2026-01-29 15:11:54'),(536,96,'theory',1,'Lợi ích của tính kế thừa','- Tái sử dụng mã nguồn (Reusability): Tránh việc copy-paste code.\n- Dễ bảo trì: Nếu muốn sửa logic \"ăn\" của tất cả động vật, bạn chỉ cần sửa ở lớp Animal.\n- Cấu trúc phân tầng: Giúp mô phỏng các mối quan hệ thực tế một cách chính xác (ví dụ: Xe điện là một loại Xe).\n- Tiền đề cho Đa hình: Kế thừa là điều kiện bắt buộc để thực hiện tính Đa hình (Polymorphism) - đỉnh cao của OOP.',NULL,NULL,'2026-01-29 15:12:18'),(537,96,'theory',1,'Tổng kết bài học','- Dùng : để bắt đầu kế thừa.\n- Luôn ưu tiên kế thừa kiểu public.\n- Dùng protected cho các thuộc tính ở lớp Cha để lớp Con có thể truy cập trực tiếp.\n\nLưu ý: Lớp con không kế thừa được Constructor (Hàm khởi tạo) của lớp cha, nhưng nó sẽ tự động gọi Constructor của cha trước khi chạy Constructor của chính nó.',NULL,NULL,'2026-01-29 15:12:42'),(538,97,'theory',1,'Tính đa hình (Polymorphism) là gì?','Từ \"Polymorphism\" có nghĩa là \"nhiều hình thái\". Trong lập trình, nó đại diện cho nguyên tắc: Một giao diện duy nhất, nhiều phương thức thực hiện khác nhau.\n\nHãy tưởng tượng bạn có một chiếc điều khiển vạn năng có nút \"Kích hoạt\".\n- Nếu bạn hướng nó vào cái Quạt, nó sẽ quay.\n- Nếu bạn hướng nó vào chiếc Đèn, nó sẽ sáng.\n- Nếu bạn hướng nó vào cái Loa, nó sẽ phát nhạc.\n\nBạn (người dùng) chỉ cần biết duy nhất một hành động là \"nhấn nút\", còn việc thiết bị nào phản ứng ra sao là chuyện của riêng thiết bị đó. Đó chính là cốt lõi của đa hình: giúp lập trình viên tập trung vào việc \"ra lệnh\" mà không cần lo lắng về chi tiết vụn vặt của từng đối tượng cụ thể.',NULL,NULL,'2026-01-30 03:26:52'),(539,97,'theory',2,'Đa hình lúc biên dịch (Compile-time Polymorphism)','Đây là dạng đa hình được quyết định ngay khi bạn nhấn nút \"Build\" chương trình. Trình biên dịch sẽ nhìn vào danh sách tham số để biết chính xác bạn muốn gọi \"phiên bản\" nào của hàm.\n- Nạp chồng hàm (Function Overloading): Bạn tạo ra nhiều hàm cùng tên nhưng khác nhau về số lượng hoặc kiểu dữ liệu của tham số. Ví dụ: hàm veHinh(int banKinh) sẽ vẽ hình tròn, trong khi veHinh(int dai, int rong) sẽ vẽ hình chữ nhật.\n- Nạp chồng toán tử (Operator Overloading): Bạn định nghĩa lại ý nghĩa của các toán tử như +, -, * cho các đối tượng tự tạo (như cộng hai số phức hay cộng hai ma trận).',NULL,NULL,'2026-01-30 03:28:31'),(540,97,'theory',3,'Đa hình lúc thực thi (Runtime Polymorphism)','Đây là cấp độ cao cấp hơn và thường được nhắc đến nhiều nhất khi nói về OOP. Tại đây, máy tính sẽ không quyết định hàm nào được gọi cho đến khi chương trình thực sự chạy. Để làm được điều này, chúng ta cần sự kết hợp của 3 yếu tố: Kế thừa, Hàm ảo (Virtual Functions) và Ghi đè (Overriding).',NULL,NULL,'2026-01-30 03:28:50'),(541,97,'theory',4,'Hàm ảo (Virtual Functions) - Trái tim của Đa hình','Để thực hiện đa hình lúc thực thi, chúng ta cần:\n- Kế thừa: Lớp con kế thừa từ lớp cha.\n- Hàm ảo: Khai báo hàm ở lớp cha với từ khóa virtual. Điều này báo với C++ rằng: \"Đừng vội gọi hàm này, hãy kiểm tra xem lớp con có bản nâng cấp nào không\".\n- Ghi đè (Override): Lớp con viết lại hàm đó với cùng tên và tham số để thực hiện logic riêng.\n\n**Sử dụng con trỏ lớp Cha trỏ đến lớp Con**',NULL,NULL,'2026-01-30 03:29:24'),(542,97,'code',5,'','#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Animal {\npublic:\n    // Hàm ảo: Cho phép lớp con ghi đè\n    virtual void makeSound() {\n        cout << \"Dong vat dang tao am thanh...\" << endl;\n    }\n};\n\nclass Dog : public Animal {\npublic:\n    void makeSound() override { // Từ khóa override giúp kiểm tra lỗi chính tả\n        cout << \"Gau Gau!\" << endl;\n    }\n};\n\nclass Cat : public Animal {\npublic:\n    void makeSound() override {\n        cout << \"Meo Meo!\" << endl;\n    }\n};\n\nint main() {\n    // Dùng con trỏ lớp cha quản lý các đối tượng lớp con\n    Animal* myPet1 = new Dog();\n    Animal* myPet2 = new Cat();\n\n    myPet1->makeSound(); // In ra: Gau Gau!\n    myPet2->makeSound(); // In ra: Meo Meo!\n\n    delete myPet1;\n    delete myPet2;\n    return 0;\n}','css','Mặc dù myPet1 và myPet2 đều có kiểu là Animal*, nhưng nhờ có tính đa hình và hàm ảo, chương trình biết được myPet1 thực sự là một con Chó để gọi hàm sủa. Điều này giúp bạn có thể quản lý một danh sách gồm nhiều loại động vật khác nhau chỉ với một mảng Animal* duy nhất.','2026-01-30 03:30:14'),(543,97,'theory',6,'Lớp trừu tượng (Abstract Class)','Đôi khi, lớp Cha chỉ tồn tại để làm \"khung\", bạn không muốn ai tạo ra một đối tượng từ nó (ví dụ: không ai biết con \"Động vật\" chung chung kêu như thế nào).\n- Chúng ta dùng hàm ảo thuần túy: virtual void makeSound() = 0;.\n- Lớp chứa ít nhất một hàm ảo thuần túy được gọi là Lớp trừu tượng.\n- Bạn không thể dùng new Animal(), bắt buộc các lớp con phải ghi đè hàm này thì mới có thể sử dụng được.',NULL,NULL,'2026-01-30 03:30:56'),(544,97,'theory',7,'Tổng kết bài học','- Virtual: Luôn dùng virtual ở lớp cha cho các hàm muốn lớp con ghi đè.\n- Override: Dùng từ khóa override ở lớp con để code rõ ràng và tránh lỗi.\n- Destructor ảo: Nếu lớp có hàm ảo, hãy nhớ làm cả hàm hủy ảo (virtual ~ClassName()) để tránh rò rỉ bộ nhớ khi xóa đối tượng.\n- Lợi ích: Giúp viết code \"mở\" (dễ dàng thêm lớp con mới như Duck, Pig mà không cần sửa lại code cũ trong main).',NULL,NULL,'2026-01-30 03:31:20'),(545,98,'theory',1,'Tính trừu tượng là gì?','Trừu tượng hóa là quá trình chọn lọc ra những đặc điểm cốt lõi của một đối tượng và loại bỏ đi những chi tiết triển khai phức tạp không cần thiết đối với người dùng.\n\nVí dụ thực tế: Khi bạn lái ô tô, bạn chỉ cần quan tâm đến vô lăng, chân ga và chân phanh (Giao diện trừu tượng). Bạn không cần biết piston chuyển động ra sao hay hệ thống phun xăng điện tử hoạt động thế nào (Chi tiết triển khai).\n\nTrong lập trình: Tính trừu tượng giúp chúng ta định nghĩa ra các \"bản quy hoạch\" chung cho hệ thống, tách biệt rõ ràng giữa việc Sử dụng và Cài đặt.',NULL,NULL,'2026-01-30 03:34:45'),(546,98,'theory',2,'Hàm ảo thuần túy (Pure Virtual Functions)','Để thực hiện tính trừu tượng, C++ sử dụng hàm ảo thuần túy. Đây là hàm được khai báo ở lớp cha nhưng không có thân hàm.\n\nCú pháp: virtual kiểu_trả_về tên_hàm() = 0;\n\nKý hiệu = 0 báo cho trình biên dịch biết rằng đây là một hàm trống. Nó đóng vai trò như một bản \"hợp đồng\": Mọi lớp con kế thừa từ đây bắt buộc phải tự viết lại (ghi đè) nội dung cho hàm này nếu muốn hoạt động.',NULL,NULL,'2026-01-30 03:35:07'),(547,98,'theory',3,'Lớp trừu tượng (Abstract Class)','Một lớp chứa ít nhất một hàm ảo thuần túy được gọi là Lớp trừu tượng.\n\nĐặc điểm: Bạn không thể khởi tạo một đối tượng trực tiếp từ lớp trừu tượng (ví dụ: không thể dùng new Animal() vì \"Động vật\" nói chung không tồn tại cụ thể).\n\nVai trò: Nó chỉ tồn tại để làm nền tảng cho các lớp con kế thừa. Điều này giúp đảm bảo tính đồng nhất: Mọi lớp con (như Chó, Mèo) đều phải có đầy đủ các hành động mà lớp cha (Động vật) đã quy định.',NULL,NULL,'2026-01-30 03:35:25'),(548,98,'code',4,'Định nghĩa khung làm việc chung','#include <iostream>\n#include <string>\nusing namespace std;\n\n// 1. Lớp trừu tượng: Định nghĩa các tiêu chuẩn chung\nclass SmartDevice {\npublic:\n    virtual void turnOn() = 0;  // Hàm ảo thuần túy\n    virtual void turnOff() = 0; // Hàm ảo thuần túy\n\n    void showInfo() {\n        cout << \"Day la thiet bi thong minh trong nha.\" << endl;\n    }\n};\n\n// 2. Lớp cụ thể: Triển khai chi tiết cho từng thiết bị\nclass SmartLight : public SmartDevice {\npublic:\n    void turnOn() override {\n        cout << \"Den thong minh: Da bat (Do sang 100%).\" << endl;\n    }\n    void turnOff() override {\n        cout << \"Den thong minh: Da tat.\" << endl;\n    }\n};\n\nclass SmartFan : public SmartDevice {\npublic:\n    void turnOn() override {\n        cout << \"Quat thong minh: Dang quay (Muc 3).\" << endl;\n    }\n    void turnOff() override {\n        cout << \"Quat thong minh: Da dung.\" << endl;\n    }\n};\n\nint main() {\n    // SmartDevice device; // LỖI! Không thể tạo đối tượng từ lớp trừu tượng\n    \n    SmartDevice* d1 = new SmartLight();\n    SmartDevice* d2 = new SmartFan();\n\n    d1->turnOn();\n    d2->turnOn();\n\n    delete d1;\n    delete d2;\n    return 0;\n}','css','Lớp SmartDevice đóng vai trò là một giao diện trừu tượng. Người dùng chỉ cần biết mọi thiết bị đều có turnOn và turnOff. Việc chiếc đèn bật như thế nào (tăng độ sáng) hay chiếc quạt bật ra sao (bắt đầu quay) là chi tiết nằm ở các lớp con.','2026-01-30 03:35:53'),(549,98,'theory',5,'Tại sao dự án lớn cần Trừu tượng?','- Đơn giản hóa: Giúp người dùng tập trung vào các tính năng cần thiết mà không bị rối bởi code xử lý bên dưới.\n- Tính linh hoạt: Bạn có thể thay đổi cách triển khai bên trong lớp con mà không làm ảnh hưởng đến các thành phần khác đang sử dụng lớp cha.\n- Tính nhất quán: Ép buộc các lớp con phải tuân theo một tiêu chuẩn chung, giúp việc quản lý hàng ngàn lớp trong dự án trở nên dễ dàng hơn.\n- Giảm sự phụ thuộc: Mã nguồn trở nên rời rạc một cách có kiểm soát (loosely coupled), giúp việc bảo trì và nâng cấp cực kỳ thuận tiện.',NULL,NULL,'2026-01-30 03:36:18'),(550,98,'theory',6,'Tổng kết bài học','- Hàm ảo thuần túy: Sử dụng = 0 để ép lớp con phải thực hiện chức năng.\n- Không khởi tạo: Nhớ rằng không thể tạo đối tượng từ lớp trừu tượng.\n- Phân biệt: Trừu tượng (Ẩn sự phức tạp để dễ dùng) khác với Đóng gói (Giấu dữ liệu để bảo vệ).\n- Hàm hủy ảo: Luôn khai báo virtual ~ClassName() ở lớp cha để giải phóng bộ nhớ an toàn.\n- Ứng dụng: Thường dùng để xây dựng các Interface hoặc Framework tiêu chuẩn.',NULL,NULL,'2026-01-30 03:36:43'),(551,99,'theory',1,'Hàm khởi tạo (Constructor) là gì?','Constructor là một hàm thành viên đặc biệt, tự động được gọi ngay khi một đối tượng của lớp được tạo ra.\n\nMục đích: Thiết lập giá trị ban đầu cho các thuộc tính, cấp phát bộ nhớ hoặc mở các kết nối cần thiết.\n\nĐặc điểm nhận dạng:\n- Tên hàm phải trùng khớp hoàn toàn với tên Lớp.\n- Không có kiểu trả về (ngay cả void cũng không).\n- Phải được đặt trong phạm vi public để có thể khởi tạo từ bên ngoài.',NULL,NULL,'2026-01-30 03:41:25'),(552,99,'theory',2,'Các loại Constructor phổ biến','Giống như các hàm thông thường, Constructor có thể nạp chồng để phù hợp với nhiều tình huống:\n- Constructor mặc định (Default Constructor): Không có tham số. Nếu bạn không viết, C++ sẽ tự tạo một cái \"rỗng\".\n- Constructor có tham số (Parameterized Constructor): Cho phép truyền giá trị vào ngay khi khai báo đối tượng (Ví dụ: Student s(\"An\", 20);).\n- Constructor sao chép (Copy Constructor): Dùng để tạo ra một đối tượng mới là bản sao của đối tượng cũ.',NULL,NULL,'2026-01-30 03:41:47'),(553,99,'theory',3,'Hàm hủy (Destructor) là gì?','Destructor là hàm tự động chạy khi một đối tượng bị tiêu hủy (khi chương trình kết thúc, khi biến ra khỏi phạm vi { }, hoặc khi bạn dùng lệnh delete).\n\nMục đích: Giải phóng các tài nguyên mà đối tượng đã chiếm dụng (như bộ nhớ Heap, đóng File, ngắt kết nối Database).\n\nĐặc điểm:\n- Tên hàm có dấu ngã ~ phía trước tên lớp (Ví dụ: ~Student()).\n- Không có kiểu trả về và không có tham số.\n- Mỗi lớp chỉ có duy nhất một hàm hủy.',NULL,NULL,'2026-01-30 03:42:11'),(554,99,'code',4,'Theo dõi vòng đời của đối tượng','#include <iostream>\n#include <string>\nusing namespace std;\n\nclass DatabaseConnection {\nprivate:\n    string dbName;\npublic:\n    // 1. Parameterized Constructor\n    DatabaseConnection(string name) {\n        dbName = name;\n        cout << \"CONNECT: Da ket noi toi database \" << dbName << endl;\n    }\n\n    // 2. Destructor\n    ~DatabaseConnection() {\n        cout << \"DISCONNECT: Da ngat ket noi va dong \" << dbName << endl;\n    }\n\n    void queryData() {\n        cout << \"Dang lay du lieu tu \" << dbName << \"...\" << endl;\n    }\n};\n\nint main() {\n    cout << \"--- Bat dau ham main ---\" << endl;\n    \n    {\n        // Doi tuong \'conn\' duoc sinh ra o day\n        DatabaseConnection conn(\"CODEPULSE_DB\");\n        conn.queryData();\n        // \'conn\' se bi tieu huy khi gap dau ngoac nhon duoi day\n    } \n\n    cout << \"--- Ket thuc ham main ---\" << endl;\n    return 0;\n}','css','Bạn sẽ thấy dòng \"DISCONNECT\" xuất hiện ngay trước dòng \"Ket thuc ham main\". Đó là vì đối tượng conn chỉ nằm trong phạm vi cặp ngoặc nhọn { }. Khi luồng xử lý thoát ra khỏi đó, hàm hủy tự động được kích hoạt để dọn dẹp tài nguyên.','2026-01-30 03:42:35'),(555,99,'theory',5,'Thứ tự gọi trong Kế thừa','Trong mối quan hệ kế thừa, thứ tự diễn ra như một quy luật tự nhiên:\n- Khi khởi tạo: Lớp Cha phải có trước thì mới có lớp Con. Vậy Constructor Cha chạy trước, rồi mới đến Constructor Con.\n- Khi tiêu hủy: Lớp Con phải được dọn dẹp trước để tránh ảnh hưởng đến các thành phần của Cha. Vậy Destructor Con chạy trước, sau đó mới đến Destructor Cha.\n\nLưu ý quan trọng: Luôn khai báo virtual ~Base() (hàm hủy ảo) ở lớp Cha nếu bạn có sử dụng tính Đa hình, để đảm bảo lớp Con được tiêu hủy hoàn toàn.',NULL,NULL,'2026-01-30 03:42:59'),(556,99,'theory',6,'Tổng kết bài học','- Constructor: Luôn dùng để gán giá trị khởi đầu, tránh để biến chứa \"giá trị rác\".\n- Destructor: Bắt buộc phải dùng nếu trong lớp có cấp phát động (new).\n- Tên gọi: Phải chuẩn xác theo tên lớp (Constructor) và có dấu ~ (Destructor).\n- Tự động: Đừng bao giờ gọi trực tiếp hàm hủy (như s.~Student()), hãy để hệ thống tự vận hành.\n- Tư duy: Mỗi khi bạn gõ new trong Constructor, hãy chắc chắn có một lệnh delete tương ứng trong Destructor.',NULL,NULL,'2026-01-30 03:43:26'),(557,100,'theory',1,'Biến tĩnh (Static Variables) là gì?','Thông thường, mỗi đối tượng có một bản sao riêng của các thuộc tính. Nhưng với một biến tĩnh, chỉ có duy nhất một bản sao tồn tại trong bộ nhớ, bất kể bạn tạo ra bao nhiêu đối tượng đi chăng nữa.\n\nĐặc điểm: Biến tĩnh thuộc về Lớp, không thuộc về bất kỳ Đối tượng cụ thể nào.\n\nVùng nhớ: Biến tĩnh được khởi tạo một lần duy nhất khi chương trình bắt đầu và chỉ bị hủy khi chương trình kết thúc.\n\nỨng dụng: Dùng để lưu trữ các hằng số chung, bộ đếm số lượng đối tượng, hoặc cấu hình dùng chung cho toàn hệ thống.',NULL,NULL,'2026-01-30 03:44:28'),(558,100,'theory',2,'Phương thức tĩnh (Static Methods)','Một phương thức tĩnh là hàm có thể được gọi mà không cần phải tạo ra bất kỳ đối tượng nào của lớp đó.\n\nCách gọi: Bạn gọi trực tiếp qua tên lớp: TenLop::TenHamStatic().\n\nHạn chế quan trọng: Vì không thuộc về đối tượng nào, phương thức tĩnh không thể truy cập các thuộc tính thông thường (non-static) của lớp. Nó chỉ có thể làm việc với các biến tĩnh khác.\n\nLý do: Trong phương thức tĩnh không tồn tại con trỏ this, vì vậy nó không biết \"thuộc tính thông thường\" đó là của đối tượng nào để mà truy cập.',NULL,NULL,'2026-01-30 03:45:17'),(559,100,'theory',3,'Quy tắc khai báo và Khởi tạo','Trong C++, việc sử dụng biến tĩnh có một quy tắc hơi rườm rà nhưng bắt buộc:\n- Khai báo: Bạn đặt từ khóa static trước biến bên trong lớp.\n- Định nghĩa/Khởi tạo: Bạn phải cấp phát bộ nhớ và gán giá trị cho nó ở bên ngoài lớp (thường là ở phía trên hàm main hoặc trong file .cpp).\n\nCú pháp khởi tạo: kieu_du_lieu TenLop::tenBienTinh = gia_tri;',NULL,NULL,'2026-01-30 03:45:38'),(560,100,'code',4,'Bộ đếm đối tượng tự động','#include <iostream>\n#include <string>\nusing namespace std;\n\nclass User {\nprivate:\n    string username;\npublic:\n    // 1. Khai báo biến tĩnh\n    static int userCount; \n\n    User(string name) {\n        username = name;\n        // Mỗi khi một đối tượng ra đời, biến dùng chung tăng lên 1\n        userCount++;\n    }\n\n    ~User() {\n        // Mỗi khi một đối tượng bị xóa, biến dùng chung giảm đi 1\n        userCount--;\n    }\n\n    // 2. Phương thức tĩnh để lấy tổng số user\n    static void showTotalUsers() {\n        cout << \"Tong so nguoi dung hien tai: \" << userCount << endl;\n    }\n};\n\n// 3. Bat buoc: Khoi tao bien tinh o ben ngoai lop\nint User::userCount = 0;\n\nint main() {\n    User u1(\"An\");\n    User u2(\"Binh\");\n    \n    // Goi phuong thuc tinh qua ten Lop\n    User::showTotalUsers(); \n\n    {\n        User u3(\"Chi\");\n        User::showTotalUsers();\n    } // u3 ra khoi pham vi va bi huy\n\n    User::showTotalUsers();\n\n    return 0;\n}','css','Trong ví dụ này, userCount không thuộc về riêng u1 hay u2. Nó là tài sản chung của lớp User. Khi u3 được tạo ra trong khối lệnh con, nó tăng biến chung lên. Khi khối lệnh kết thúc, u3 bị hủy (hàm hủy được gọi), biến chung tự động giảm xuống.','2026-01-30 03:46:05'),(561,100,'theory',5,'Khi nào nên sử dụng Static?','- Hằng số: Các giá trị không đổi cho mọi đối tượng (ví dụ: PI, MAX_SPEED).\n- Hàm tiện ích (Utility): Các hàm tính toán thuần túy không cần dữ liệu từ đối tượng (ví dụ: lớp Math với các hàm sqrt, abs).\n- Quản lý tài nguyên: Theo dõi số lượng kết nối, số lượng file đang mở.\n- Singleton Pattern: Một mẫu thiết kế đảm bảo một lớp chỉ có duy nhất một đối tượng trong suốt vòng đời chương trình.',NULL,NULL,'2026-01-30 03:46:30'),(562,100,'theory',6,'Tổng kết bài học','- Tư duy: Static = Dùng chung cho cả Lớp.\n- Truy cập: Gọi qua TenLop:: (không cần dấu chấm hay mũi tên).\n- Giới hạn: Hàm static không được dùng biến non-static.\n- Khởi tạo: Đừng quên dòng định nghĩa biến tĩnh ở bên ngoài Class.\n- Lợi ích: Tiết kiệm bộ nhớ (vì chỉ có 1 bản sao) và đồng bộ dữ liệu giữa các đối tượng.',NULL,NULL,'2026-01-30 03:46:53'),(563,101,'theory',1,'Ngoại lệ của tính đóng gói','Thông thường, các thành phần private của một lớp là \"bất khả xâm phạm\" đối với các hàm bên ngoài. Nhưng khi bạn khai báo một hàm hoặc một lớp khác là Friend, bạn đang chính thức cấp quyền cho chúng truy cập vào mọi ngóc ngách private và protected của lớp mình.\n\n3 quy tắc \"vàng\" về tình bạn trong OOP:\n- Tình bạn không có tính hai chiều: Nếu lớp A là bạn của lớp B, thì lớp B chưa chắc đã là bạn của lớp A (trừ khi A cũng khai báo B là bạn).\n- Tình bạn không có tính bắc cầu: Nếu A là bạn của B, B là bạn của C, thì A không đương nhiên là bạn của C.\n- Tình bạn không có tính kế thừa: Bạn của cha không mặc định là bạn của con.',NULL,NULL,'2026-01-30 03:48:41'),(564,101,'theory',2,'Hàm bạn (Friend Function)','Một hàm bạn là một hàm nằm ngoài lớp nhưng có quyền hạn như một hàm thành viên.\n\nTại sao dùng?: Thường dùng để thực hiện các thao tác giữa hai lớp khác nhau hoặc khi nạp chồng toán tử (như toán tử << của cout).\n\nCú pháp: Đặt từ khóa friend trước khai báo hàm bên trong lớp.',NULL,NULL,'2026-01-30 03:48:55'),(565,101,'theory',3,'Lớp bạn (Friend Class)','Khi bạn khai báo friend class TenLop;, toàn bộ các hàm thành viên của lớp đó đều trở thành \"bạn\" của lớp hiện tại.\n\nỨng dụng: Thường thấy trong các hệ thống quản lý. Ví dụ: Lớp RemoteControl (Điều khiển) cần là bạn của lớp Television (Tivi) để có thể thay đổi các thông số bí mật bên trong Tivi như cường độ dòng điện hay tần số quét.',NULL,NULL,'2026-01-30 03:49:11'),(566,101,'code',4,'Sử dụng Friend để kết nối dữ liệu','#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Message {\nprivate:\n    string content;\npublic:\n    Message(string c) : content(c) {}\n\n    // 1. Khai báo Hàm bạn\n    friend void revealMessage(Message m);\n\n    // 2. Khai báo Lớp bạn\n    friend class Admin;\n};\n\n// Định nghĩa hàm bạn (Không có từ khóa friend ở đây, không có thuộc về lớp)\nvoid revealMessage(Message m) {\n    cout << \"Noi dung bi mat: \" << m.content << endl;\n}\n\nclass Admin {\npublic:\n    void changeMessage(Message &m, string newContent) {\n        m.content = newContent; // Truy cập trực tiếp vào private content\n        cout << \"Admin da thay doi tin nhan!\" << endl;\n    }\n};\n\nint main() {\n    Message msg(\"Mat ma kho bau: 12345\");\n    Admin boss;\n\n    revealMessage(msg);      // Gọi hàm bạn\n    boss.changeMessage(msg, \"Mat ma da bi doi!\"); // Dung Lop ban\n    revealMessage(msg);\n\n    return 0;\n}','css','Trong ví dụ này, hàm revealMessage và lớp Admin đều có thể chạm vào thuộc tính content (vốn là private). Nếu không có từ khóa friend bên trong lớp Message, trình biên dịch sẽ báo lỗi truy cập ngay lập tức.','2026-01-30 03:49:29'),(567,101,'theory',5,'Khi nào nên (và không nên) dùng Friend?','Nên dùng khi:\n- Cần nạp chồng các toán tử nhập/xuất (<<, >>).\n- Hai hoặc nhiều lớp có mối quan hệ cực kỳ mật thiết và cần hiệu suất cao (không muốn qua các hàm Getter/Setter trung gian).\n\nKhông nên lạm dụng vì:\n- Làm yếu đi tính đóng gói (Encapsulation).\n- Khiến mã nguồn khó bảo trì hơn vì \"bí mật\" của lớp bị lộ ra ngoài quá nhiều nơi.\n- Vi phạm nguyên tắc \"chỉ biết những gì cần biết\".',NULL,NULL,'2026-01-30 03:50:06'),(568,101,'theory',6,'Tổng kết bài học','- Vị trí: Khai báo friend nằm bên trong lớp có dữ liệu bị truy cập.\n- Tư duy: friend là hàm/lớp bên ngoài, không phải thành viên của lớp đó (nên không có con trỏ this).\n- Giới hạn: Chỉ dùng khi thực sự cần thiết để kết nối hai thực thể rời rạc.\n- Tính chất: Nhớ rằng tình bạn là do lớp sở hữu dữ liệu tự nguyện trao đi, không thể bị ép buộc từ bên ngoài.',NULL,NULL,'2026-01-30 03:50:28'),(569,102,'theory',1,'Tư duy Has-a và Is-a (Lắp ghép thay vì Kế thừa)','- Kế thừa (Inheritance - Is-a): Một con Cho là một con DongVat. Nó thừa hưởng mọi thứ từ cha.\n- Quan hệ sở hữu (Has-a): Một chiếc OTo có một cái DongCo. Chiếc ô tô không \"kế thừa\" động cơ, nó chỉ \"sở hữu\" động cơ đó như một bộ phận.\n\nMối quan hệ \"Has-a\" được chia làm hai loại dựa trên mức độ \"gắn bó\" giữa vật sở hữu và vật bị sở hữu: Composition và Aggregation.',NULL,NULL,'2026-01-30 03:52:04'),(570,102,'theory',2,'Composition (Quan hệ cấu thành)','Composition là mối quan hệ sở hữu mạnh mẽ nhất. Trong mối quan hệ này, vật bị sở hữu (thành phần) không thể tồn tại độc lập bên ngoài vật sở hữu (tổng thể).\n\nĐặc điểm: Khi đối tượng \"Tổng thể\" bị tiêu hủy, các đối tượng \"Thành phần\" cũng bị tiêu hủy theo ngay lập tức.\n\nVí dụ: Một NgoiNha có các Phong. Nếu ngôi nhà bị sập, các phòng cũng không còn tồn tại.\n\nTrong C++: Chúng ta thường khai báo đối tượng thành phần trực tiếp như một thuộc tính bình thường (không dùng con trỏ) bên trong lớp.',NULL,NULL,'2026-01-30 03:52:17'),(571,102,'theory',3,'Aggregation (Quan hệ tập hợp)','Aggregation là mối quan hệ sở hữu yếu hơn. Vật bị sở hữu có vòng đời độc lập với vật sở hữu.\n\nĐặc điểm: Khi đối tượng \"Tổng thể\" bị tiêu hủy, các đối tượng \"Thành phần\" vẫn tiếp tục tồn tại và có thể được sử dụng bởi các đối tượng khác.\n\nVí dụ: Một LopHoc có các SinhVien. Nếu lớp học kết thúc (bị hủy), các sinh viên vẫn tồn tại và có thể tham gia lớp học khác.\n\nTrong C++: Chúng ta thường sử dụng Con trỏ hoặc Tham chiếu để trỏ tới các đối tượng thành phần được tạo ra từ bên ngoài.',NULL,NULL,'2026-01-30 03:52:32'),(572,102,'code',4,'Phân biệt Composition và Aggregation trong code','#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\n// Đối tượng độc lập\nclass CPU {\npublic:\n    string model;\n    CPU(string m) : model(m) {}\n};\n\n// Đối tượng độc lập\nclass Mouse {\npublic:\n    string brand;\n    Mouse(string b) : brand(b) {}\n};\n\nclass Computer {\nprivate:\n    // 1. COMPOSITION: CPU \"dính liền\" với máy tính.\n    // Khi Computer mất, CPU này cũng mất.\n    CPU core; \n\n    // 2. AGGREGATION: Chuột được \"cắm\" vào máy tính.\n    // Dùng con trỏ để trỏ tới một đối tượng bên ngoài.\n    Mouse* externalMouse; \n\npublic:\n    Computer(string cpuModel, Mouse* m) : core(cpuModel), externalMouse(m) {}\n\n    void showSpecs() {\n        cout << \"May tinh dung CPU: \" << core.model << endl;\n        if (externalMouse)\n            cout << \"Dang dung chuot: \" << externalMouse->brand << endl;\n    }\n};\n\nint main() {\n    Mouse myLogitech(\"Logitech G502\"); // Chuột tồn tại bên ngoài\n\n    {\n        Computer myPC(\"Intel i9\", &myLogitech);\n        myPC.showSpecs();\n        // Khi ra khỏi ngoặc này, myPC bị hủy.\n        // Đối tượng \'core\' bên trong myPC bị hủy theo (Composition).\n    }\n\n    cout << \"May tinh da huy, nhung chuot \" << myLogitech.brand << \" van con dung duoc!\" << endl; // (Aggregation)\n    \n    return 0;\n}','css','Trong ví dụ này, core là thành phần cấu thành nên máy tính. Còn externalMouse chỉ là một thiết bị ngoại vi được kết nối thông qua địa chỉ (con trỏ). Điều này giúp hệ thống của bạn linh hoạt hơn: bạn có thể thay đổi chuột cho máy tính mà không cần phải phá hủy cả cái máy tính đó.','2026-01-30 03:53:06'),(573,102,'theory',5,'Tổng kết bài học','- Luôn ưu tiên dùng Composition/Aggregation hơn là Kế thừa nếu mối quan hệ không phải là \"Is-a\" rõ ràng.\n- Dùng Composition khi bạn muốn đảm bảo tính toàn vẹn của dữ liệu (thành phần không thể thiếu).\n- Dùng Aggregation khi bạn muốn các module của mình rời rạc, dễ thay thế và tái sử dụng ở nơi khác.\n- Cẩn trọng: Khi dùng Aggregation (Con trỏ), hãy đảm bảo đối tượng bên ngoài chưa bị xóa trước khi bạn truy cập vào nó để tránh lỗi \"Dangling Pointer\".',NULL,NULL,'2026-01-30 03:53:38'),(574,103,'theory',1,'Cạm bẫy của việc ghi đè (Overriding)','Trong C++ truyền thống (trước C++11), khi bạn muốn ghi đè một hàm ảo, bạn chỉ cần viết lại hàm đó ở lớp con. Tuy nhiên, nếu bạn vô tình viết sai dù chỉ một lỗi nhỏ (sai kiểu dữ liệu tham số, thiếu từ khóa const, hoặc sai một chữ cái trong tên hàm), trình biên dịch sẽ coi đó là một hàm hoàn toàn mới thay vì ghi đè hàm cũ.\n\nHậu quả: Tính đa hình bị phá vỡ, nhưng chương trình vẫn chạy (dẫn đến sai kết quả) và không hề báo lỗi.\n\nGiải pháp: Từ khóa override báo cho trình biên dịch biết: \"Hàm này tôi định dùng để ghi đè hàm ở lớp cha, hãy kiểm tra kỹ giúp tôi!\". Nếu không tìm thấy hàm tương ứng ở lớp cha, trình biên dịch sẽ báo lỗi ngay lập tức.',NULL,NULL,'2026-01-30 03:54:47'),(575,103,'theory',2,'Từ khóa final dành cho hàm','Đôi khi, bạn thiết kế một lớp con và ghi đè một phương thức từ lớp cha, nhưng bạn muốn đây là phiên bản cuối cùng—không một lớp \"cháu\" nào được phép ghi đè phương thức này thêm một lần nào nữa.\n\nCú pháp: Đặt final sau khai báo hàm.\n\nTác dụng: Đảm bảo logic của hàm được giữ nguyên ở các cấp kế thừa thấp hơn, giúp bảo vệ các thuật toán quan trọng không bị thay đổi ngoài ý muốn.',NULL,NULL,'2026-01-30 03:54:59'),(576,103,'theory',3,'Từ khóa final dành cho lớp','Có những lớp được thiết kế để sử dụng trực tiếp và bạn không muốn bất kỳ ai tạo thêm lớp con từ nó (ví dụ: các lớp chứa hằng số hoặc các lớp tiện ích hoàn chỉnh).\n\nCú pháp: class TenLop final { ... };\n\nTác dụng: Ngăn chặn hoàn toàn việc kế thừa. Nếu có ai đó cố gắng viết class MyClass : public TenLop, trình biên dịch sẽ ném ra một thông báo lỗi. Điều này giúp tối ưu hóa hiệu suất (vì trình biên dịch biết không cần tra bảng V-Table cho các lớp này).',NULL,NULL,'2026-01-30 03:55:14'),(577,103,'code',4,'Sử dụng override và final chuyên nghiệp','#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Base {\npublic:\n    virtual void show(int x) {\n        cout << \"Gia tri lop Cha: \" << x << endl;\n    }\n    virtual void process() {\n        cout << \"Lop Cha dang xu ly...\" << endl;\n    }\n};\n\nclass Derived : public Base {\npublic:\n    // 1. Dung override de bao ve (Neu xoa \'int\', trinh bien dich se bao loi)\n    void show(int x) override {\n        cout << \"Gia tri lop Con: \" << x << endl;\n    }\n\n    // 2. Dung final de ngan lop chau ghi de ham nay\n    void process() override final {\n        cout << \"Lop Con dang xu ly (Phien ban cuoi cung)!\" << endl;\n    }\n};\n\n// 3. Lop bi khoa ke thua\nclass Ultimate final : public Derived {\n    // void process() override { ... } // LỖI! process da la final o Derived\n};\n\n// class SubUltimate : public Ultimate { ... }; // LỖI! Ultimate da la final\n\nint main() {\n    Derived d;\n    d.show(100);\n    d.process();\n    return 0;\n}','css','Trong ví dụ này, override đảm bảo hàm show khớp hoàn toàn với lớp cha. Hàm process ở lớp Derived đánh dấu final khiến các lớp kế thừa tiếp theo không thể can thiệp vào logic của nó nữa. Lớp Ultimate đánh dấu final để kết thúc chuỗi kế thừa.','2026-01-30 03:55:40'),(578,103,'theory',5,'Lợi ích thực tế','- Phát hiện lỗi sớm: Biến các lỗi logic khó tìm (Runtime errors) thành lỗi biên dịch (Compile errors) dễ xử lý.\n- Tự liệu hóa (Self-documenting): Người đọc code nhìn vào override sẽ biết ngay đây là hàm kế thừa, nhìn vào final sẽ biết không nên cố gắng mở rộng lớp này nữa.\n- Tối ưu hiệu suất: Trình biên dịch có thể thực hiện kỹ thuật \"Inlining\" cho các hàm hoặc lớp final, giúp chương trình chạy nhanh hơn một chút.',NULL,NULL,'2026-01-30 03:56:08'),(579,103,'theory',6,'Tổng kết bài học','- Luôn dùng override: Cho mọi hàm ảo ở lớp con. Đừng lười biếng, nó sẽ cứu bạn khỏi những giờ phút debug vô tận.\n- Dùng final cho hàm: Khi bạn muốn cố định logic của một hành vi ở một cấp kế thừa nhất định.\n- Dùng final cho lớp: Khi lớp đã hoàn chỉnh và không có ý định cho phép ai mở rộng thêm.\n- Thứ tự: override và final luôn nằm ở cuối khai báo hàm (sau const nếu có).',NULL,NULL,'2026-01-30 03:56:32'),(580,67,'code',3,'','#include <iostream>\nusing namespace std;\n\nint main() {\n    // Khai báo hằng số số nguyên\n    const int MAX_USERS = 100;\n    const double GRAVITY = 9.8;\n\n    cout << \"Gioi han nguoi dung: \" << MAX_USERS << endl;\n\n    // MAX_USERS = 200; // LỖI! Trình biên dịch sẽ ngăn chặn hành động này.\n\n    return 0;\n}','css','','2026-01-30 13:00:59'),(581,71,'code',3,'','#include <iostream>\nusing namespace std;\n\nint main() {\n    bool coNguoi = true; // Giả sử cảm biến báo có người\n\n    if (coNguoi) {\n        cout << \"Cua dang mo... Chao mung ban!\" << endl;\n    }\n\n    cout << \"Ket thuc chuong trinh.\" << endl;\n    return 0;\n}','css','Nếu coNguoi là false, dòng chữ \"Cua dang mo...\" sẽ hoàn toàn bị ngó lơ.','2026-01-30 13:05:25'),(582,71,'code',5,'','#include <iostream>\n#include <string>\nusing namespace std;\n\nint main() {\n    string mauDen = \"do\"; \n\n    if (mauDen == \"xanh\") {\n        cout << \"Ban duoc phep di tiep.\" << endl;\n    } \n    else {\n        // Khối lệnh này chạy nếu màu đèn KHÔNG PHẢI là xanh\n        cout << \"Dung lai! Vui long cho den khi den chuyen xanh.\" << endl;\n    }\n\n    return 0;\n}','css','','2026-01-30 13:05:56'),(583,74,'code',5,'','#include <iostream>\n#include <string>\nusing namespace std;\n\nint main() {\n    string matKhauDung = \"1234\";\n    string matKhauNhap;\n\n    cout << \"Vui long nhap mat khau: \";\n    cin >> matKhauNhap;\n\n    // Chừng nào matKhauNhap còn KHÁC matKhauDung, thì còn bắt nhập lại\n    while (matKhauNhap != matKhauDung) {\n        cout << \"Sai mat khau roi! Nhap lai di: \";\n        cin >> matKhauNhap;\n    }\n\n    cout << \"Chuc mung! Ban da dang nhap thanh cong.\" << endl;\n\n    return 0;\n}','css','Chương trình sẽ lặp đi lặp lại việc yêu cầu nhập cho đến khi người dùng nhập đúng mật khẩu là 1234','2026-01-30 13:08:17'),(584,74,'theory',6,'Vòng lặp Do-While - Làm trước, hỏi sau','Trong lập trình, cấu trúc Do-While thuộc nhóm vòng lặp kiểm tra sau (post-test loop). Điều này tạo nên một sự khác biệt cốt yếu về tư duy lập trình:\n\nTính cam kết thực thi: Với while hay for, mã nguồn mang tính chất \"đề phòng\" (chỉ làm nếu đủ điều kiện). Với do-while, mã nguồn mang tính chất \"thực thi\" (làm đi đã, rồi mới tính tiếp).\n\nĐiểm dừng: Điều kiện trong while là điều kiện để bắt đầu, còn điều kiện trong do-while thực tế là điều kiện để lặp lại.\n\n**Cấu trúc chi tiết và cú pháp mở rộng**',NULL,NULL,'2026-01-30 13:10:30'),(585,74,'code',7,'','do {\n    // 1. Khởi tạo hoặc cập nhật dữ liệu bên trong này\n    // 2. Thực hiện hành động chính\n} while (biểu_thức_điều_kiện);','css','','2026-01-30 13:10:46'),(586,74,'theory',8,'','Phạm vi biến (Scope): Nếu bạn khai báo một biến bên trong cặp ngoặc { } của do, bạn không thể sử dụng biến đó trong điều kiện while(...).\n- Sai: do { int x = 5; } while (x < 10); (Biến x sẽ không tồn tại ở dòng while).\n- Đúng: Khai báo biến bên ngoài khối do.',NULL,NULL,'2026-01-30 13:11:14');
/*!40000 ALTER TABLE `lesson_contents` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `lessons`
--

DROP TABLE IF EXISTS `lessons`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `lessons` (
  `lesson_id` int NOT NULL AUTO_INCREMENT,
  `chapter_id` int NOT NULL,
  `lesson_name` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL,
  `lesson_order` int DEFAULT '1',
  `created_at` timestamp NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`lesson_id`),
  KEY `chapter_id` (`chapter_id`),
  CONSTRAINT `lessons_ibfk_1` FOREIGN KEY (`chapter_id`) REFERENCES `chapters` (`chapter_id`) ON DELETE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=104 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `lessons`
--

LOCK TABLES `lessons` WRITE;
/*!40000 ALTER TABLE `lessons` DISABLE KEYS */;
INSERT INTO `lessons` VALUES (2,2,'1. Lời khuyên trước khóa học',1,'2026-01-28 04:57:47'),(3,2,'2. Cài đặt môi trường',1,'2026-01-28 05:07:23'),(4,6,'1. Khái niệm biến và cách sử dụng',1,'2026-01-28 05:40:36'),(5,6,'2. Cú pháp comments là gì?',1,'2026-01-28 05:44:26'),(6,6,'3. Thuật ngữ Built-in là gì?',1,'2026-01-28 05:48:31'),(7,7,'1. Làm quen với toán tử',1,'2026-01-28 05:54:13'),(9,7,'2. Toán tử số học.',1,'2026-01-28 06:03:40'),(10,7,'3. Toán tử gán',1,'2026-01-28 06:10:19'),(11,7,'4. Nguyên lý hoạt động của ++ / --',1,'2026-01-28 06:15:54'),(12,7,'5. Toán tử nối chuỗi',1,'2026-01-28 06:29:25'),(13,7,'6. Toán tử so sánh',1,'2026-01-28 06:38:19'),(14,7,'7. Kiểu dữ liệu Boolean',1,'2026-01-28 06:43:10'),(15,7,'8. Câu lệnh điều kiện If',1,'2026-01-28 06:46:39'),(16,7,'9. Toán tử logical',1,'2026-01-28 06:51:13'),(17,7,'10. Các kiểu dữ liệu trong JavaScript',1,'2026-01-28 09:01:08'),(18,7,'11.  Truthy và Falsy',1,'2026-01-28 09:06:52'),(19,7,'12. Toán tử Logical và câu lệnh điều kiện If',1,'2026-01-28 09:11:30'),(20,8,'1. Khái niệm hàm (function)',1,'2026-01-28 09:15:15'),(21,8,'2. Tham số trong hàm (Parameters & Arguments)',1,'2026-01-28 09:18:59'),(22,8,'3. Từ khóa return trong hàm',1,'2026-01-28 09:21:47'),(23,8,'4. Các loại hàm',1,'2026-01-28 09:26:07'),(25,9,'1. Kiểu dữ liệu chuỗi (String)',1,'2026-01-28 09:30:23'),(26,9,'2. Thao tác làm việc với chuỗi (String Methods)',1,'2026-01-28 09:34:59'),(27,10,'1. Số và làm việc với số',1,'2026-01-28 09:39:54'),(28,11,'1. Mảng (array)',1,'2026-01-28 14:08:42'),(29,11,'2. Làm việc, thao tác với mảng',1,'2026-01-28 14:14:40'),(30,12,'1. Object là gì?',1,'2026-01-28 14:18:36'),(31,12,'2. Object constructor',1,'2026-01-28 14:23:08'),(32,12,'3. Object prototype',1,'2026-01-28 14:31:27'),(33,12,'4. Đối tượng Date và Math Object',1,'2026-01-28 14:36:16'),(34,13,'1.  Lệnh rẽ nhánh If else',1,'2026-01-28 14:39:38'),(35,13,'2. Câu lệnh rẽ nhánh Switch',1,'2026-01-28 14:42:51'),(36,13,'3. Toán tử 3 ngôi (Ternary Operator)',1,'2026-01-28 14:45:27'),(37,14,' 1. Giới thiệu vòng lặp',1,'2026-01-28 14:50:09'),(39,14,'2. Vòng lặp For',1,'2026-01-28 14:55:47'),(40,14,'3. Vòng lặp for...in',1,'2026-01-28 14:59:15'),(41,14,'4. Vòng lặp for...of',1,'2026-01-28 15:02:43'),(42,14,'5. Vòng lặp While',1,'2026-01-29 00:53:37'),(43,14,'6. Vòng lặp do...while',1,'2026-01-29 00:56:24'),(44,14,'7.  Break và Continue trong vòng lặp',1,'2026-01-29 01:23:21'),(45,14,'8. Vòng lặp lồng nhau (Nested loop)',1,'2026-01-29 01:26:26'),(46,14,'9. Đệ quy là gì? Học về đệ quy!',1,'2026-01-29 01:33:04'),(47,11,'3. Làm việc với mảng nâng cao',1,'2026-01-29 01:45:54'),(48,15,'1. Callback là gì?',1,'2026-01-29 01:51:23'),(49,15,'2. Các phương thức làm chủ Callback',1,'2026-01-29 01:56:00'),(50,15,'3. Tạo phương thức mySome và myEvery',1,'2026-01-29 01:59:39'),(51,16,'1. HTML DOM là gì?',1,'2026-01-29 02:02:21'),(52,16,'2.  HTML DOM vs DOM API',1,'2026-01-29 02:05:18'),(54,16,'3. Đối tượng Document (The Document Object)',1,'2026-01-29 02:08:39'),(55,16,'4. Các phương thức truy xuất phần tử (Get Element Methods)',1,'2026-01-29 02:11:50'),(56,16,'5. Xử lý sự kiện và Kiểm soát hành vi (DOM Events)',1,'2026-01-29 06:47:12'),(57,17,'1. JSON & Tư duy Bất đồng bộ (Async)',1,'2026-01-29 06:53:32'),(58,17,'2. Promise',1,'2026-01-29 06:56:15'),(59,17,'3. Fetch',1,'2026-01-29 06:59:07'),(60,18,'1. Arrow Functions & Enhanced Object Literals',1,'2026-01-29 07:05:49'),(61,18,'2. Destructuring, Rest & Spread',1,'2026-01-29 07:08:06'),(62,19,'1. Giới thiệu khóa học',1,'2026-01-29 07:12:02'),(64,19,'2. Cài đặt Dev - C++ và hướng dẫn sử dụng',1,'2026-01-29 07:23:24'),(65,20,'1. Biến và nhập xuất dữ liệu',1,'2026-01-29 07:29:59'),(66,20,'2. Các kiểu dữ liệu thường gặp',1,'2026-01-29 11:51:10'),(67,20,'3. Hằng số',1,'2026-01-29 11:58:16'),(68,20,'4. Toán tử gán và toán tử số học',1,'2026-01-29 13:24:19'),(69,20,'5. Toán tử quan hệ và toán tử logic',1,'2026-01-29 13:29:45'),(70,20,'6. Ép kiểu dữ liệu và bảng mã ASCII',1,'2026-01-29 13:34:52'),(71,21,'1. Cấu trúc if else',1,'2026-01-29 13:39:50'),(72,21,'2. Cấu trúc switch case',1,'2026-01-29 13:42:36'),(73,21,'3.  Toán tử 3 ngôi',1,'2026-01-29 13:45:24'),(74,21,'4. Vòng lặp',1,'2026-01-29 13:48:36'),(75,21,'5. Break, continue, goto',1,'2026-01-29 13:51:30'),(76,22,'1. Mảng một chiều',1,'2026-01-29 13:55:41'),(77,22,'2. Mảng hai chiều - Ma trận và Bảng dữ liệu',1,'2026-01-29 13:59:22'),(78,23,'1. Khái niệm và thao tác cơ bản với String',1,'2026-01-29 14:03:23'),(79,23,'2. Các hàm nâng cao và Xử lý chuỗi phức tạp',1,'2026-01-29 14:06:03'),(80,24,'1. Khái niệm và cú pháp hàm',1,'2026-01-29 14:10:51'),(81,24,'2.  Tham số và đối số',1,'2026-01-29 14:14:23'),(82,24,'3. Đối số mặc định',1,'2026-01-29 14:18:25'),(83,24,'4. Hàm nguyên mẫu',1,'2026-01-29 14:21:22'),(84,24,'5. Nạp chồng hàm (Function Overloading)',1,'2026-01-29 14:25:20'),(85,24,'6. Đệ quy (Recursion)',1,'2026-01-29 14:28:28'),(86,25,'1. Khái niệm và Thao tác cơ bản với Con trỏ',1,'2026-01-29 14:33:27'),(87,25,'2. Cấp phát động',1,'2026-01-29 14:35:59'),(88,25,'3. Cấp phát mảng động',1,'2026-01-29 14:39:09'),(89,26,'1. Khái niệm và Cách sử dụng Struct',1,'2026-01-29 14:46:49'),(90,26,'2. Con trỏ và struct',1,'2026-01-29 14:49:36'),(91,26,'3. Nạp chồng toán tử (Operator Overloading)',1,'2026-01-29 14:53:12'),(92,27,'1. Ghi và Đọc File văn bản (Text Files)',1,'2026-01-29 14:56:07'),(93,27,'2. Đọc và Ghi File Nhị phân (Binary Files)',1,'2026-01-29 14:59:35'),(94,28,'1. Class và object',1,'2026-01-29 15:03:52'),(95,28,'2. Tính đóng gói (Encapsulation)',1,'2026-01-29 15:06:59'),(96,28,'3. Tính kế thừa (Inheritance)',1,'2026-01-29 15:09:52'),(97,28,'4. Tính đa hình (Polymorphism)',1,'2026-01-29 15:12:58'),(98,28,'5. Tính trừu tượng (Abstraction)',1,'2026-01-30 03:32:42'),(99,28,'6. Vòng đời đối tượng: Constructor & Destructor',1,'2026-01-30 03:40:49'),(100,28,'7. Thành viên tĩnh (Static Members)',1,'2026-01-30 03:43:51'),(101,28,'8. Hàm bạn và Lớp bạn (Friend Functions & Classes)',1,'2026-01-30 03:47:23'),(102,28,'9. Mối quan hệ Composition & Aggregation',1,'2026-01-30 03:50:57'),(103,28,'10. Từ khóa final và override (C++11)',1,'2026-01-30 03:53:58');
/*!40000 ALTER TABLE `lessons` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `test_cases`
--

DROP TABLE IF EXISTS `test_cases`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `test_cases` (
  `test_case_id` int NOT NULL AUTO_INCREMENT,
  `exercise_id` int NOT NULL,
  `input` text COLLATE utf8mb4_unicode_ci,
  `expected_output` text COLLATE utf8mb4_unicode_ci NOT NULL,
  `is_hidden` tinyint(1) DEFAULT '1',
  `points` int DEFAULT '1',
  PRIMARY KEY (`test_case_id`),
  KEY `exercise_id` (`exercise_id`),
  CONSTRAINT `test_cases_ibfk_1` FOREIGN KEY (`exercise_id`) REFERENCES `coding_exercises` (`exercise_id`) ON DELETE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=168 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `test_cases`
--

LOCK TABLES `test_cases` WRITE;
/*!40000 ALTER TABLE `test_cases` DISABLE KEYS */;
INSERT INTO `test_cases` VALUES (1,1,'','CodePulse Learning',1,1),(2,5,'Nam','Xin chao Nam!',1,1),(3,5,'CodePulse','Xin chao CodePulse!',1,1),(4,6,'12345 CNTT1','MSSV: 12345, Lop: CNTT1',1,1),(5,6,'67890 KTPM2','MSSV: 67890, Lop: KTPM2',1,1),(6,7,'A','65',1,1),(7,7,'#','35',1,1),(8,8,'5','31.4',1,1),(9,8,'2.5','15.7',1,1),(10,9,'1000','100',1,1),(11,9,'250','25',0,1),(12,10,'36','10',0,1),(13,10,'18','5',0,1),(14,11,'10 5','15 5 50',1,1),(15,11,'7 3','10 4 21',1,1),(16,12,'123','3',1,1),(17,12,'2026','6',1,1),(18,13,'10 5','1',0,1),(19,13,'3 8','0',0,1),(20,13,'7 7','0',0,1),(21,14,'50','1',0,1),(22,14,'5','0',0,1),(23,14,'101','0',0,1),(24,15,'3 4','3.5',0,1),(25,15,'10 2','6',0,1),(26,16,'A','B',0,1),(27,16,'m','n',0,1),(28,16,'1','2',0,1),(29,17,'10 8 9','8.83333',0,1),(30,17,'7 7 7','7',0,1),(31,18,'3661','1 1 1',0,1),(32,18,'7200','2 0 0',0,1),(33,18,'125','0 2 5',1,1),(34,19,'4','CHAN',0,1),(35,19,'7','LE',0,1),(36,20,'10 20','20',0,1),(37,20,'8 8','8',0,1),(38,21,'2','Thu Hai',0,1),(39,21,'8','Chu Nhat',0,1),(40,21,'19','Khong hop le',0,1),(41,22,'10 5 -','5',0,1),(42,22,'4 3 *','12',0,1),(43,23,'10','DUONG',0,1),(44,23,'-5','AM',0,1),(45,24,'15.5 20','15.5',0,1),(46,24,'100 99.9','99.9',0,1),(47,25,'5','1 2 3 4 5',0,1),(48,26,'123','6',0,1),(49,26,'2026','10',0,1),(50,27,'1 20','7',0,1),(51,27,'10 30','14',0,1),(52,28,'7','1 2 4 5 7',0,1),(53,28,'10','1 2 4 5 7 8 10',0,1),(54,29,'7','YES',0,1),(55,29,'10','NO',0,1),(56,31,'5 / 1 2 3 4 5','15',0,1),(57,31,'3 / 10 -5 2','7',0,1),(58,32,'4 / 10 2 35 7','35',0,1),(59,32,'5 / -1 -5 -2 -10 -3','-1',0,1),(60,33,'2 2 / 1 2 3 4','10',0,1),(61,33,'3 2 / 1 1 1 1 1 1','6',0,1),(62,34,'2 3 / 1 5 3 8 2 4','5 8',0,1),(63,34,'3 3 / 9 1 2 4 10 5 3 6 8','9 10 8',0,1),(64,35,'Hello','5',0,1),(65,35,'Programming','11',0,1),(66,36,'abcd','a d',0,1),(67,36,'C++','C +',0,1),(68,37,'Hoc lap trinh C++ / C++','14',0,1),(69,37,'Hello World / Java','-1',0,1),(70,38,'CodePulse_Learning / 0 9','CodePulse',0,1),(71,38,'I love C++ / 7 3','C++',0,1),(72,39,'radar','YES',0,1),(73,39,'hello','NO',0,1),(74,40,'cpp','Cpp',0,1),(75,40,'learning','Learning',0,1),(76,41,'','Hello CodePulse!',0,1),(77,42,'5','25',0,1),(78,42,'-4','16',0,1),(79,43,'2 3','8',0,1),(80,43,'5 2','25',0,1),(81,44,'10 20','20 10',0,1),(82,44,'5 5','5 5',0,1),(83,45,'1 2 3','6 3',0,1),(84,45,'10 20 30','60 30',0,1),(85,46,'500 1.5','750 500',0,1),(86,46,'1000 2.0','2000 1000',0,1),(87,47,'5 4','20',0,1),(88,47,'2.5 4','10',0,1),(89,48,'4','1 0',0,1),(90,48,'-3 ','0 1',0,1),(91,49,'5 10 2.5 3.5','15 6',0,1),(92,49,'1 2 1.1 2.2','3 3.3',0,1),(93,50,'10 20 30','20 30',0,1),(94,50,'50 10 5','50 50',0,1),(95,51,'5','120',0,1),(96,51,'0','1',0,1),(97,52,'6','8',0,1),(98,52,'10','55',0,1),(99,53,'12 18','6',0,1),(100,53,'7 13','1',0,1),(101,54,'6','YES',0,1),(102,54,'10','NO',0,1),(103,55,'10','10',0,1),(104,55,'-20','-20',0,1),(105,56,'5','15',0,1),(106,56,'0','10',0,1),(107,57,'100','100',0,1),(108,57,'-25','-25',0,1),(109,58,'10 20','30',0,1),(110,58,'-5 15','10',0,1),(111,59,'3 / 1 2 3','3 2 1',0,1),(112,59,'4 / 10 20 30 40','40 30 20 10',0,1),(113,60,'2 / 4 6','5',0,1),(114,60,'3 / 1.5 2.5 5','3',0,1),(115,61,'10 20','20 10',0,1),(116,61,'5 5','5 5',0,1),(117,62,'4\n1 5 3 9','9',0,1),(118,62,'3\n-10 -2 -5','-2',0,1),(119,63,'3 4','(3, 4)',0,1),(120,63,'-1 5','(-1, 5)',0,1),(121,64,'Nguyen Van A \n20\n3.5','Ten: Nguyen Van A\nTuoi: 20\nGPA: 3.5',0,1),(122,64,'Le Thi B \n19\n4.0','Ten: Le Thi B\nTuoi: 19\nGPA: 4',0,1),(123,65,'An\n18','Ten: An, Tuoi: 18',0,1),(124,65,'Binh\n20','Ten: Binh, Tuoi: 20',0,1),(125,66,'2 3 4','24',0,1),(126,66,'5 5 5','125',0,1),(127,67,'1 2\n3 4','4 + 6i',0,1),(128,67,'1.5 0.5\n2.5 1.5','4 + 2i',0,1),(129,68,'1 2 2 4','YES',0,1),(130,68,'1 3 1 4','NO',0,1),(131,69,'Hello C++','Ghi file thanh cong',0,1),(132,69,'CodePulse Learning','Ghi file thanh cong',0,1),(133,70,'Welcome','Welcome',0,1),(134,71,'12345','Ghi file nhi phan thanh cong',0,1),(135,72,'1 99','99',0,1),(136,72,'10 500','500',0,1),(137,73,'Hello\nC++','Lines: 2, Chars: 8',0,1),(138,74,'2 \n1 50.5 2 49.5','100',0,1),(139,75,'5 4','20',0,1),(140,75,'2.5 10','25',0,1),(141,76,'Toyota\n2024','Brand: Toyota, Year: 2024',0,1),(142,77,'500.5','Balance: 500.5',0,1),(143,77,'-100','Balance: 0',0,1),(144,78,'8.5','Score: 8.5',0,1),(145,78,'12','Diem khong hop le\nScore: 0',0,1),(146,79,'','Animal speaks\nDog wags tail',0,1),(147,80,'Alex \n5000','Manager: Alex, Salary: 5000',0,1),(148,80,'Maria\n7500.5','Manager: Maria, Salary: 7500.5',0,1),(149,81,'','Meow\nWoof',0,1),(150,82,'4 2','16 12.56',0,1),(151,82,'10 1','100 3.14',0,1),(152,83,'','Laptop is booting Windows...\nPhone is showing Apple logo...',0,1),(154,84,'100','Paid 100 using Credit Card\nPaid 100 using E-Wallet',0,1),(155,84,'25.5','Paid 25.5 using Credit Card\nPaid 25.5 using E-Wallet',0,1),(156,85,'CodePulse \n20','Name: CodePulse, Age: 20',0,1),(157,86,'5','Array created\nArray destroyed',0,1),(158,87,'','Total users: 3',0,1),(159,88,'3','27',0,1),(160,88,'5','125',0,1),(161,90,'123456','Hacked password: 123456',0,1),(162,91,'Intel i9','Computer with CPU: Intel i9',0,1),(163,92,'Mr. Smith','Department Head: Mr. Smith',1,1),(164,93,'','Derived show: 10',0,1),(165,94,'','SuperRobot moves fast',0,1),(166,95,'FullTime: \"An\", 2000','An - Luong: 2000',0,1),(167,95,'PartTime: \"Binh\", 50, 20','Binh - Luong: 1000',0,1);
/*!40000 ALTER TABLE `test_cases` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2026-01-31 13:14:05
